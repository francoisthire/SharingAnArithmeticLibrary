Require Import leibniz.
Definition True : Prop := forall z : Prop, (z) -> z.
Definition False : Prop := forall z : Prop, z.
Definition Imp : Prop -> Prop -> Prop := fun x : Prop => fun y : Prop => (x) -> y.
Definition Not : Prop -> Prop := fun x : Prop => (x) -> False.
Definition And : Prop -> Prop -> Prop := fun x : Prop => fun y : Prop => forall z : Prop, ((x) -> (y) -> z) -> z.
Definition Or : Prop -> Prop -> Prop := fun x : Prop => fun y : Prop => forall z : Prop, ((x) -> z) -> ((y) -> z) -> z.
Definition Ex : forall A : Type, ((A) -> Prop) -> Prop := fun A : Type => fun f : (A) -> Prop => forall z : Prop, (forall x : A, ((f) (x)) -> z) -> z.
Definition I : True := fun z : Prop => fun p : z => p.
Parameter eq : forall A : Type, (A) -> (A) -> Prop.
Axiom refl : forall A : Type, forall x : A, (((eq) (A)) (x)) (x).
Axiom eq_ind : forall A : Type, forall x : A, forall P : (A) -> Prop, ((P) (x)) -> forall y : A, ((((eq) (A)) (x)) (y)) -> (P) (y).
Definition eq_rect_r : forall A : Type, forall a : A, forall x : A, ((((eq) (A)) (x)) (a)) -> forall P : (A) -> Prop, ((P) (a)) -> (P) (x) := fun A : Type => fun a : A => fun x : A => fun p : (((eq) (A)) (x)) (a) => ((((((eq_ind) (A)) (x)) (fun Joker_ : A => forall P : (A) -> Prop, ((P) (Joker_)) -> (P) (x))) (fun P : (A) -> Prop => fun auto : (P) (x) => auto)) (a)) (p).
Definition eq_ind_r : forall A : Type, forall a : A, forall P : (A) -> Prop, ((P) (a)) -> forall x : A, ((((eq) (A)) (x)) (a)) -> (P) (x) := fun A : Type => fun a : A => fun P : (A) -> Prop => fun p : (P) (a) => fun x0 : A => fun p0 : (((eq) (A)) (x0)) (a) => ((((((eq_rect_r) (A)) (a)) (x0)) (p0)) (fun x01 : A => (P) (x01))) (p).
Definition rewrite_l : forall A : Type, forall x : A, forall P : (A) -> Prop, ((P) (x)) -> forall y : A, ((((eq) (A)) (x)) (y)) -> (P) (y) := fun A : Type => fun x : A => fun P : (A) -> Prop => fun Hx : (P) (x) => fun y : A => fun Heq : (((eq) (A)) (x)) (y) => ((((((eq_ind) (A)) (x)) (fun Joker_ : A => (P) (Joker_))) (Hx)) (y)) (Heq).
Definition sym_eq : forall A : Type, forall x : A, forall y : A, ((((eq) (A)) (x)) (y)) -> (((eq) (A)) (y)) (x) := fun A : Type => fun x : A => fun y : A => fun Heq : (((eq) (A)) (x)) (y) => ((((((rewrite_l) (A)) (x)) (fun Joker_ : A => (((eq) (A)) (Joker_)) (x))) (((refl) (A)) (x))) (y)) (((((((rewrite_l) (A)) (x)) (fun Joker_ : A => (((eq) (A)) (x)) (Joker_))) (((refl) (A)) (x))) (y)) (Heq)).
Definition rewrite_r : forall A : Type, forall x : A, forall P : (A) -> Prop, ((P) (x)) -> forall y : A, ((((eq) (A)) (y)) (x)) -> (P) (y) := fun A : Type => fun x : A => fun P : (A) -> Prop => fun Hx : (P) (x) => fun y : A => fun Heq : (((eq) (A)) (y)) (x) => ((((((eq_ind) (A)) (x)) (fun Joker_ : A => (P) (Joker_))) (Hx)) (y)) (((((sym_eq) (A)) (y)) (x)) (Heq)).
Definition eq_coerc : forall A : Prop, forall B : Prop, (A) -> ((((eq) Prop) (A)) (B)) -> B := fun A : Prop => fun B : Prop => fun Ha : A => fun Heq : (((eq) Prop) (A)) (B) => ((((((eq_ind) Prop) (A)) (fun x_19 : Prop => x_19)) (Ha)) (B)) (Heq).
Definition trans_eq : forall A : Type, forall x : A, forall y : A, forall z : A, ((((eq) (A)) (x)) (y)) -> ((((eq) (A)) (y)) (z)) -> (((eq) (A)) (x)) (z) := fun A : Type => fun x : A => fun y : A => fun z : A => fun H1 : (((eq) (A)) (x)) (y) => fun H2 : (((eq) (A)) (y)) (z) => ((((((eq_ind_r) (A)) (y)) (fun x0 : A => (((eq) (A)) (x0)) (z))) (((((((rewrite_l) (A)) (x)) (fun Joker_ : A => (((eq) (A)) (Joker_)) (z))) (((((((rewrite_l) (A)) (x)) (fun Joker_ : A => (((eq) (A)) (x)) (Joker_))) (((refl) (A)) (x))) (z)) (((((((rewrite_r) (A)) (y)) (fun Joker_ : A => (((eq) (A)) (Joker_)) (z))) (H2)) (x)) (H1)))) (y)) (H1))) (x)) (H1).
Definition eq_f : forall A : Type, forall B : Type, forall f : (A) -> B, forall x : A, forall y : A, ((((eq) (A)) (x)) (y)) -> (((eq) (B)) ((f) (x))) ((f) (y)) := fun A : Type => fun B : Type => fun f : (A) -> B => fun x : A => fun y : A => fun H : (((eq) (A)) (x)) (y) => ((((((eq_ind_r) (A)) (y)) (fun x0 : A => (((eq) (B)) ((f) (x0))) ((f) (y)))) (((((((rewrite_l) (A)) (x)) (fun Joker_ : A => (((eq) (B)) ((f) (Joker_))) ((f) (y)))) (((((((rewrite_l) (A)) (x)) (fun Joker_ : A => (((eq) (B)) ((f) (x))) ((f) (Joker_)))) (((refl) (B)) ((f) (x)))) (y)) (H))) (y)) (H))) (x)) (H).
Definition eq_f2 : forall A : Type, forall B : Type, forall C : Type, forall f : (A) -> (B) -> C, forall x1 : A, forall x2 : A, forall y1 : B, forall y2 : B, ((((eq) (A)) (x1)) (x2)) -> ((((eq) (B)) (y1)) (y2)) -> (((eq) (C)) (((f) (x1)) (y1))) (((f) (x2)) (y2)) := fun A : Type => fun B : Type => fun C : Type => fun f : (A) -> (B) -> C => fun x1 : A => fun x2 : A => fun y1 : B => fun y2 : B => fun E1 : (((eq) (A)) (x1)) (x2) => fun E2 : (((eq) (B)) (y1)) (y2) => ((((((eq_ind_r) (A)) (x2)) (fun x : A => (((eq) (C)) (((f) (x)) (y1))) (((f) (x2)) (y2)))) (((((((eq_ind_r) (B)) (y2)) (fun x : B => (((eq) (C)) (((f) (x2)) (x))) (((f) (x2)) (y2)))) (((((((rewrite_l) (A)) (x1)) (fun Joker_ : A => (((eq) (C)) (((f) (Joker_)) (y2))) (((f) (x2)) (y2)))) (((((((rewrite_l) (B)) (y1)) (fun Joker_ : B => (((eq) (C)) (((f) (x1)) (Joker_))) (((f) (x2)) (y2)))) (((((((rewrite_l) (A)) (x1)) (fun Joker_ : A => (((eq) (C)) (((f) (x1)) (y1))) (((f) (Joker_)) (y2)))) (((((((rewrite_l) (B)) (y1)) (fun Joker_ : B => (((eq) (C)) (((f) (x1)) (y1))) (((f) (x1)) (Joker_)))) (((refl) (C)) (((f) (x1)) (y1)))) (y2)) (E2))) (x2)) (E1))) (y2)) (E2))) (x2)) (E1))) (y1)) (E2))) (x1)) (E1).
Definition falsity : forall t : Prop, (False) -> t := fun t : Prop => fun f : forall x : Prop, x => (f) (t).
Definition Not_ind : forall A : Prop, forall Q : Prop, (((A) -> False) -> Q) -> ((Not) (A)) -> Q := fun A : Prop => fun Q : Prop => fun F : ((A) -> False) -> Q => fun N : (Not) (A) => (F) (N).
Definition absurd : forall A : Prop, (A) -> ((Not) (A)) -> False := fun A : Prop => fun H : A => fun Hn : (Not) (A) => ((((Not_ind) (A)) (False)) (fun Jokerx_80 : (A) -> False => (Jokerx_80) (H))) (Hn).
Definition not_to_not : forall A : Prop, forall B : Prop, ((A) -> B) -> ((Not) (B)) -> (Not) (A) := fun A : Prop => fun B : Prop => fun auto : (A) -> B => fun auto' : (Not) (B) => fun auto'' : A => (((absurd) (B)) ((auto) (auto''))) (auto').
Definition sym_not_eq : forall A : Type, forall x : A, forall y : A, ((Not) ((((eq) (A)) (x)) (y))) -> (Not) ((((eq) (A)) (y)) (x)) := fun A : Type => fun x : A => fun y : A => fun auto : (Not) ((((eq) (A)) (x)) (y)) => fun auto' : (((eq) (A)) (y)) (x) => (((absurd) ((((eq) (A)) (x)) (y))) (((((((rewrite_r) (A)) (x)) (fun Joker_ : A => (((eq) (A)) (x)) (Joker_))) (((refl) (A)) (x))) (y)) (auto'))) (auto).
Definition match_And_prop : forall A : Prop, forall B : Prop, forall return_ : Prop, ((A) -> (B) -> return_) -> (((And) (A)) (B)) -> return_ := fun A : Prop => fun B : Prop => fun return_ : Prop => fun case : (A) -> (B) -> return_ => fun and : ((And) (A)) (B) => ((and) (return_)) (case).
Definition proj1 : forall A : Prop, forall B : Prop, (((And) (A)) (B)) -> A := fun A : Prop => fun B : Prop => fun AB : ((And) (A)) (B) => (((((match_And_prop) (A)) (B)) (A)) (fun Jokerx_120 : A => fun Jokerx_119 : B => Jokerx_120)) (AB).
Definition proj2 : forall A : Prop, forall B : Prop, (((And) (A)) (B)) -> B := fun A : Prop => fun B : Prop => fun AB : ((And) (A)) (B) => (((((match_And_prop) (A)) (B)) (B)) (fun Jokerx_120 : A => fun Jokerx_119 : B => Jokerx_119)) (AB).
Definition match_Or_prop : forall A : Prop, forall B : Prop, forall return_ : Prop, ((A) -> return_) -> ((B) -> return_) -> (((Or) (A)) (B)) -> return_ := fun A : Prop => fun B : Prop => fun return_ : Prop => fun case_A : (A) -> return_ => fun case_B : (B) -> return_ => fun or : ((Or) (A)) (B) => (((or) (return_)) (case_A)) (case_B).
Definition decidable : Prop -> Prop := fun A : Prop => ((Or) (A)) ((Not) (A)).
Definition match_ex_prop : forall A : Type, forall P : (A) -> Prop, forall return_ : Prop, (forall x : A, ((P) (x)) -> return_) -> (((Ex) (A)) (P)) -> return_ := fun A : Type => fun P : (A) -> Prop => fun return_ : Prop => fun case : forall x : A, ((P) (x)) -> return_ => fun Ex : ((Ex) (A)) (P) => ((Ex) (return_)) (case).
Definition reflexive : forall A : Type, ((A) -> (A) -> Prop) -> Prop := fun A : Type => fun R : (A) -> (A) -> Prop => forall x : A, ((R) (x)) (x).
Definition transitive : forall A : Type, ((A) -> (A) -> Prop) -> Prop := fun A : Type => fun R : (A) -> (A) -> Prop => forall x : A, forall y : A, forall z : A, (((R) (x)) (y)) -> (((R) (y)) (z)) -> ((R) (x)) (z).
Definition RC : forall A : Type, ((A) -> (A) -> Prop) -> (A) -> (A) -> Prop := fun A : Type => fun R : (A) -> (A) -> Prop => fun x : A => fun y : A => ((Or) (((R) (x)) (y))) ((((eq) (A)) (x)) (y)).
Definition RC_reflexive : forall A : Type, forall R : (A) -> (A) -> Prop, ((reflexive) (A)) (((RC) (A)) (R)) := fun A : Type => fun R : (A) -> (A) -> Prop => fun x : A => fun z : Prop => fun l : (((R) (x)) (x)) -> z => fun r : ((((eq) (A)) (x)) (x)) -> z => (r) (((refl) (A)) (x)).
Definition injective : forall A : Type, forall B : Type, ((A) -> B) -> Prop := fun A : Type => fun B : Type => fun f : (A) -> B => forall x : A, forall y : A, ((((eq) (B)) ((f) (x))) ((f) (y))) -> (((eq) (A)) (x)) (y).
Definition commutative : forall A : Type, ((A) -> (A) -> A) -> Prop := fun A : Type => fun f : (A) -> (A) -> A => forall x : A, forall y : A, (((eq) (A)) (((f) (x)) (y))) (((f) (y)) (x)).
Definition associative : forall A : Type, ((A) -> (A) -> A) -> Prop := fun A : Type => fun f : (A) -> (A) -> A => forall x : A, forall y : A, forall z : A, (((eq) (A)) (((f) (((f) (x)) (y))) (z))) (((f) (x)) (((f) (y)) (z))).
Definition monotonic : forall A : Type, ((A) -> (A) -> Prop) -> ((A) -> A) -> Prop := fun A : Type => fun R : (A) -> (A) -> Prop => fun f : (A) -> A => forall x : A, forall y : A, (((R) (x)) (y)) -> ((R) ((f) (x))) ((f) (y)).
Definition distributive : forall A : Type, ((A) -> (A) -> A) -> ((A) -> (A) -> A) -> Prop := fun A : Type => fun f : (A) -> (A) -> A => fun g : (A) -> (A) -> A => forall x : A, forall y : A, forall z : A, (((eq) (A)) (((f) (x)) (((g) (y)) (z)))) (((g) (((f) (x)) (y))) (((f) (x)) (z))).
Parameter bool : Type.
Parameter true : bool.
Parameter false : bool.
Axiom match_bool_prop : forall return_ : (bool) -> Prop, ((return_) (true)) -> ((return_) (false)) -> forall z : bool, (return_) (z).
Parameter match_bool_type : forall return_ : Type, (return_) -> (return_) -> (bool) -> return_.
Axiom eq_match_bool_type_true : forall return_ : Type, forall case_true : return_, forall case_false : return_, (((leibniz) (return_)) (((((match_bool_type) (return_)) (case_true)) (case_false)) (true))) (case_true).
Axiom eq_match_bool_type_false : forall return_ : Type, forall case_true : return_, forall case_false : return_, (((leibniz) (return_)) (((((match_bool_type) (return_)) (case_true)) (case_false)) (false))) (case_false).
Definition sym_eq_match_bool_type_true : forall return_ : Type, forall case_true : return_, forall case_false : return_, (((leibniz) (return_)) (case_true)) (((((match_bool_type) (return_)) (case_true)) (case_false)) (true)) := fun return_type : Type => fun case_true : return_type => fun case_false : return_type => ((((sym_leibniz) (return_type)) (((((match_bool_type) (return_type)) (case_true)) (case_false)) (true))) (case_true)) ((((eq_match_bool_type_true) (return_type)) (case_true)) (case_false)).
Definition sym_eq_match_bool_type_false : forall return_ : Type, forall case_true : return_, forall case_false : return_, (((leibniz) (return_)) (case_false)) (((((match_bool_type) (return_)) (case_true)) (case_false)) (false)) := fun return_type : Type => fun case_true : return_type => fun case_false : return_type => ((((sym_leibniz) (return_type)) (((((match_bool_type) (return_type)) (case_true)) (case_false)) (false))) (case_false)) ((((eq_match_bool_type_false) (return_type)) (case_true)) (case_false)).
Definition bool_discr : forall x : bool, forall y : bool, ((((eq) (bool)) (x)) (y)) -> ((((match_bool_type) Prop) (((((match_bool_type) Prop) (forall P : Prop, (P) -> P)) (forall P : Prop, P)) (y))) (((((match_bool_type) Prop) (forall P : Prop, P)) (forall P : Prop, (P) -> P)) (y))) (x) := fun x : bool => fun y : bool => fun Deq : (((eq) (bool)) (x)) (y) => ((((((eq_ind) (bool)) (x)) (fun x_13 : bool => ((((match_bool_type) Prop) (((((match_bool_type) Prop) (forall P : Prop, (P) -> P)) (forall P : Prop, P)) (x_13))) (((((match_bool_type) Prop) (forall P : Prop, P)) (forall P : Prop, (P) -> P)) (x_13))) (x))) (((((match_bool_prop) (fun Joker_ : bool => ((((match_bool_type) Prop) (((((match_bool_type) Prop) (forall P : Prop, (P) -> P)) (forall P : Prop, P)) (Joker_))) (((((match_bool_type) Prop) (forall P : Prop, P)) (forall P : Prop, (P) -> P)) (Joker_))) (Joker_))) ((((((sym_eq_match_bool_type_true) Prop) (((((match_bool_type) Prop) (forall P : Prop, (P) -> P)) (forall P : Prop, P)) (true))) (((((match_bool_type) Prop) (forall P : Prop, P)) (forall P : Prop, (P) -> P)) (true))) (fun x0 : Prop => x0)) ((((((sym_eq_match_bool_type_true) Prop) (forall P : Prop, (P) -> P)) (forall P : Prop, P)) (fun x0 : Prop => x0)) (fun P : Prop => fun DH : P => DH)))) ((((((sym_eq_match_bool_type_false) Prop) (((((match_bool_type) Prop) (forall P : Prop, (P) -> P)) (forall P : Prop, P)) (false))) (((((match_bool_type) Prop) (forall P : Prop, P)) (forall P : Prop, (P) -> P)) (false))) (fun x0 : Prop => x0)) ((((((sym_eq_match_bool_type_false) Prop) (forall P : Prop, P)) (forall P : Prop, (P) -> P)) (fun x0 : Prop => x0)) (fun P : Prop => fun DH : P => DH)))) (x))) (y)) (Deq).
Definition not_eq_true_false : (Not) ((((eq) (bool)) (true)) (false)) := fun Heq : (((eq) (bool)) (true)) (false) => ((((((eq_match_bool_type_false) Prop) (forall P : Prop, (P) -> P)) (forall P : Prop, P)) (fun x : Prop => x)) ((((((eq_match_bool_type_true) Prop) (((((match_bool_type) Prop) (forall P : Prop, (P) -> P)) (forall P : Prop, P)) (false))) (((((match_bool_type) Prop) (forall P : Prop, P)) (forall P : Prop, (P) -> P)) (false))) (fun x : Prop => x)) ((((bool_discr) (true)) (false)) (Heq)))) (False).
Definition notb : (bool) -> bool := fun b : bool => ((((match_bool_type) (bool)) (false)) (true)) (b).
Definition andb : (bool) -> (bool) -> bool := fun b1 : bool => fun b2 : bool => ((((match_bool_type) (bool)) (b2)) (false)) (b1).
Definition andb_true_l : forall b1 : bool, forall b2 : bool, ((((eq) (bool)) (((andb) (b1)) (b2))) (true)) -> (((eq) (bool)) (b1)) (true) := fun b1 : bool => ((((match_bool_prop) (fun Joker_ : bool => forall b2 : bool, ((((eq) (bool)) (((andb) (Joker_)) (b2))) (true)) -> (((eq) (bool)) (Joker_)) (true))) (fun b2 : bool => (((((sym_eq_match_bool_type_true) (bool)) (b2)) (false)) (fun x : bool => ((((eq) (bool)) (x)) (true)) -> (((eq) (bool)) (true)) (true))) (fun auto : (((eq) (bool)) (b2)) (true) => ((((((rewrite_l) (bool)) (b2)) (fun Joker_ : bool => (((eq) (bool)) (Joker_)) (true))) (((((((rewrite_l) (bool)) (b2)) (fun Joker_ : bool => (((eq) (bool)) (b2)) (Joker_))) (((refl) (bool)) (b2))) (true)) (auto))) (true)) (auto)))) (fun Jokerb2 : bool => (((((sym_eq_match_bool_type_false) (bool)) (Jokerb2)) (false)) (fun x : bool => ((((eq) (bool)) (x)) (true)) -> (((eq) (bool)) (false)) (true))) (fun auto : (((eq) (bool)) (false)) (true) => ((((((rewrite_r) (bool)) (true)) (fun Joker_ : bool => (((eq) (bool)) (Joker_)) (true))) (((refl) (bool)) (true))) (false)) (auto)))) (b1).
Definition andb_true_r : forall b1 : bool, forall b2 : bool, ((((eq) (bool)) (((andb) (b1)) (b2))) (true)) -> (((eq) (bool)) (b2)) (true) := fun b1 : bool => fun b2 : bool => ((((match_bool_prop) (fun Joker_ : bool => ((((eq) (bool)) (((andb) (Joker_)) (b2))) (true)) -> (((eq) (bool)) (b2)) (true))) ((((((sym_eq_match_bool_type_true) (bool)) (b2)) (false)) (fun x : bool => ((((eq) (bool)) (x)) (true)) -> (((eq) (bool)) (b2)) (true))) (fun auto : (((eq) (bool)) (b2)) (true) => ((((((rewrite_l) (bool)) (b2)) (fun Joker_ : bool => (((eq) (bool)) (b2)) (Joker_))) (((refl) (bool)) (b2))) (true)) (auto)))) ((((((sym_eq_match_bool_type_false) (bool)) (b2)) (false)) (fun x : bool => ((((eq) (bool)) (x)) (true)) -> (((eq) (bool)) (b2)) (true))) (((((match_bool_prop) (fun Joker_ : bool => ((((eq) (bool)) (false)) (true)) -> (((eq) (bool)) (Joker_)) (true))) (fun auto : (((eq) (bool)) (false)) (true) => ((refl) (bool)) (true))) (fun auto : (((eq) (bool)) (false)) (true) => ((((((rewrite_r) (bool)) (true)) (fun Joker_ : bool => (((eq) (bool)) (Joker_)) (true))) (((refl) (bool)) (true))) (false)) (auto))) (b2)))) (b1).
Definition true_or_false : forall b : bool, ((Or) ((((eq) (bool)) (b)) (true))) ((((eq) (bool)) (b)) (false)) := fun b : bool => ((((match_bool_prop) (fun Joker_ : bool => ((Or) ((((eq) (bool)) (Joker_)) (true))) ((((eq) (bool)) (Joker_)) (false)))) (fun z : Prop => fun l : ((((eq) (bool)) (true)) (true)) -> z => fun r : ((((eq) (bool)) (true)) (false)) -> z => (l) (((refl) (bool)) (true)))) ((((RC_reflexive) (bool)) (fun Joker_ : bool => fun Joker0 : bool => (((eq) (bool)) (false)) (true))) (false))) (b).
Parameter nat : Type.
Parameter O : nat.
Parameter S : (nat) -> nat.
Axiom match_nat_prop : forall return_ : (nat) -> Prop, ((return_) (O)) -> (forall n : nat, (return_) ((S) (n))) -> forall z : nat, (return_) (z).
Parameter match_nat_type : forall return_ : Type, (return_) -> ((nat) -> return_) -> (nat) -> return_.
Axiom eq_match_nat_type_O : forall return_type : Type, forall case_O : return_type, forall case_S : (nat) -> return_type, (((leibniz) (return_type)) (((((match_nat_type) (return_type)) (case_O)) (case_S)) (O))) (case_O).
Definition sym_eq_match_nat_type_O : forall return_type : Type, forall case_O : return_type, forall case_S : (nat) -> return_type, (((leibniz) (return_type)) (case_O)) (((((match_nat_type) (return_type)) (case_O)) (case_S)) (O)) := fun return_type : Type => fun case_O : return_type => fun case_S : (nat) -> return_type => ((((sym_leibniz) (return_type)) (((((match_nat_type) (return_type)) (case_O)) (case_S)) (O))) (case_O)) ((((eq_match_nat_type_O) (return_type)) (case_O)) (case_S)).
Axiom eq_match_nat_type_S : forall return_type : Type, forall case_O : return_type, forall case_S : (nat) -> return_type, forall n : nat, (((leibniz) (return_type)) (((((match_nat_type) (return_type)) (case_O)) (case_S)) ((S) (n)))) ((case_S) (n)).
Definition sym_eq_match_nat_type_S : forall return_type : Type, forall case_O : return_type, forall case_S : (nat) -> return_type, forall n : nat, (((leibniz) (return_type)) ((case_S) (n))) (((((match_nat_type) (return_type)) (case_O)) (case_S)) ((S) (n))) := fun return_type : Type => fun case_O : return_type => fun case_S : (nat) -> return_type => fun n : nat => ((((sym_leibniz) (return_type)) (((((match_nat_type) (return_type)) (case_O)) (case_S)) ((S) (n)))) ((case_S) (n))) (((((eq_match_nat_type_S) (return_type)) (case_O)) (case_S)) (n)).
Parameter filter_nat_type : forall return_ : Type, ((nat) -> return_) -> (nat) -> return_.
Axiom eq_filter_nat_type_O : forall return_type : Type, forall return_ : (nat) -> return_type, (((leibniz) (return_type)) ((((filter_nat_type) (return_type)) (return_)) (O))) ((return_) (O)).
Definition sym_eq_filter_nat_type_O : forall return_type : Type, forall return_ : (nat) -> return_type, (((leibniz) (return_type)) ((return_) (O))) ((((filter_nat_type) (return_type)) (return_)) (O)) := fun return_type : Type => fun return_ : (nat) -> return_type => ((((sym_leibniz) (return_type)) ((((filter_nat_type) (return_type)) (return_)) (O))) ((return_) (O))) (((eq_filter_nat_type_O) (return_type)) (return_)).
Axiom eq_filter_nat_type_S : forall return_type : Type, forall return_ : (nat) -> return_type, forall n : nat, (((leibniz) (return_type)) ((((filter_nat_type) (return_type)) (return_)) ((S) (n)))) ((return_) ((S) (n))).
Definition sym_eq_filter_nat_type_S : forall return_type : Type, forall return_ : (nat) -> return_type, forall n : nat, (((leibniz) (return_type)) ((return_) ((S) (n)))) ((((filter_nat_type) (return_type)) (return_)) ((S) (n))) := fun return_type : Type => fun return_ : (nat) -> return_type => fun n : nat => ((((sym_leibniz) (return_type)) ((((filter_nat_type) (return_type)) (return_)) ((S) (n)))) ((return_) ((S) (n)))) ((((eq_filter_nat_type_S) (return_type)) (return_)) (n)).
Axiom nat_ind : forall Q : (nat) -> Prop, ((Q) (O)) -> (forall x : nat, ((Q) (x)) -> (Q) ((S) (x))) -> forall x : nat, (Q) (x).
Definition pred : (nat) -> nat := fun n : nat => ((((match_nat_type) (nat)) (O)) (fun p : nat => p)) (n).
Definition not_zero : (nat) -> Prop := fun n : nat => ((((match_nat_type) Prop) (False)) (fun p : nat => True)) (n).
Parameter le : (nat) -> (nat) -> Prop.
Axiom le_n : forall n : nat, ((le) (n)) (n).
Axiom le_S : forall n : nat, forall m : nat, (((le) (n)) (m)) -> ((le) (n)) ((S) (m)).
Axiom match_le_prop : forall n : nat, forall return_ : (nat) -> Prop, ((return_) (n)) -> (forall m : nat, (return_) ((S) (m))) -> forall m : nat, (((le) (n)) (m)) -> (return_) (m).
Axiom le_ind : forall n : nat, forall Q : (nat) -> Prop, ((Q) (n)) -> (forall m : nat, (((le) (n)) (m)) -> ((Q) (m)) -> (Q) ((S) (m))) -> forall m : nat, (((le) (n)) (m)) -> (Q) (m).
Definition lt : (nat) -> (nat) -> Prop := fun n : nat => fun m : nat => ((le) ((S) (n))) (m).
Parameter plus : (nat) -> (nat) -> nat.
Parameter plus_body : (nat) -> (nat) -> nat.
Axiom eq_plus : forall n : nat, (((leibniz) ((nat) -> nat)) ((plus) (n))) ((((filter_nat_type) ((nat) -> nat)) (plus_body)) (n)).
Definition sym_eq_plus : forall n : nat, (((leibniz) ((nat) -> nat)) ((((filter_nat_type) ((nat) -> nat)) (plus_body)) (n))) ((plus) (n)) := fun n : nat => ((((sym_leibniz) ((nat) -> nat)) ((plus) (n))) ((((filter_nat_type) ((nat) -> nat)) (plus_body)) (n))) ((eq_plus) (n)).
Axiom eq_plus_body_O : (((leibniz) ((nat) -> nat)) ((plus_body) (O))) (fun m : nat => m).
Definition sym_eq_plus_body_O : (((leibniz) ((nat) -> nat)) (fun m : nat => m)) ((plus_body) (O)) := ((((sym_leibniz) ((nat) -> nat)) ((plus_body) (O))) (fun m : nat => m)) (eq_plus_body_O).
Axiom eq_plus_body_S : forall n : nat, (((leibniz) ((nat) -> nat)) ((plus_body) ((S) (n)))) (fun m : nat => (S) (((plus) (n)) (m))).
Definition sym_eq_plus_body_S : forall n : nat, (((leibniz) ((nat) -> nat)) (fun m : nat => (S) (((plus) (n)) (m)))) ((plus_body) ((S) (n))) := fun n : nat => ((((sym_leibniz) ((nat) -> nat)) ((plus_body) ((S) (n)))) (fun m : nat => (S) (((plus) (n)) (m)))) ((eq_plus_body_S) (n)).
Parameter times : (nat) -> (nat) -> nat.
Parameter times_body : (nat) -> (nat) -> nat.
Axiom eq_times : forall n : nat, (((leibniz) ((nat) -> nat)) ((times) (n))) ((((filter_nat_type) ((nat) -> nat)) (times_body)) (n)).
Definition sym_eq_times : forall n : nat, (((leibniz) ((nat) -> nat)) ((((filter_nat_type) ((nat) -> nat)) (times_body)) (n))) ((times) (n)) := fun n : nat => ((((sym_leibniz) ((nat) -> nat)) ((times) (n))) ((((filter_nat_type) ((nat) -> nat)) (times_body)) (n))) ((eq_times) (n)).
Axiom eq_times_body_O : (((leibniz) ((nat) -> nat)) ((times_body) (O))) (fun m : nat => O).
Definition sym_eq_times_body_O : (((leibniz) ((nat) -> nat)) (fun m : nat => O)) ((times_body) (O)) := ((((sym_leibniz) ((nat) -> nat)) ((times_body) (O))) (fun m : nat => O)) (eq_times_body_O).
Axiom eq_times_body_S : forall n : nat, (((leibniz) ((nat) -> nat)) ((times_body) ((S) (n)))) (fun m : nat => ((plus) (m)) (((times) (n)) (m))).
Definition sym_eq_times_body_S : forall n : nat, (((leibniz) ((nat) -> nat)) (fun m : nat => ((plus) (m)) (((times) (n)) (m)))) ((times_body) ((S) (n))) := fun n : nat => ((((sym_leibniz) ((nat) -> nat)) ((times_body) ((S) (n)))) (fun m : nat => ((plus) (m)) (((times) (n)) (m)))) ((eq_times_body_S) (n)).
Parameter minus : (nat) -> (nat) -> nat.
Parameter minus_body : (nat) -> (nat) -> nat.
Axiom eq_minus : forall n : nat, (((leibniz) ((nat) -> nat)) ((minus) (n))) ((((filter_nat_type) ((nat) -> nat)) (minus_body)) (n)).
Definition sym_eq_minus : forall n : nat, (((leibniz) ((nat) -> nat)) ((((filter_nat_type) ((nat) -> nat)) (minus_body)) (n))) ((minus) (n)) := fun n : nat => ((((sym_leibniz) ((nat) -> nat)) ((minus) (n))) ((((filter_nat_type) ((nat) -> nat)) (minus_body)) (n))) ((eq_minus) (n)).
Axiom eq_minus_body_O : (((leibniz) ((nat) -> nat)) ((minus_body) (O))) (fun m : nat => O).
Definition sym_eq_minus_body_O : (((leibniz) ((nat) -> nat)) (fun m : nat => O)) ((minus_body) (O)) := ((((sym_leibniz) ((nat) -> nat)) ((minus_body) (O))) (fun m : nat => O)) (eq_minus_body_O).
Axiom eq_minus_body_S : forall n : nat, (((leibniz) ((nat) -> nat)) ((minus_body) ((S) (n)))) (fun m : nat => ((((match_nat_type) (nat)) ((S) (n))) (fun q : nat => ((minus) (n)) (q))) (m)).
Definition sym_eq_minus_body_S : forall n : nat, (((leibniz) ((nat) -> nat)) (fun m : nat => ((((match_nat_type) (nat)) ((S) (n))) (fun q : nat => ((minus) (n)) (q))) (m))) ((minus_body) ((S) (n))) := fun n : nat => ((((sym_leibniz) ((nat) -> nat)) ((minus_body) ((S) (n)))) (fun m : nat => ((((match_nat_type) (nat)) ((S) (n))) (fun q : nat => ((minus) (n)) (q))) (m))) ((eq_minus_body_S) (n)).
Definition nat_case : forall n : nat, forall P : (nat) -> Prop, (((((eq) (nat)) (n)) (O)) -> (P) (O)) -> (forall m : nat, ((((eq) (nat)) (n)) ((S) (m))) -> (P) ((S) (m))) -> (P) (n) := fun n : nat => fun P : (nat) -> Prop => ((((nat_ind) (fun Jokerx_365 : nat => (((((eq) (nat)) (Jokerx_365)) (O)) -> (P) (O)) -> (forall m : nat, ((((eq) (nat)) (Jokerx_365)) ((S) (m))) -> (P) ((S) (m))) -> (P) (Jokerx_365))) (fun auto : ((((eq) (nat)) (O)) (O)) -> (P) (O) => fun auto' : forall m : nat, ((((eq) (nat)) (O)) ((S) (m))) -> (P) ((S) (m)) => (auto) (((refl) (nat)) (O)))) (fun x_366 : nat => fun Jokerx_368 : (((((eq) (nat)) (x_366)) (O)) -> (P) (O)) -> (forall m : nat, ((((eq) (nat)) (x_366)) ((S) (m))) -> (P) ((S) (m))) -> (P) (x_366) => fun auto : ((((eq) (nat)) ((S) (x_366))) (O)) -> (P) (O) => fun auto' : forall m : nat, ((((eq) (nat)) ((S) (x_366))) ((S) (m))) -> (P) ((S) (m)) => ((auto') (x_366)) (((refl) (nat)) ((S) (x_366))))) (n).
Definition nat_elim2 : forall R : (nat) -> (nat) -> Prop, (forall n : nat, ((R) (O)) (n)) -> (forall n : nat, ((R) ((S) (n))) (O)) -> (forall n : nat, forall m : nat, (((R) (n)) (m)) -> ((R) ((S) (n))) ((S) (m))) -> forall n : nat, forall m : nat, ((R) (n)) (m) := fun R : (nat) -> (nat) -> Prop => fun ROn : forall n : nat, ((R) (O)) (n) => fun RSO : forall n : nat, ((R) ((S) (n))) (O) => fun RSS : forall n : nat, forall m : nat, (((R) (n)) (m)) -> ((R) ((S) (n))) ((S) (m)) => fun n : nat => ((((nat_ind) (fun Jokerx_365 : nat => forall m : nat, ((R) (Jokerx_365)) (m))) (fun m : nat => (ROn) (m))) (fun n0 : nat => fun Rn0m : forall m : nat, ((R) (n0)) (m) => fun m : nat => ((((match_nat_prop) (fun Joker_ : nat => ((R) ((S) (n0))) (Joker_))) ((RSO) (n0))) (fun auto : nat => (((RSS) (n0)) (auto)) ((Rn0m) (auto)))) (m))) (n).
Definition le_gen : forall P : (nat) -> Prop, forall n : nat, (forall i : nat, (((le) (i)) (n)) -> (P) (i)) -> (P) (n) := fun P : (nat) -> Prop => fun n : nat => fun auto : forall i : nat, (((le) (i)) (n)) -> (P) (i) => ((auto) (n)) ((le_n) (n)).
Definition pred_Sn : forall n : nat, (((eq) (nat)) (n)) ((pred) ((S) (n))) := fun n : nat => ((((((sym_eq_match_nat_type_S) (nat)) (O)) (fun p : nat => p)) (n)) (fun y : nat => (((eq) (nat)) (n)) (y))) (((refl) (nat)) (n)).
Definition injective_S : (((injective) (nat)) (nat)) (S) := fun x : nat => fun y : nat => fun auto : (((eq) (nat)) ((S) (x))) ((S) (y)) => ((((((rewrite_l) (nat)) (y)) (fun Joker_ : nat => (((eq) (nat)) (Joker_)) (y))) (((refl) (nat)) (y))) (x)) (((((((rewrite_r) (nat)) ((pred) ((S) (x)))) (fun Joker_ : nat => (((eq) (nat)) (y)) (Joker_))) (((((((rewrite_r) (nat)) ((S) (y))) (fun Joker_ : nat => (((eq) (nat)) (y)) ((pred) (Joker_)))) ((pred_Sn) (y))) ((S) (x))) (auto))) (x)) ((pred_Sn) (x))).
Definition S_pred : forall n : nat, (((lt) (O)) (n)) -> (((eq) (nat)) ((S) ((pred) (n)))) (n) := fun n : nat => fun posn : ((lt) (O)) (n) => ((((((match_le_prop) ((S) (O))) (fun Joker_ : nat => (((eq) (nat)) ((S) ((pred) (Joker_)))) (Joker_))) (((((((rewrite_l) (nat)) (O)) (fun Joker_ : nat => (((eq) (nat)) ((S) (Joker_))) ((S) (O)))) (((refl) (nat)) ((S) (O)))) ((pred) ((S) (O)))) ((pred_Sn) (O)))) (fun m : nat => ((((((rewrite_l) (nat)) (m)) (fun Joker_ : nat => (((eq) (nat)) ((S) (Joker_))) ((S) (m)))) (((refl) (nat)) ((S) (m)))) ((pred) ((S) (m)))) ((pred_Sn) (m)))) (n)) (posn).
Definition plus_O_n : forall n : nat, (((eq) (nat)) (n)) (((plus) (O)) (n)) := fun n : nat => (((sym_eq_plus) (O)) (fun y : (nat) -> nat => (((eq) (nat)) (n)) ((y) (n)))) (((((sym_eq_filter_nat_type_O) ((nat) -> nat)) (plus_body)) (fun y : (nat) -> nat => (((eq) (nat)) (n)) ((y) (n)))) (((sym_eq_plus_body_O) (fun y : (nat) -> nat => (((eq) (nat)) (n)) ((y) (n)))) (((refl) (nat)) (n)))).
Definition plus_n_O : forall n : nat, (((eq) (nat)) (n)) (((plus) (n)) (O)) := fun n : nat => ((((nat_ind) (fun Jokerx_365 : nat => (((eq) (nat)) (Jokerx_365)) (((plus) (Jokerx_365)) (O)))) ((((sym_eq_plus) (O)) (fun y : (nat) -> nat => (((eq) (nat)) (O)) ((y) (O)))) (((((sym_eq_filter_nat_type_O) ((nat) -> nat)) (plus_body)) (fun y : (nat) -> nat => (((eq) (nat)) (O)) ((y) (O)))) (((sym_eq_plus_body_O) (fun y : (nat) -> nat => (((eq) (nat)) (O)) ((y) (O)))) (((refl) (nat)) (O)))))) (fun x_366 : nat => fun Jokerx_368 : (((eq) (nat)) (x_366)) (((plus) (x_366)) (O)) => (((sym_eq_plus) ((S) (x_366))) (fun y : (nat) -> nat => (((eq) (nat)) ((S) (x_366))) ((y) (O)))) ((((((sym_eq_filter_nat_type_S) ((nat) -> nat)) (plus_body)) (x_366)) (fun y : (nat) -> nat => (((eq) (nat)) ((S) (x_366))) ((y) (O)))) ((((sym_eq_plus_body_S) (x_366)) (fun y : (nat) -> nat => (((eq) (nat)) ((S) (x_366))) ((y) (O)))) (((((((rewrite_l) (nat)) (x_366)) (fun Joker_ : nat => (((eq) (nat)) ((S) (x_366))) ((S) (Joker_)))) (((refl) (nat)) ((S) (x_366)))) (((plus) (x_366)) (O))) (Jokerx_368)))))) (n).
Definition plus_n_Sm : forall n : nat, forall m : nat, (((eq) (nat)) ((S) (((plus) (n)) (m)))) (((plus) (n)) ((S) (m))) := fun n : nat => ((((nat_ind) (fun Jokerx_365 : nat => forall m : nat, (((eq) (nat)) ((S) (((plus) (Jokerx_365)) (m)))) (((plus) (Jokerx_365)) ((S) (m))))) (fun m : nat => (((sym_eq_plus) (O)) (fun y : (nat) -> nat => (((eq) (nat)) ((S) ((y) (m)))) (((plus) (O)) ((S) (m))))) ((((sym_eq_plus) (O)) (fun y : (nat) -> nat => (((eq) (nat)) ((S) (((((filter_nat_type) ((nat) -> nat)) (plus_body)) (O)) (m)))) ((y) ((S) (m))))) (((((sym_eq_filter_nat_type_O) ((nat) -> nat)) (plus_body)) (fun y : (nat) -> nat => (((eq) (nat)) ((S) (((((filter_nat_type) ((nat) -> nat)) (plus_body)) (O)) (m)))) ((y) ((S) (m))))) (((((sym_eq_filter_nat_type_O) ((nat) -> nat)) (plus_body)) (fun y : (nat) -> nat => (((eq) (nat)) ((S) ((y) (m)))) (((plus_body) (O)) ((S) (m))))) (((sym_eq_plus_body_O) (fun y : (nat) -> nat => (((eq) (nat)) ((S) ((y) (m)))) (((plus_body) (O)) ((S) (m))))) (((sym_eq_plus_body_O) (fun y : (nat) -> nat => (((eq) (nat)) ((S) (m))) ((y) ((S) (m))))) (((refl) (nat)) ((S) (m)))))))))) (fun x_366 : nat => fun Jokerx_368 : forall m : nat, (((eq) (nat)) ((S) (((plus) (x_366)) (m)))) (((plus) (x_366)) ((S) (m))) => fun m : nat => (((sym_eq_plus) ((S) (x_366))) (fun y : (nat) -> nat => (((eq) (nat)) ((S) ((y) (m)))) (((plus) ((S) (x_366))) ((S) (m))))) ((((sym_eq_plus) ((S) (x_366))) (fun y : (nat) -> nat => (((eq) (nat)) ((S) (((((filter_nat_type) ((nat) -> nat)) (plus_body)) ((S) (x_366))) (m)))) ((y) ((S) (m))))) ((((((sym_eq_filter_nat_type_S) ((nat) -> nat)) (plus_body)) (x_366)) (fun y : (nat) -> nat => (((eq) (nat)) ((S) (((((filter_nat_type) ((nat) -> nat)) (plus_body)) ((S) (x_366))) (m)))) ((y) ((S) (m))))) ((((((sym_eq_filter_nat_type_S) ((nat) -> nat)) (plus_body)) (x_366)) (fun y : (nat) -> nat => (((eq) (nat)) ((S) ((y) (m)))) (((plus_body) ((S) (x_366))) ((S) (m))))) ((((sym_eq_plus_body_S) (x_366)) (fun y : (nat) -> nat => (((eq) (nat)) ((S) ((y) (m)))) (((plus_body) ((S) (x_366))) ((S) (m))))) ((((sym_eq_plus_body_S) (x_366)) (fun y : (nat) -> nat => (((eq) (nat)) ((S) ((S) (((plus) (x_366)) (m))))) ((y) ((S) (m))))) (((((((rewrite_r) (nat)) (((plus) (x_366)) ((S) (m)))) (fun Joker_ : nat => (((eq) (nat)) ((S) (Joker_))) ((S) (((plus) (x_366)) ((S) (m)))))) (((((((rewrite_r) (nat)) (((plus) (x_366)) ((S) ((S) (m))))) (fun Joker_ : nat => (((eq) (nat)) (Joker_)) ((S) (((plus) (x_366)) ((S) (m)))))) (((((((rewrite_r) (nat)) (((plus) (x_366)) ((S) ((S) (m))))) (fun Joker_ : nat => (((eq) (nat)) (((plus) (x_366)) ((S) ((S) (m))))) (Joker_))) (((refl) (nat)) (((plus) (x_366)) ((S) ((S) (m)))))) ((S) (((plus) (x_366)) ((S) (m))))) ((Jokerx_368) ((S) (m))))) ((S) (((plus) (x_366)) ((S) (m))))) ((Jokerx_368) ((S) (m))))) ((S) (((plus) (x_366)) (m)))) ((Jokerx_368) (m)))))))))) (n).
Definition commutative_plus : ((commutative) (nat)) (plus) := fun n : nat => ((((nat_ind) (fun Jokerx_365 : nat => forall y : nat, (((eq) (nat)) (((plus) (Jokerx_365)) (y))) (((plus) (y)) (Jokerx_365)))) (fun y : nat => (((sym_eq_plus) (O)) (fun z : (nat) -> nat => (((eq) (nat)) ((z) (y))) (((plus) (y)) (O)))) (((((sym_eq_filter_nat_type_O) ((nat) -> nat)) (plus_body)) (fun z : (nat) -> nat => (((eq) (nat)) ((z) (y))) (((plus) (y)) (O)))) (((sym_eq_plus_body_O) (fun z : (nat) -> nat => (((eq) (nat)) ((z) (y))) (((plus) (y)) (O)))) (((((((rewrite_l) (nat)) (y)) (fun Joker_ : nat => (((eq) (nat)) (y)) (Joker_))) (((refl) (nat)) (y))) (((plus) (y)) (O))) ((plus_n_O) (y))))))) (fun x_366 : nat => fun Jokerx_368 : forall y : nat, (((eq) (nat)) (((plus) (x_366)) (y))) (((plus) (y)) (x_366)) => fun y : nat => (((sym_eq_plus) ((S) (x_366))) (fun z : (nat) -> nat => (((eq) (nat)) ((z) (y))) (((plus) (y)) ((S) (x_366))))) ((((((sym_eq_filter_nat_type_S) ((nat) -> nat)) (plus_body)) (x_366)) (fun z : (nat) -> nat => (((eq) (nat)) ((z) (y))) (((plus) (y)) ((S) (x_366))))) ((((sym_eq_plus_body_S) (x_366)) (fun z : (nat) -> nat => (((eq) (nat)) ((z) (y))) (((plus) (y)) ((S) (x_366))))) (((((((rewrite_r) (nat)) (((plus) (x_366)) ((S) (y)))) (fun Joker_ : nat => (((eq) (nat)) (Joker_)) (((plus) (y)) ((S) (x_366))))) (((((((rewrite_r) (nat)) (((plus) (y)) ((S) (x_366)))) (fun Joker_ : nat => (((eq) (nat)) (Joker_)) (((plus) (y)) ((S) (x_366))))) (((refl) (nat)) (((plus) (y)) ((S) (x_366))))) (((plus) (x_366)) ((S) (y)))) (((((((rewrite_l) (nat)) ((S) (((plus) (x_366)) (y)))) (fun Joker_ : nat => (((eq) (nat)) (Joker_)) (((plus) (y)) ((S) (x_366))))) (((((((rewrite_r) (nat)) (((plus) (y)) (x_366))) (fun Joker_ : nat => (((eq) (nat)) ((S) (Joker_))) (((plus) (y)) ((S) (x_366))))) (((plus_n_Sm) (y)) (x_366))) (((plus) (x_366)) (y))) ((Jokerx_368) (y)))) (((plus) (x_366)) ((S) (y)))) (((plus_n_Sm) (x_366)) (y))))) ((S) (((plus) (x_366)) (y)))) (((plus_n_Sm) (x_366)) (y))))))) (n).
Definition associative_plus : ((associative) (nat)) (plus) := fun n : nat => ((((nat_ind) (fun Jokerx_365 : nat => forall y : nat, forall z : nat, (((eq) (nat)) (((plus) (((plus) (Jokerx_365)) (y))) (z))) (((plus) (Jokerx_365)) (((plus) (y)) (z))))) (fun y : nat => fun z : nat => (((sym_eq_plus) (O)) (fun x : (nat) -> nat => (((eq) (nat)) (((plus) (((plus) (O)) (y))) (z))) ((x) (((plus) (y)) (z))))) ((((sym_eq_plus) (O)) (fun x : (nat) -> nat => (((eq) (nat)) (((plus) ((x) (y))) (z))) (((((filter_nat_type) ((nat) -> nat)) (plus_body)) (O)) (((plus) (y)) (z))))) (((((sym_eq_filter_nat_type_O) ((nat) -> nat)) (plus_body)) (fun x : (nat) -> nat => (((eq) (nat)) (((plus) ((x) (y))) (z))) (((((filter_nat_type) ((nat) -> nat)) (plus_body)) (O)) (((plus) (y)) (z))))) (((((sym_eq_filter_nat_type_O) ((nat) -> nat)) (plus_body)) (fun x : (nat) -> nat => (((eq) (nat)) (((plus) (((plus_body) (O)) (y))) (z))) ((x) (((plus) (y)) (z))))) (((sym_eq_plus_body_O) (fun x : (nat) -> nat => (((eq) (nat)) (((plus) (((plus_body) (O)) (y))) (z))) ((x) (((plus) (y)) (z))))) (((sym_eq_plus_body_O) (fun x : (nat) -> nat => (((eq) (nat)) (((plus) ((x) (y))) (z))) (((plus) (y)) (z)))) (((refl) (nat)) (((plus) (y)) (z)))))))))) (fun x_366 : nat => fun Jokerx_368 : forall y : nat, forall z : nat, (((eq) (nat)) (((plus) (((plus) (x_366)) (y))) (z))) (((plus) (x_366)) (((plus) (y)) (z))) => fun y : nat => fun z : nat => (((sym_eq_plus) ((S) (x_366))) (fun x : (nat) -> nat => (((eq) (nat)) (((plus) (((plus) ((S) (x_366))) (y))) (z))) ((x) (((plus) (y)) (z))))) ((((sym_eq_plus) ((S) (x_366))) (fun x : (nat) -> nat => (((eq) (nat)) (((plus) ((x) (y))) (z))) (((((filter_nat_type) ((nat) -> nat)) (plus_body)) ((S) (x_366))) (((plus) (y)) (z))))) ((((((sym_eq_filter_nat_type_S) ((nat) -> nat)) (plus_body)) (x_366)) (fun x : (nat) -> nat => (((eq) (nat)) (((plus) ((x) (y))) (z))) (((((filter_nat_type) ((nat) -> nat)) (plus_body)) ((S) (x_366))) (((plus) (y)) (z))))) ((((((sym_eq_filter_nat_type_S) ((nat) -> nat)) (plus_body)) (x_366)) (fun x : (nat) -> nat => (((eq) (nat)) (((plus) (((plus_body) ((S) (x_366))) (y))) (z))) ((x) (((plus) (y)) (z))))) ((((sym_eq_plus_body_S) (x_366)) (fun x : (nat) -> nat => (((eq) (nat)) (((plus) (((plus_body) ((S) (x_366))) (y))) (z))) ((x) (((plus) (y)) (z))))) ((((sym_eq_plus_body_S) (x_366)) (fun x : (nat) -> nat => (((eq) (nat)) (((plus) ((x) (y))) (z))) ((S) (((plus) (x_366)) (((plus) (y)) (z)))))) ((((sym_eq_plus) ((S) (((plus) (x_366)) (y)))) (fun x : (nat) -> nat => (((eq) (nat)) ((x) (z))) ((S) (((plus) (x_366)) (((plus) (y)) (z)))))) ((((((sym_eq_filter_nat_type_S) ((nat) -> nat)) (plus_body)) (((plus) (x_366)) (y))) (fun x : (nat) -> nat => (((eq) (nat)) ((x) (z))) ((S) (((plus) (x_366)) (((plus) (y)) (z)))))) ((((sym_eq_plus_body_S) (((plus) (x_366)) (y))) (fun x : (nat) -> nat => (((eq) (nat)) ((x) (z))) ((S) (((plus) (x_366)) (((plus) (y)) (z)))))) (((((((rewrite_r) (nat)) (((plus) (x_366)) (((plus) (y)) (z)))) (fun Joker_ : nat => (((eq) (nat)) ((S) (Joker_))) ((S) (((plus) (x_366)) (((plus) (y)) (z)))))) (((refl) (nat)) ((S) (((plus) (x_366)) (((plus) (y)) (z)))))) (((plus) (((plus) (x_366)) (y))) (z))) (((Jokerx_368) (y)) (z))))))))))))) (n).
Definition assoc_plus1 : forall a : nat, forall b : nat, forall c : nat, (((eq) (nat)) (((plus) (c)) (((plus) (b)) (a)))) (((plus) (((plus) (b)) (c))) (a)) := fun a : nat => fun b : nat => fun c : nat => ((((((rewrite_r) (nat)) (((plus) (a)) (b))) (fun Joker_ : nat => (((eq) (nat)) (((plus) (c)) (Joker_))) (((plus) (((plus) (b)) (c))) (a)))) (((((((rewrite_r) (nat)) (((plus) (a)) (((plus) (b)) (c)))) (fun Joker_ : nat => (((eq) (nat)) (((plus) (c)) (((plus) (a)) (b)))) (Joker_))) (((((((rewrite_r) (nat)) (((plus) (a)) (((plus) (b)) (c)))) (fun Joker_ : nat => (((eq) (nat)) (Joker_)) (((plus) (a)) (((plus) (b)) (c))))) (((refl) (nat)) (((plus) (a)) (((plus) (b)) (c))))) (((plus) (c)) (((plus) (a)) (b)))) (((((((rewrite_l) (nat)) (((plus) (((plus) (a)) (b))) (c))) (fun Joker_ : nat => (((eq) (nat)) (((plus) (c)) (((plus) (a)) (b)))) (Joker_))) (((commutative_plus) (c)) (((plus) (a)) (b)))) (((plus) (a)) (((plus) (b)) (c)))) ((((associative_plus) (a)) (b)) (c))))) (((plus) (((plus) (b)) (c))) (a))) (((commutative_plus) (((plus) (b)) (c))) (a)))) (((plus) (b)) (a))) (((commutative_plus) (b)) (a)).
Definition injective_plus_r : forall n : nat, (((injective) (nat)) (nat)) (fun m : nat => ((plus) (n)) (m)) := fun n : nat => ((((nat_ind) (fun Jokerx_365 : nat => (((injective) (nat)) (nat)) (fun m : nat => ((plus) (Jokerx_365)) (m)))) ((((sym_eq_plus) (O)) (fun y : (nat) -> nat => (((injective) (nat)) (nat)) (fun m : nat => (y) (m)))) (((((sym_eq_filter_nat_type_O) ((nat) -> nat)) (plus_body)) (fun y : (nat) -> nat => (((injective) (nat)) (nat)) (fun m : nat => (y) (m)))) (((sym_eq_plus_body_O) (fun y : (nat) -> nat => (((injective) (nat)) (nat)) (fun m : nat => (y) (m)))) (fun x : nat => fun y : nat => fun auto : (((eq) (nat)) (x)) (y) => ((((((rewrite_l) (nat)) (x)) (fun Joker_ : nat => (((eq) (nat)) (x)) (Joker_))) (((refl) (nat)) (x))) (y)) (auto)))))) (fun x_366 : nat => fun Jokerx_368 : forall x : nat, forall y : nat, ((((eq) (nat)) (((plus) (x_366)) (x))) (((plus) (x_366)) (y))) -> (((eq) (nat)) (x)) (y) => (((sym_eq_plus) ((S) (x_366))) (fun y : (nat) -> nat => (((injective) (nat)) (nat)) (fun m : nat => (y) (m)))) ((((((sym_eq_filter_nat_type_S) ((nat) -> nat)) (plus_body)) (x_366)) (fun y : (nat) -> nat => (((injective) (nat)) (nat)) (fun m : nat => (y) (m)))) ((((sym_eq_plus_body_S) (x_366)) (fun y : (nat) -> nat => (((injective) (nat)) (nat)) (fun m : nat => (y) (m)))) (fun x : nat => fun y : nat => fun auto : (((eq) (nat)) ((S) (((plus) (x_366)) (x)))) ((S) (((plus) (x_366)) (y))) => (((Jokerx_368) (x)) (y)) ((((injective_S) (((plus) (x_366)) (x))) (((plus) (x_366)) (y))) (((((((rewrite_r) (nat)) (((plus) (x_366)) ((S) (x)))) (fun Joker_ : nat => (((eq) (nat)) (Joker_)) ((S) (((plus) (x_366)) (y))))) (((((((rewrite_r) (nat)) (((plus) (x_366)) ((S) (y)))) (fun Joker_ : nat => (((eq) (nat)) (((plus) (x_366)) ((S) (x)))) (Joker_))) (((((((rewrite_l) (nat)) (((plus) (x_366)) ((S) (x)))) (fun Joker_ : nat => (((eq) (nat)) (((plus) (x_366)) ((S) (x)))) (Joker_))) (((refl) (nat)) (((plus) (x_366)) ((S) (x))))) (((plus) (x_366)) ((S) (y)))) (((((((rewrite_l) (nat)) ((S) (((plus) (x_366)) (y)))) (fun Joker_ : nat => (((eq) (nat)) (((plus) (x_366)) ((S) (x)))) (Joker_))) (((((((rewrite_l) (nat)) ((S) (((plus) (x_366)) (x)))) (fun Joker_ : nat => (((eq) (nat)) (Joker_)) ((S) (((plus) (x_366)) (y))))) (auto)) (((plus) (x_366)) ((S) (x)))) (((plus_n_Sm) (x_366)) (x)))) (((plus) (x_366)) ((S) (y)))) (((plus_n_Sm) (x_366)) (y))))) ((S) (((plus) (x_366)) (y)))) (((plus_n_Sm) (x_366)) (y)))) ((S) (((plus) (x_366)) (x)))) (((plus_n_Sm) (x_366)) (x))))))))) (n).
Definition times_Sn_m : forall n : nat, forall m : nat, (((eq) (nat)) (((plus) (m)) (((times) (n)) (m)))) (((times) ((S) (n))) (m)) := fun n : nat => fun m : nat => (((sym_eq_times) ((S) (n))) (fun y : (nat) -> nat => (((eq) (nat)) (((plus) (m)) (((times) (n)) (m)))) ((y) (m)))) ((((((sym_eq_filter_nat_type_S) ((nat) -> nat)) (times_body)) (n)) (fun y : (nat) -> nat => (((eq) (nat)) (((plus) (m)) (((times) (n)) (m)))) ((y) (m)))) ((((sym_eq_times_body_S) (n)) (fun y : (nat) -> nat => (((eq) (nat)) (((plus) (m)) (((times) (n)) (m)))) ((y) (m)))) (((refl) (nat)) (((plus) (m)) (((times) (n)) (m)))))).
Definition times_O_n : forall n : nat, (((eq) (nat)) (O)) (((times) (O)) (n)) := fun n : nat => (((sym_eq_times) (O)) (fun y : (nat) -> nat => (((eq) (nat)) (O)) ((y) (n)))) (((((sym_eq_filter_nat_type_O) ((nat) -> nat)) (times_body)) (fun y : (nat) -> nat => (((eq) (nat)) (O)) ((y) (n)))) (((sym_eq_times_body_O) (fun y : (nat) -> nat => (((eq) (nat)) (O)) ((y) (n)))) (((refl) (nat)) (O)))).
Definition times_n_O : forall n : nat, (((eq) (nat)) (O)) (((times) (n)) (O)) := fun n : nat => ((((nat_ind) (fun Jokerx_365 : nat => (((eq) (nat)) (O)) (((times) (Jokerx_365)) (O)))) (((((((rewrite_l) (nat)) (O)) (fun Joker_ : nat => (((eq) (nat)) (O)) (Joker_))) (((refl) (nat)) (O))) (((times) (O)) (O))) ((times_O_n) (O)))) (fun x_366 : nat => fun Jokerx_368 : (((eq) (nat)) (O)) (((times) (x_366)) (O)) => ((((((rewrite_l) (nat)) (((plus) (O)) (((times) (x_366)) (O)))) (fun Joker_ : nat => (((eq) (nat)) (O)) (Joker_))) (((((((rewrite_l) (nat)) (O)) (fun Joker_ : nat => (((eq) (nat)) (O)) (((plus) (O)) (Joker_)))) (((((((rewrite_l) (nat)) (O)) (fun Joker_ : nat => (((eq) (nat)) (O)) (Joker_))) (((refl) (nat)) (O))) (((plus) (O)) (O))) ((plus_O_n) (O)))) (((times) (x_366)) (O))) (Jokerx_368))) (((times) ((S) (x_366))) (O))) (((times_Sn_m) (x_366)) (O)))) (n).
Definition times_n_Sm : forall n : nat, forall m : nat, (((eq) (nat)) (((plus) (n)) (((times) (n)) (m)))) (((times) (n)) ((S) (m))) := fun n : nat => ((((nat_ind) (fun Jokerx_365 : nat => forall m : nat, (((eq) (nat)) (((plus) (Jokerx_365)) (((times) (Jokerx_365)) (m)))) (((times) (Jokerx_365)) ((S) (m))))) ((((sym_eq_times) (O)) (fun y : (nat) -> nat => forall m : nat, (((eq) (nat)) (((plus) (O)) (((times) (O)) (m)))) ((y) ((S) (m))))) ((((sym_eq_times) (O)) (fun y : (nat) -> nat => forall m : nat, (((eq) (nat)) (((plus) (O)) ((y) (m)))) (((((filter_nat_type) ((nat) -> nat)) (times_body)) (O)) ((S) (m))))) (((((sym_eq_filter_nat_type_O) ((nat) -> nat)) (times_body)) (fun y : (nat) -> nat => forall m : nat, (((eq) (nat)) (((plus) (O)) ((y) (m)))) (((((filter_nat_type) ((nat) -> nat)) (times_body)) (O)) ((S) (m))))) (((((sym_eq_filter_nat_type_O) ((nat) -> nat)) (times_body)) (fun y : (nat) -> nat => forall m : nat, (((eq) (nat)) (((plus) (O)) (((times_body) (O)) (m)))) ((y) ((S) (m))))) (((sym_eq_times_body_O) (fun y : (nat) -> nat => forall m : nat, (((eq) (nat)) (((plus) (O)) (((times_body) (O)) (m)))) ((y) ((S) (m))))) (((sym_eq_times_body_O) (fun y : (nat) -> nat => forall m : nat, (((eq) (nat)) (((plus) (O)) ((y) (m)))) (O))) ((((sym_eq_plus) (O)) (fun y : (nat) -> nat => forall m : nat, (((eq) (nat)) ((y) (O))) (O))) (((((sym_eq_filter_nat_type_O) ((nat) -> nat)) (plus_body)) (fun y : (nat) -> nat => forall m : nat, (((eq) (nat)) ((y) (O))) (O))) (((sym_eq_plus_body_O) (fun y : (nat) -> nat => forall m : nat, (((eq) (nat)) ((y) (O))) (O))) (fun Jokerm : nat => ((refl) (nat)) (O)))))))))))) (fun x_366 : nat => fun Jokerx_368 : forall m : nat, (((eq) (nat)) (((plus) (x_366)) (((times) (x_366)) (m)))) (((times) (x_366)) ((S) (m))) => fun m : nat => (((sym_eq_times) ((S) (x_366))) (fun y : (nat) -> nat => (((eq) (nat)) (((plus) ((S) (x_366))) (((times) ((S) (x_366))) (m)))) ((y) ((S) (m))))) ((((sym_eq_times) ((S) (x_366))) (fun y : (nat) -> nat => (((eq) (nat)) (((plus) ((S) (x_366))) ((y) (m)))) (((((filter_nat_type) ((nat) -> nat)) (times_body)) ((S) (x_366))) ((S) (m))))) ((((((sym_eq_filter_nat_type_S) ((nat) -> nat)) (times_body)) (x_366)) (fun y : (nat) -> nat => (((eq) (nat)) (((plus) ((S) (x_366))) ((y) (m)))) (((((filter_nat_type) ((nat) -> nat)) (times_body)) ((S) (x_366))) ((S) (m))))) ((((((sym_eq_filter_nat_type_S) ((nat) -> nat)) (times_body)) (x_366)) (fun y : (nat) -> nat => (((eq) (nat)) (((plus) ((S) (x_366))) (((times_body) ((S) (x_366))) (m)))) ((y) ((S) (m))))) ((((sym_eq_times_body_S) (x_366)) (fun y : (nat) -> nat => (((eq) (nat)) (((plus) ((S) (x_366))) (((times_body) ((S) (x_366))) (m)))) ((y) ((S) (m))))) ((((sym_eq_times_body_S) (x_366)) (fun y : (nat) -> nat => (((eq) (nat)) (((plus) ((S) (x_366))) ((y) (m)))) (((plus) ((S) (m))) (((times) (x_366)) ((S) (m)))))) ((((sym_eq_plus) ((S) (x_366))) (fun y : (nat) -> nat => (((eq) (nat)) ((y) (((plus) (m)) (((times) (x_366)) (m))))) (((plus) ((S) (m))) (((times) (x_366)) ((S) (m)))))) ((((((sym_eq_filter_nat_type_S) ((nat) -> nat)) (plus_body)) (x_366)) (fun y : (nat) -> nat => (((eq) (nat)) ((y) (((plus) (m)) (((times) (x_366)) (m))))) (((plus) ((S) (m))) (((times) (x_366)) ((S) (m)))))) ((((sym_eq_plus_body_S) (x_366)) (fun y : (nat) -> nat => (((eq) (nat)) ((y) (((plus) (m)) (((times) (x_366)) (m))))) (((plus) ((S) (m))) (((times) (x_366)) ((S) (m)))))) ((((sym_eq_plus) ((S) (m))) (fun y : (nat) -> nat => (((eq) (nat)) ((S) (((plus) (x_366)) (((plus) (m)) (((times) (x_366)) (m)))))) ((y) (((times) (x_366)) ((S) (m)))))) ((((((sym_eq_filter_nat_type_S) ((nat) -> nat)) (plus_body)) (m)) (fun y : (nat) -> nat => (((eq) (nat)) ((S) (((plus) (x_366)) (((plus) (m)) (((times) (x_366)) (m)))))) ((y) (((times) (x_366)) ((S) (m)))))) ((((sym_eq_plus_body_S) (m)) (fun y : (nat) -> nat => (((eq) (nat)) ((S) (((plus) (x_366)) (((plus) (m)) (((times) (x_366)) (m)))))) ((y) (((times) (x_366)) ((S) (m)))))) (((((((rewrite_r) (nat)) (((plus) (x_366)) ((S) (((plus) (m)) (((times) (x_366)) (m)))))) (fun Joker_ : nat => (((eq) (nat)) (Joker_)) ((S) (((plus) (m)) (((times) (x_366)) ((S) (m))))))) (((((((rewrite_r) (nat)) (((plus) (m)) ((S) (((times) (x_366)) (m))))) (fun Joker_ : nat => (((eq) (nat)) (((plus) (x_366)) (Joker_))) ((S) (((plus) (m)) (((times) (x_366)) ((S) (m))))))) (((((((rewrite_l) (nat)) (((plus) (x_366)) (((times) (x_366)) (m)))) (fun Joker_ : nat => (((eq) (nat)) (((plus) (x_366)) (((plus) (m)) ((S) (((times) (x_366)) (m)))))) ((S) (((plus) (m)) (Joker_))))) (((((((rewrite_r) (nat)) (((plus) (x_366)) (((plus) (m)) (((times) (x_366)) (m))))) (fun Joker_ : nat => (((eq) (nat)) (((plus) (x_366)) (((plus) (m)) ((S) (((times) (x_366)) (m)))))) ((S) (Joker_)))) (((((((rewrite_r) (nat)) (((plus) (x_366)) ((S) (((plus) (m)) (((times) (x_366)) (m)))))) (fun Joker_ : nat => (((eq) (nat)) (((plus) (x_366)) (((plus) (m)) ((S) (((times) (x_366)) (m)))))) (Joker_))) (((((((rewrite_r) (nat)) (((plus) (m)) ((S) (((times) (x_366)) (m))))) (fun Joker_ : nat => (((eq) (nat)) (((plus) (x_366)) (((plus) (m)) ((S) (((times) (x_366)) (m)))))) (((plus) (x_366)) (Joker_)))) (((refl) (nat)) (((plus) (x_366)) (((plus) (m)) ((S) (((times) (x_366)) (m))))))) ((S) (((plus) (m)) (((times) (x_366)) (m))))) (((plus_n_Sm) (m)) (((times) (x_366)) (m))))) ((S) (((plus) (x_366)) (((plus) (m)) (((times) (x_366)) (m)))))) (((plus_n_Sm) (x_366)) (((plus) (m)) (((times) (x_366)) (m)))))) (((plus) (m)) (((plus) (x_366)) (((times) (x_366)) (m))))) (((((((rewrite_l) (nat)) (((plus) (((plus) (x_366)) (m))) (((times) (x_366)) (m)))) (fun Joker_ : nat => (((eq) (nat)) (((plus) (m)) (((plus) (x_366)) (((times) (x_366)) (m))))) (Joker_))) ((((assoc_plus1) (((times) (x_366)) (m))) (x_366)) (m))) (((plus) (x_366)) (((plus) (m)) (((times) (x_366)) (m))))) ((((associative_plus) (x_366)) (m)) (((times) (x_366)) (m)))))) (((times) (x_366)) ((S) (m)))) ((Jokerx_368) (m)))) ((S) (((plus) (m)) (((times) (x_366)) (m))))) (((plus_n_Sm) (m)) (((times) (x_366)) (m))))) ((S) (((plus) (x_366)) (((plus) (m)) (((times) (x_366)) (m)))))) (((plus_n_Sm) (x_366)) (((plus) (m)) (((times) (x_366)) (m)))))))))))))))))) (n).
Definition commutative_times : ((commutative) (nat)) (times) := fun n : nat => ((((nat_ind) (fun Jokerx_365 : nat => forall y : nat, (((eq) (nat)) (((times) (Jokerx_365)) (y))) (((times) (y)) (Jokerx_365)))) ((((sym_eq_times) (O)) (fun y : (nat) -> nat => forall z : nat, (((eq) (nat)) ((y) (z))) (((times) (z)) (O)))) (((((sym_eq_filter_nat_type_O) ((nat) -> nat)) (times_body)) (fun y : (nat) -> nat => forall z : nat, (((eq) (nat)) ((y) (z))) (((times) (z)) (O)))) (((sym_eq_times_body_O) (fun y : (nat) -> nat => forall z : nat, (((eq) (nat)) ((y) (z))) (((times) (z)) (O)))) (fun y : nat => ((((((rewrite_l) (nat)) (O)) (fun Joker_ : nat => (((eq) (nat)) (O)) (Joker_))) (((refl) (nat)) (O))) (((times) (y)) (O))) ((times_n_O) (y))))))) (fun x_366 : nat => fun Jokerx_368 : forall y : nat, (((eq) (nat)) (((times) (x_366)) (y))) (((times) (y)) (x_366)) => fun y : nat => (((sym_eq_times) ((S) (x_366))) (fun z : (nat) -> nat => (((eq) (nat)) ((z) (y))) (((times) (y)) ((S) (x_366))))) ((((((sym_eq_filter_nat_type_S) ((nat) -> nat)) (times_body)) (x_366)) (fun z : (nat) -> nat => (((eq) (nat)) ((z) (y))) (((times) (y)) ((S) (x_366))))) ((((sym_eq_times_body_S) (x_366)) (fun z : (nat) -> nat => (((eq) (nat)) ((z) (y))) (((times) (y)) ((S) (x_366))))) (((((((rewrite_l) (nat)) (((plus) (y)) (((times) (y)) (x_366)))) (fun Joker_ : nat => (((eq) (nat)) (((plus) (y)) (((times) (x_366)) (y)))) (Joker_))) (((((((rewrite_l) (nat)) (((times) (x_366)) (y))) (fun Joker_ : nat => (((eq) (nat)) (((plus) (y)) (((times) (x_366)) (y)))) (((plus) (y)) (Joker_)))) (((refl) (nat)) (((plus) (y)) (((times) (x_366)) (y))))) (((times) (y)) (x_366))) ((Jokerx_368) (y)))) (((times) (y)) ((S) (x_366)))) (((times_n_Sm) (y)) (x_366))))))) (n).
Definition distributive_times_plus : (((distributive) (nat)) (times)) (plus) := fun n : nat => ((((nat_ind) (fun Jokerx_365 : nat => forall y : nat, forall z : nat, (((eq) (nat)) (((times) (Jokerx_365)) (((plus) (y)) (z)))) (((plus) (((times) (Jokerx_365)) (y))) (((times) (Jokerx_365)) (z))))) ((((sym_eq_times) (O)) (fun x : (nat) -> nat => forall y : nat, forall z : nat, (((eq) (nat)) (((times) (O)) (((plus) (y)) (z)))) (((plus) (((times) (O)) (y))) ((x) (z))))) ((((sym_eq_times) (O)) (fun x : (nat) -> nat => forall y : nat, forall z : nat, (((eq) (nat)) (((times) (O)) (((plus) (y)) (z)))) (((plus) ((x) (y))) (((((filter_nat_type) ((nat) -> nat)) (times_body)) (O)) (z))))) ((((sym_eq_times) (O)) (fun x : (nat) -> nat => forall y : nat, forall z : nat, (((eq) (nat)) ((x) (((plus) (y)) (z)))) (((plus) (((((filter_nat_type) ((nat) -> nat)) (times_body)) (O)) (y))) (((((filter_nat_type) ((nat) -> nat)) (times_body)) (O)) (z))))) (((((sym_eq_filter_nat_type_O) ((nat) -> nat)) (times_body)) (fun x : (nat) -> nat => forall y : nat, forall z : nat, (((eq) (nat)) ((x) (((plus) (y)) (z)))) (((plus) (((((filter_nat_type) ((nat) -> nat)) (times_body)) (O)) (y))) (((((filter_nat_type) ((nat) -> nat)) (times_body)) (O)) (z))))) (((((sym_eq_filter_nat_type_O) ((nat) -> nat)) (times_body)) (fun x : (nat) -> nat => forall y : nat, forall z : nat, (((eq) (nat)) (((times_body) (O)) (((plus) (y)) (z)))) (((plus) ((x) (y))) (((((filter_nat_type) ((nat) -> nat)) (times_body)) (O)) (z))))) (((((sym_eq_filter_nat_type_O) ((nat) -> nat)) (times_body)) (fun x : (nat) -> nat => forall y : nat, forall z : nat, (((eq) (nat)) (((times_body) (O)) (((plus) (y)) (z)))) (((plus) (((times_body) (O)) (y))) ((x) (z))))) (((sym_eq_times_body_O) (fun x : (nat) -> nat => forall y : nat, forall z : nat, (((eq) (nat)) (((times_body) (O)) (((plus) (y)) (z)))) (((plus) (((times_body) (O)) (y))) ((x) (z))))) (((sym_eq_times_body_O) (fun x : (nat) -> nat => forall y : nat, forall z : nat, (((eq) (nat)) (((times_body) (O)) (((plus) (y)) (z)))) (((plus) ((x) (y))) (O)))) (((sym_eq_times_body_O) (fun x : (nat) -> nat => forall y : nat, forall z : nat, (((eq) (nat)) ((x) (((plus) (y)) (z)))) (((plus) (O)) (O)))) ((((sym_eq_plus) (O)) (fun x : (nat) -> nat => forall y : nat, forall z : nat, (((eq) (nat)) (O)) ((x) (O)))) (((((sym_eq_filter_nat_type_O) ((nat) -> nat)) (plus_body)) (fun x : (nat) -> nat => forall y : nat, forall z : nat, (((eq) (nat)) (O)) ((x) (O)))) (((sym_eq_plus_body_O) (fun x : (nat) -> nat => forall y : nat, forall z : nat, (((eq) (nat)) (O)) ((x) (O)))) (fun Jokery : nat => fun Jokerz : nat => ((refl) (nat)) (O))))))))))))))) (fun x_366 : nat => fun Jokerx_368 : forall y : nat, forall z : nat, (((eq) (nat)) (((times) (x_366)) (((plus) (y)) (z)))) (((plus) (((times) (x_366)) (y))) (((times) (x_366)) (z))) => fun y : nat => fun z : nat => (((sym_eq_times) ((S) (x_366))) (fun x : (nat) -> nat => (((eq) (nat)) (((times) ((S) (x_366))) (((plus) (y)) (z)))) (((plus) (((times) ((S) (x_366))) (y))) ((x) (z))))) ((((sym_eq_times) ((S) (x_366))) (fun x : (nat) -> nat => (((eq) (nat)) (((times) ((S) (x_366))) (((plus) (y)) (z)))) (((plus) ((x) (y))) (((((filter_nat_type) ((nat) -> nat)) (times_body)) ((S) (x_366))) (z))))) ((((sym_eq_times) ((S) (x_366))) (fun x : (nat) -> nat => (((eq) (nat)) ((x) (((plus) (y)) (z)))) (((plus) (((((filter_nat_type) ((nat) -> nat)) (times_body)) ((S) (x_366))) (y))) (((((filter_nat_type) ((nat) -> nat)) (times_body)) ((S) (x_366))) (z))))) ((((((sym_eq_filter_nat_type_S) ((nat) -> nat)) (times_body)) (x_366)) (fun x : (nat) -> nat => (((eq) (nat)) ((x) (((plus) (y)) (z)))) (((plus) (((((filter_nat_type) ((nat) -> nat)) (times_body)) ((S) (x_366))) (y))) (((((filter_nat_type) ((nat) -> nat)) (times_body)) ((S) (x_366))) (z))))) ((((((sym_eq_filter_nat_type_S) ((nat) -> nat)) (times_body)) (x_366)) (fun x : (nat) -> nat => (((eq) (nat)) (((times_body) ((S) (x_366))) (((plus) (y)) (z)))) (((plus) ((x) (y))) (((((filter_nat_type) ((nat) -> nat)) (times_body)) ((S) (x_366))) (z))))) ((((((sym_eq_filter_nat_type_S) ((nat) -> nat)) (times_body)) (x_366)) (fun x : (nat) -> nat => (((eq) (nat)) (((times_body) ((S) (x_366))) (((plus) (y)) (z)))) (((plus) (((times_body) ((S) (x_366))) (y))) ((x) (z))))) ((((sym_eq_times_body_S) (x_366)) (fun x : (nat) -> nat => (((eq) (nat)) (((times_body) ((S) (x_366))) (((plus) (y)) (z)))) (((plus) (((times_body) ((S) (x_366))) (y))) ((x) (z))))) ((((sym_eq_times_body_S) (x_366)) (fun x : (nat) -> nat => (((eq) (nat)) (((times_body) ((S) (x_366))) (((plus) (y)) (z)))) (((plus) ((x) (y))) (((plus) (z)) (((times) (x_366)) (z)))))) ((((sym_eq_times_body_S) (x_366)) (fun x : (nat) -> nat => (((eq) (nat)) ((x) (((plus) (y)) (z)))) (((plus) (((plus) (y)) (((times) (x_366)) (y)))) (((plus) (z)) (((times) (x_366)) (z)))))) (((((((rewrite_r) (nat)) (((plus) (y)) (((plus) (z)) (((times) (x_366)) (((plus) (y)) (z)))))) (fun Joker_ : nat => (((eq) (nat)) (Joker_)) (((plus) (((plus) (y)) (((times) (x_366)) (y)))) (((plus) (z)) (((times) (x_366)) (z)))))) (((((((rewrite_r) (nat)) (((plus) (y)) (((plus) (((times) (x_366)) (y))) (((plus) (z)) (((times) (x_366)) (z)))))) (fun Joker_ : nat => (((eq) (nat)) (((plus) (y)) (((plus) (z)) (((times) (x_366)) (((plus) (y)) (z)))))) (Joker_))) (((((((rewrite_r) (nat)) (((plus) (z)) (((plus) (((times) (x_366)) (y))) (((times) (x_366)) (z))))) (fun Joker_ : nat => (((eq) (nat)) (((plus) (y)) (((plus) (z)) (((times) (x_366)) (((plus) (y)) (z)))))) (((plus) (y)) (Joker_)))) (((((((rewrite_l) (nat)) (((times) (x_366)) (((plus) (y)) (z)))) (fun Joker_ : nat => (((eq) (nat)) (((plus) (y)) (((plus) (z)) (((times) (x_366)) (((plus) (y)) (z)))))) (((plus) (y)) (((plus) (z)) (Joker_))))) (((refl) (nat)) (((plus) (y)) (((plus) (z)) (((times) (x_366)) (((plus) (y)) (z))))))) (((plus) (((times) (x_366)) (y))) (((times) (x_366)) (z)))) (((Jokerx_368) (y)) (z)))) (((plus) (((times) (x_366)) (y))) (((plus) (z)) (((times) (x_366)) (z))))) (((((((rewrite_l) (nat)) (((plus) (((plus) (z)) (((times) (x_366)) (y)))) (((times) (x_366)) (z)))) (fun Joker_ : nat => (((eq) (nat)) (((plus) (((times) (x_366)) (y))) (((plus) (z)) (((times) (x_366)) (z))))) (Joker_))) ((((assoc_plus1) (((times) (x_366)) (z))) (z)) (((times) (x_366)) (y)))) (((plus) (z)) (((plus) (((times) (x_366)) (y))) (((times) (x_366)) (z))))) ((((associative_plus) (z)) (((times) (x_366)) (y))) (((times) (x_366)) (z)))))) (((plus) (((plus) (y)) (((times) (x_366)) (y)))) (((plus) (z)) (((times) (x_366)) (z))))) ((((associative_plus) (y)) (((times) (x_366)) (y))) (((plus) (z)) (((times) (x_366)) (z)))))) (((plus) (((plus) (y)) (z))) (((times) (x_366)) (((plus) (y)) (z))))) ((((associative_plus) (y)) (z)) (((times) (x_366)) (((plus) (y)) (z))))))))))))))) (n).
Definition distributive_times_plus_r : forall a : nat, forall b : nat, forall c : nat, (((eq) (nat)) (((times) (((plus) (b)) (c))) (a))) (((plus) (((times) (b)) (a))) (((times) (c)) (a))) := fun a : nat => fun b : nat => fun c : nat => ((((((rewrite_r) (nat)) (((times) (a)) (((plus) (b)) (c)))) (fun Joker_ : nat => (((eq) (nat)) (Joker_)) (((plus) (((times) (b)) (a))) (((times) (c)) (a))))) (((((((rewrite_r) (nat)) (((times) (a)) (b))) (fun Joker_ : nat => (((eq) (nat)) (((times) (a)) (((plus) (b)) (c)))) (((plus) (Joker_)) (((times) (c)) (a))))) (((((((rewrite_r) (nat)) (((times) (a)) (c))) (fun Joker_ : nat => (((eq) (nat)) (((times) (a)) (((plus) (b)) (c)))) (((plus) (((times) (a)) (b))) (Joker_)))) (((((((rewrite_l) (nat)) (((times) (a)) (((plus) (b)) (c)))) (fun Joker_ : nat => (((eq) (nat)) (((times) (a)) (((plus) (b)) (c)))) (Joker_))) (((refl) (nat)) (((times) (a)) (((plus) (b)) (c))))) (((plus) (((times) (a)) (b))) (((times) (a)) (c)))) ((((distributive_times_plus) (a)) (b)) (c)))) (((times) (c)) (a))) (((commutative_times) (c)) (a)))) (((times) (b)) (a))) (((commutative_times) (b)) (a)))) (((times) (((plus) (b)) (c))) (a))) (((commutative_times) (((plus) (b)) (c))) (a)).
Definition associative_times : ((associative) (nat)) (times) := fun n : nat => ((((nat_ind) (fun Jokerx_365 : nat => forall y : nat, forall z : nat, (((eq) (nat)) (((times) (((times) (Jokerx_365)) (y))) (z))) (((times) (Jokerx_365)) (((times) (y)) (z))))) ((((sym_eq_times) (O)) (fun x : (nat) -> nat => forall y : nat, forall z : nat, (((eq) (nat)) (((times) (((times) (O)) (y))) (z))) ((x) (((times) (y)) (z))))) ((((sym_eq_times) (O)) (fun x : (nat) -> nat => forall y : nat, forall z : nat, (((eq) (nat)) (((times) ((x) (y))) (z))) (((((filter_nat_type) ((nat) -> nat)) (times_body)) (O)) (((times) (y)) (z))))) (((((sym_eq_filter_nat_type_O) ((nat) -> nat)) (times_body)) (fun x : (nat) -> nat => forall y : nat, forall z : nat, (((eq) (nat)) (((times) ((x) (y))) (z))) (((((filter_nat_type) ((nat) -> nat)) (times_body)) (O)) (((times) (y)) (z))))) (((((sym_eq_filter_nat_type_O) ((nat) -> nat)) (times_body)) (fun x : (nat) -> nat => forall y : nat, forall z : nat, (((eq) (nat)) (((times) (((times_body) (O)) (y))) (z))) ((x) (((times) (y)) (z))))) (((sym_eq_times_body_O) (fun x : (nat) -> nat => forall y : nat, forall z : nat, (((eq) (nat)) (((times) (((times_body) (O)) (y))) (z))) ((x) (((times) (y)) (z))))) (((sym_eq_times_body_O) (fun x : (nat) -> nat => forall y : nat, forall z : nat, (((eq) (nat)) (((times) ((x) (y))) (z))) (O))) ((((sym_eq_times) (O)) (fun x : (nat) -> nat => forall y : nat, forall z : nat, (((eq) (nat)) ((x) (z))) (O))) (((((sym_eq_filter_nat_type_O) ((nat) -> nat)) (times_body)) (fun x : (nat) -> nat => forall y : nat, forall z : nat, (((eq) (nat)) ((x) (z))) (O))) (((sym_eq_times_body_O) (fun x : (nat) -> nat => forall y : nat, forall z : nat, (((eq) (nat)) ((x) (z))) (O))) (fun Jokery : nat => fun Jokerz : nat => ((refl) (nat)) (O)))))))))))) (fun x_366 : nat => fun Jokerx_368 : forall y : nat, forall z : nat, (((eq) (nat)) (((times) (((times) (x_366)) (y))) (z))) (((times) (x_366)) (((times) (y)) (z))) => fun y : nat => fun z : nat => (((sym_eq_times) ((S) (x_366))) (fun x : (nat) -> nat => (((eq) (nat)) (((times) (((times) ((S) (x_366))) (y))) (z))) ((x) (((times) (y)) (z))))) ((((sym_eq_times) ((S) (x_366))) (fun x : (nat) -> nat => (((eq) (nat)) (((times) ((x) (y))) (z))) (((((filter_nat_type) ((nat) -> nat)) (times_body)) ((S) (x_366))) (((times) (y)) (z))))) ((((((sym_eq_filter_nat_type_S) ((nat) -> nat)) (times_body)) (x_366)) (fun x : (nat) -> nat => (((eq) (nat)) (((times) ((x) (y))) (z))) (((((filter_nat_type) ((nat) -> nat)) (times_body)) ((S) (x_366))) (((times) (y)) (z))))) ((((((sym_eq_filter_nat_type_S) ((nat) -> nat)) (times_body)) (x_366)) (fun x : (nat) -> nat => (((eq) (nat)) (((times) (((times_body) ((S) (x_366))) (y))) (z))) ((x) (((times) (y)) (z))))) ((((sym_eq_times_body_S) (x_366)) (fun x : (nat) -> nat => (((eq) (nat)) (((times) (((times_body) ((S) (x_366))) (y))) (z))) ((x) (((times) (y)) (z))))) ((((sym_eq_times_body_S) (x_366)) (fun x : (nat) -> nat => (((eq) (nat)) (((times) ((x) (y))) (z))) (((plus) (((times) (y)) (z))) (((times) (x_366)) (((times) (y)) (z)))))) (((((((rewrite_r) (nat)) (((plus) (((times) (y)) (z))) (((times) (x_366)) (((times) (y)) (z))))) (fun Joker_ : nat => (((eq) (nat)) (Joker_)) (((plus) (((times) (y)) (z))) (((times) (x_366)) (((times) (y)) (z)))))) (((refl) (nat)) (((plus) (((times) (y)) (z))) (((times) (x_366)) (((times) (y)) (z)))))) (((times) (((plus) (y)) (((times) (x_366)) (y)))) (z))) (((((((rewrite_l) (nat)) (((times) (((times) (x_366)) (y))) (z))) (fun Joker_ : nat => (((eq) (nat)) (((times) (((plus) (y)) (((times) (x_366)) (y)))) (z))) (((plus) (((times) (y)) (z))) (Joker_)))) ((((distributive_times_plus_r) (z)) (y)) (((times) (x_366)) (y)))) (((times) (x_366)) (((times) (y)) (z)))) (((Jokerx_368) (y)) (z))))))))))) (n).
Definition times_times : forall x : nat, forall y : nat, forall z : nat, (((eq) (nat)) (((times) (x)) (((times) (y)) (z)))) (((times) (y)) (((times) (x)) (z))) := fun x : nat => fun y : nat => fun z : nat => ((((((rewrite_r) (nat)) (((times) (y)) (((times) (x)) (z)))) (fun Joker_ : nat => (((eq) (nat)) (Joker_)) (((times) (y)) (((times) (x)) (z))))) (((refl) (nat)) (((times) (y)) (((times) (x)) (z))))) (((times) (x)) (((times) (y)) (z)))) (((((((rewrite_l) (nat)) (((times) (((times) (x)) (y))) (z))) (fun Joker_ : nat => (((eq) (nat)) (Joker_)) (((times) (y)) (((times) (x)) (z))))) (((((((rewrite_l) (nat)) (((times) (y)) (x))) (fun Joker_ : nat => (((eq) (nat)) (((times) (Joker_)) (z))) (((times) (y)) (((times) (x)) (z))))) ((((associative_times) (y)) (x)) (z))) (((times) (x)) (y))) (((commutative_times) (y)) (x)))) (((times) (x)) (((times) (y)) (z)))) ((((associative_times) (x)) (y)) (z))).
Definition times_n_1 : forall n : nat, (((eq) (nat)) (n)) (((times) (n)) ((S) (O))) := fun n : nat => ((((((rewrite_l) (nat)) (((plus) (n)) (((times) (n)) (O)))) (fun Joker_ : nat => (((eq) (nat)) (n)) (Joker_))) (((((((rewrite_l) (nat)) (O)) (fun Joker_ : nat => (((eq) (nat)) (n)) (((plus) (n)) (Joker_)))) (((((((rewrite_l) (nat)) (n)) (fun Joker_ : nat => (((eq) (nat)) (n)) (Joker_))) (((refl) (nat)) (n))) (((plus) (n)) (O))) ((plus_n_O) (n)))) (((times) (n)) (O))) ((times_n_O) (n)))) (((times) (n)) ((S) (O)))) (((times_n_Sm) (n)) (O)).
Definition minus_S_S : forall n : nat, forall m : nat, (((eq) (nat)) (((minus) ((S) (n))) ((S) (m)))) (((minus) (n)) (m)) := fun n : nat => fun m : nat => ((((((eq_match_nat_type_S) (nat)) ((S) (n))) (fun q : nat => ((minus) (n)) (q))) (m)) (fun y : nat => (((eq) (nat)) (((minus) ((S) (n))) ((S) (m)))) (y))) ((((eq_minus_body_S) (n)) (fun y : (nat) -> nat => (((eq) (nat)) (((minus) ((S) (n))) ((S) (m)))) ((y) ((S) (m))))) ((((((eq_filter_nat_type_S) ((nat) -> nat)) (minus_body)) (n)) (fun y : (nat) -> nat => (((eq) (nat)) (((minus) ((S) (n))) ((S) (m)))) ((y) ((S) (m))))) ((((eq_minus) ((S) (n))) (fun y : (nat) -> nat => (((eq) (nat)) (((minus) ((S) (n))) ((S) (m)))) ((y) ((S) (m))))) (((refl) (nat)) (((minus) ((S) (n))) ((S) (m))))))).
Definition minus_O_n : forall n : nat, (((eq) (nat)) (O)) (((minus) (O)) (n)) := fun n : nat => ((((match_nat_prop) (fun Joker_ : nat => (((eq) (nat)) (O)) (((minus) (O)) (Joker_)))) ((((sym_eq_minus) (O)) (fun y : (nat) -> nat => (((eq) (nat)) (O)) ((y) (O)))) (((((sym_eq_filter_nat_type_O) ((nat) -> nat)) (minus_body)) (fun y : (nat) -> nat => (((eq) (nat)) (O)) ((y) (O)))) (((sym_eq_minus_body_O) (fun y : (nat) -> nat => (((eq) (nat)) (O)) ((y) (O)))) (((refl) (nat)) (O)))))) ((((sym_eq_minus) (O)) (fun y : (nat) -> nat => forall n0 : nat, (((eq) (nat)) (O)) ((y) ((S) (n0))))) (((((sym_eq_filter_nat_type_O) ((nat) -> nat)) (minus_body)) (fun y : (nat) -> nat => forall n0 : nat, (((eq) (nat)) (O)) ((y) ((S) (n0))))) (((sym_eq_minus_body_O) (fun y : (nat) -> nat => forall n0 : nat, (((eq) (nat)) (O)) ((y) ((S) (n0))))) (fun auto : nat => ((refl) (nat)) (O)))))) (n).
Definition minus_n_O : forall n : nat, (((eq) (nat)) (n)) (((minus) (n)) (O)) := fun n : nat => ((((match_nat_prop) (fun Joker_ : nat => (((eq) (nat)) (Joker_)) (((minus) (Joker_)) (O)))) (((((((rewrite_l) (nat)) (O)) (fun Joker_ : nat => (((eq) (nat)) (O)) (Joker_))) (((refl) (nat)) (O))) (((minus) (O)) (O))) ((minus_O_n) (O)))) (fun auto : nat => (((sym_eq_minus) ((S) (auto))) (fun y : (nat) -> nat => (((eq) (nat)) ((S) (auto))) ((y) (O)))) ((((((sym_eq_filter_nat_type_S) ((nat) -> nat)) (minus_body)) (auto)) (fun y : (nat) -> nat => (((eq) (nat)) ((S) (auto))) ((y) (O)))) ((((sym_eq_minus_body_S) (auto)) (fun y : (nat) -> nat => (((eq) (nat)) ((S) (auto))) ((y) (O)))) ((((((sym_eq_match_nat_type_O) (nat)) ((S) (auto))) (fun q : nat => ((minus) (auto)) (q))) (fun y : nat => (((eq) (nat)) ((S) (auto))) (y))) (((refl) (nat)) ((S) (auto)))))))) (n).
Definition minus_n_n : forall n : nat, (((eq) (nat)) (O)) (((minus) (n)) (n)) := fun n : nat => ((((nat_ind) (fun Jokerx_365 : nat => (((eq) (nat)) (O)) (((minus) (Jokerx_365)) (Jokerx_365)))) (((((((rewrite_l) (nat)) (O)) (fun Joker_ : nat => (((eq) (nat)) (O)) (Joker_))) (((refl) (nat)) (O))) (((minus) (O)) (O))) ((minus_O_n) (O)))) (fun x_366 : nat => fun Jokerx_368 : (((eq) (nat)) (O)) (((minus) (x_366)) (x_366)) => ((((((rewrite_r) (nat)) (((minus) (x_366)) (x_366))) (fun Joker_ : nat => (((eq) (nat)) (O)) (Joker_))) (((((((rewrite_l) (nat)) (O)) (fun Joker_ : nat => (((eq) (nat)) (O)) (Joker_))) (((refl) (nat)) (O))) (((minus) (x_366)) (x_366))) (Jokerx_368))) (((minus) ((S) (x_366))) ((S) (x_366)))) (((minus_S_S) (x_366)) (x_366)))) (n).
Definition eq_minus_S_pred : forall n : nat, forall m : nat, (((eq) (nat)) (((minus) (n)) ((S) (m)))) ((pred) (((minus) (n)) (m))) := ((((nat_elim2) (fun Joker_ : nat => fun Joker0 : nat => (((eq) (nat)) (((minus) (Joker_)) ((S) (Joker0)))) ((pred) (((minus) (Joker_)) (Joker0))))) (fun Jokern : nat => (((sym_eq_minus) (O)) (fun y : (nat) -> nat => (((eq) (nat)) (((minus) (O)) ((S) (Jokern)))) ((pred) ((y) (Jokern))))) ((((sym_eq_minus) (O)) (fun y : (nat) -> nat => (((eq) (nat)) ((y) ((S) (Jokern)))) ((pred) (((((filter_nat_type) ((nat) -> nat)) (minus_body)) (O)) (Jokern))))) (((((sym_eq_filter_nat_type_O) ((nat) -> nat)) (minus_body)) (fun y : (nat) -> nat => (((eq) (nat)) ((y) ((S) (Jokern)))) ((pred) (((((filter_nat_type) ((nat) -> nat)) (minus_body)) (O)) (Jokern))))) (((((sym_eq_filter_nat_type_O) ((nat) -> nat)) (minus_body)) (fun y : (nat) -> nat => (((eq) (nat)) (((minus_body) (O)) ((S) (Jokern)))) ((pred) ((y) (Jokern))))) (((sym_eq_minus_body_O) (fun y : (nat) -> nat => (((eq) (nat)) (((minus_body) (O)) ((S) (Jokern)))) ((pred) ((y) (Jokern))))) (((sym_eq_minus_body_O) (fun y : (nat) -> nat => (((eq) (nat)) ((y) ((S) (Jokern)))) (((((match_nat_type) (nat)) (O)) (fun p : nat => p)) (O)))) ((((((sym_eq_match_nat_type_O) (nat)) (O)) (fun p : nat => p)) (fun y : nat => (((eq) (nat)) (O)) (y))) (((refl) (nat)) (O)))))))))) (fun n : nat => (((sym_eq_minus) ((S) (n))) (fun y : (nat) -> nat => (((eq) (nat)) (((minus) ((S) (n))) ((S) (O)))) ((pred) ((y) (O))))) ((((sym_eq_minus) ((S) (n))) (fun y : (nat) -> nat => (((eq) (nat)) ((y) ((S) (O)))) ((pred) (((((filter_nat_type) ((nat) -> nat)) (minus_body)) ((S) (n))) (O))))) ((((((sym_eq_filter_nat_type_S) ((nat) -> nat)) (minus_body)) (n)) (fun y : (nat) -> nat => (((eq) (nat)) ((y) ((S) (O)))) ((pred) (((((filter_nat_type) ((nat) -> nat)) (minus_body)) ((S) (n))) (O))))) ((((((sym_eq_filter_nat_type_S) ((nat) -> nat)) (minus_body)) (n)) (fun y : (nat) -> nat => (((eq) (nat)) (((minus_body) ((S) (n))) ((S) (O)))) ((pred) ((y) (O))))) ((((sym_eq_minus_body_S) (n)) (fun y : (nat) -> nat => (((eq) (nat)) (((minus_body) ((S) (n))) ((S) (O)))) ((pred) ((y) (O))))) ((((sym_eq_minus_body_S) (n)) (fun y : (nat) -> nat => (((eq) (nat)) ((y) ((S) (O)))) ((pred) (((((match_nat_type) (nat)) ((S) (n))) (fun q : nat => ((minus) (n)) (q))) (O))))) (((((((sym_eq_match_nat_type_S) (nat)) ((S) (n))) (fun q : nat => ((minus) (n)) (q))) (O)) (fun y : nat => (((eq) (nat)) (y)) (((((match_nat_type) (nat)) (O)) (fun p : nat => p)) (((((match_nat_type) (nat)) ((S) (n))) (fun q : nat => ((minus) (n)) (q))) (O))))) ((((((sym_eq_match_nat_type_O) (nat)) ((S) (n))) (fun q : nat => ((minus) (n)) (q))) (fun y : nat => (((eq) (nat)) (((minus) (n)) (O))) (((((match_nat_type) (nat)) (O)) (fun p : nat => p)) (y)))) (((((((sym_eq_match_nat_type_S) (nat)) (O)) (fun q : nat => q)) (n)) (fun y : nat => (((eq) (nat)) (((minus) (n)) (O))) (y))) (((((((rewrite_l) (nat)) (n)) (fun Joker_ : nat => (((eq) (nat)) (Joker_)) (n))) (((refl) (nat)) (n))) (((minus) (n)) (O))) ((minus_n_O) (n))))))))))))) (fun n : nat => fun m : nat => (((sym_eq_minus) ((S) (n))) (fun y : (nat) -> nat => ((((eq) (nat)) (((minus) (n)) ((S) (m)))) ((pred) (((minus) (n)) (m)))) -> (((eq) (nat)) (((minus) ((S) (n))) ((S) ((S) (m))))) ((pred) ((y) ((S) (m)))))) ((((sym_eq_minus) ((S) (n))) (fun y : (nat) -> nat => ((((eq) (nat)) (((minus) (n)) ((S) (m)))) ((pred) (((minus) (n)) (m)))) -> (((eq) (nat)) ((y) ((S) ((S) (m))))) ((pred) (((((filter_nat_type) ((nat) -> nat)) (minus_body)) ((S) (n))) ((S) (m)))))) ((((((sym_eq_filter_nat_type_S) ((nat) -> nat)) (minus_body)) (n)) (fun y : (nat) -> nat => ((((eq) (nat)) (((minus) (n)) ((S) (m)))) ((pred) (((minus) (n)) (m)))) -> (((eq) (nat)) ((y) ((S) ((S) (m))))) ((pred) (((((filter_nat_type) ((nat) -> nat)) (minus_body)) ((S) (n))) ((S) (m)))))) ((((((sym_eq_filter_nat_type_S) ((nat) -> nat)) (minus_body)) (n)) (fun y : (nat) -> nat => ((((eq) (nat)) (((minus) (n)) ((S) (m)))) ((pred) (((minus) (n)) (m)))) -> (((eq) (nat)) (((minus_body) ((S) (n))) ((S) ((S) (m))))) ((pred) ((y) ((S) (m)))))) ((((sym_eq_minus_body_S) (n)) (fun y : (nat) -> nat => ((((eq) (nat)) (((minus) (n)) ((S) (m)))) ((pred) (((minus) (n)) (m)))) -> (((eq) (nat)) (((minus_body) ((S) (n))) ((S) ((S) (m))))) ((pred) ((y) ((S) (m)))))) ((((sym_eq_minus_body_S) (n)) (fun y : (nat) -> nat => ((((eq) (nat)) (((minus) (n)) ((S) (m)))) ((pred) (((minus) (n)) (m)))) -> (((eq) (nat)) ((y) ((S) ((S) (m))))) ((pred) (((((match_nat_type) (nat)) ((S) (n))) (fun q : nat => ((minus) (n)) (q))) ((S) (m)))))) (((((((sym_eq_match_nat_type_S) (nat)) ((S) (n))) (fun q : nat => ((minus) (n)) (q))) ((S) (m))) (fun y : nat => ((((eq) (nat)) (((minus) (n)) ((S) (m)))) ((pred) (((minus) (n)) (m)))) -> (((eq) (nat)) (y)) (((((match_nat_type) (nat)) (O)) (fun p : nat => p)) (((((match_nat_type) (nat)) ((S) (n))) (fun q : nat => ((minus) (n)) (q))) ((S) (m)))))) (((((((sym_eq_match_nat_type_S) (nat)) ((S) (n))) (fun q : nat => ((minus) (n)) (q))) (m)) (fun y : nat => ((((eq) (nat)) (((minus) (n)) ((S) (m)))) ((pred) (((minus) (n)) (m)))) -> (((eq) (nat)) (((minus) (n)) ((S) (m)))) (((((match_nat_type) (nat)) (O)) (fun p : nat => p)) (y)))) (fun auto : (((eq) (nat)) (((minus) (n)) ((S) (m)))) (((((match_nat_type) (nat)) (O)) (fun p : nat => p)) (((minus) (n)) (m))) => ((((((rewrite_r) (nat)) (((((match_nat_type) (nat)) (O)) (fun p : nat => p)) (((minus) (n)) (m)))) (fun Joker_ : nat => (((eq) (nat)) (Joker_)) (((((match_nat_type) (nat)) (O)) (fun p : nat => p)) (((minus) (n)) (m))))) (((refl) (nat)) (((((match_nat_type) (nat)) (O)) (fun p : nat => p)) (((minus) (n)) (m))))) (((minus) (n)) ((S) (m)))) (auto)))))))))).
Definition not_eq_S : forall n : nat, forall m : nat, ((Not) ((((eq) (nat)) (n)) (m))) -> (Not) ((((eq) (nat)) ((S) (n))) ((S) (m))) := fun n : nat => fun m : nat => fun auto : (Not) ((((eq) (nat)) (n)) (m)) => ((((not_to_not) ((((eq) (nat)) ((S) (n))) ((S) (m)))) ((((eq) (nat)) (n)) (m))) (fun auto' : (((eq) (nat)) ((S) (n))) ((S) (m)) => ((((((rewrite_l) (nat)) (m)) (fun Joker_ : nat => (((eq) (nat)) (Joker_)) (m))) (((refl) (nat)) (m))) (n)) (((((((rewrite_r) (nat)) ((pred) ((S) (n)))) (fun Joker_ : nat => (((eq) (nat)) (m)) (Joker_))) (((((((rewrite_r) (nat)) ((S) (m))) (fun Joker_ : nat => (((eq) (nat)) (m)) ((pred) (Joker_)))) ((pred_Sn) (m))) ((S) (n))) (auto'))) (n)) ((pred_Sn) (n))))) (auto).
Definition not_eq_O_S : forall n : nat, (Not) ((((eq) (nat)) (O)) ((S) (n))) := fun n : nat => fun eqOS : (((eq) (nat)) (O)) ((S) (n)) => (((((eq_match_nat_type_O) Prop) (False)) (fun p : nat => True)) (fun y : Prop => y)) (((((((eq_ind_r) (nat)) ((S) (n))) (fun x : nat => (not_zero) (x))) (((((((sym_eq_match_nat_type_S) Prop) (False)) (fun p : nat => True)) (n)) (fun y : Prop => y)) (I))) (O)) (eqOS)).
Definition lt_to_not_zero : forall n : nat, forall m : nat, (((lt) (n)) (m)) -> (not_zero) (m) := fun n : nat => fun m : nat => fun Hlt : ((lt) (n)) (m) => ((((((le_ind) ((S) (n))) (fun x_417 : nat => (not_zero) (x_417))) (((((((sym_eq_match_nat_type_S) Prop) (False)) (fun p : nat => True)) (n)) (fun y : Prop => y)) (I))) (fun m0 : nat => fun Jokerx_419 : ((le) ((S) (n))) (m0) => fun Jokerx_421 : (not_zero) (m0) => ((((((sym_eq_match_nat_type_S) Prop) (False)) (fun p : nat => True)) (m0)) (fun y : Prop => y)) (I))) (m)) (Hlt).
Definition le_S_S : forall n : nat, forall m : nat, (((le) (n)) (m)) -> ((le) ((S) (n))) ((S) (m)) := fun n : nat => fun m : nat => fun lenm : ((le) (n)) (m) => ((((((le_ind) (n)) (fun x_417 : nat => ((le) ((S) (n))) ((S) (x_417)))) ((le_n) ((S) (n)))) (fun m0 : nat => fun Jokerx_419 : ((le) (n)) (m0) => fun Jokerx_421 : ((le) ((S) (n))) ((S) (m0)) => (((le_S) ((S) (n))) ((S) (m0))) (Jokerx_421))) (m)) (lenm).
Definition le_O_n : forall n : nat, ((le) (O)) (n) := fun n : nat => ((((nat_ind) ((le) (O))) ((le_n) (O))) (fun x_366 : nat => fun Jokerx_368 : ((le) (O)) (x_366) => (((le_S) (O)) (x_366)) (Jokerx_368))) (n).
Definition le_n_Sn : forall n : nat, ((le) (n)) ((S) (n)) := fun n : nat => (((le_S) (n)) (n)) ((le_n) (n)).
Definition transitive_le : ((transitive) (nat)) (le) := fun a : nat => fun b : nat => fun c : nat => fun leab : ((le) (a)) (b) => fun lebc : ((le) (b)) (c) => ((((((le_ind) (b)) (fun x_417 : nat => ((le) (a)) (x_417))) (leab)) (fun m : nat => fun Jokerx_419 : ((le) (b)) (m) => fun Jokerx_421 : ((le) (a)) (m) => (((le_S) (a)) (m)) (Jokerx_421))) (c)) (lebc).
Definition le_pred_n : forall n : nat, ((le) ((pred) (n))) (n) := fun n : nat => ((((nat_ind) (fun Jokerx_365 : nat => ((le) ((pred) (Jokerx_365))) (Jokerx_365))) ((((((eq_match_nat_type_O) (nat)) (O)) (fun p : nat => p)) (fun y : nat => ((le) (((((match_nat_type) (nat)) (O)) (fun p : nat => p)) (O))) (y))) ((le_n) ((pred) (O))))) (fun x_366 : nat => fun Jokerx_368 : ((le) ((pred) (x_366))) (x_366) => ((((((eq_match_nat_type_S) (nat)) (O)) (fun p : nat => p)) (x_366)) (fun y : nat => ((le) ((pred) ((S) (x_366)))) ((S) (y)))) ((le_n_Sn) ((pred) ((S) (x_366)))))) (n).
Definition monotonic_pred : (((monotonic) (nat)) (le)) (pred) := fun n : nat => fun m : nat => fun lenm : ((le) (n)) (m) => ((((((le_ind) (n)) (fun x_417 : nat => ((le) ((pred) (n))) ((pred) (x_417)))) ((le_n) ((pred) (n)))) (fun m0 : nat => fun Jokerx_419 : ((le) (n)) (m0) => fun Jokerx_421 : ((le) ((pred) (n))) ((pred) (m0)) => (((((transitive_le) ((pred) (n))) (n)) ((pred) ((S) (m0)))) ((le_pred_n) (n))) (((((((sym_eq_match_nat_type_S) (nat)) (O)) (fun p : nat => p)) (m0)) (fun y : nat => ((le) (n)) (y))) (Jokerx_419)))) (m)) (lenm).
Definition le_S_S_to_le : forall n : nat, forall m : nat, (((le) ((S) (n))) ((S) (m))) -> ((le) (n)) (m) := fun n : nat => fun m : nat => fun auto : ((le) ((S) (n))) ((S) (m)) => ((((((eq_match_nat_type_S) (nat)) (O)) (fun p : nat => p)) (m)) (fun y : nat => ((le) (n)) (y))) (((((((eq_match_nat_type_S) (nat)) (O)) (fun p : nat => p)) (n)) (fun y : nat => ((le) (y)) (((((match_nat_type) (nat)) (O)) (fun p : nat => p)) ((S) (m))))) ((((monotonic_pred) ((S) (n))) ((S) (m))) (auto))).
Definition monotonic_le_plus_r : forall n : nat, (((monotonic) (nat)) (le)) (fun m : nat => ((plus) (n)) (m)) := fun n : nat => fun a : nat => fun b : nat => ((((nat_ind) (fun Jokerx_365 : nat => (((le) (a)) (b)) -> ((le) (((plus) (Jokerx_365)) (a))) (((plus) (Jokerx_365)) (b)))) ((((sym_eq_plus) (O)) (fun y : (nat) -> nat => (((le) (a)) (b)) -> ((le) (((plus) (O)) (a))) ((y) (b)))) ((((sym_eq_plus) (O)) (fun y : (nat) -> nat => (((le) (a)) (b)) -> ((le) ((y) (a))) (((((filter_nat_type) ((nat) -> nat)) (plus_body)) (O)) (b)))) (((((sym_eq_filter_nat_type_O) ((nat) -> nat)) (plus_body)) (fun y : (nat) -> nat => (((le) (a)) (b)) -> ((le) ((y) (a))) (((((filter_nat_type) ((nat) -> nat)) (plus_body)) (O)) (b)))) (((((sym_eq_filter_nat_type_O) ((nat) -> nat)) (plus_body)) (fun y : (nat) -> nat => (((le) (a)) (b)) -> ((le) (((plus_body) (O)) (a))) ((y) (b)))) (((sym_eq_plus_body_O) (fun y : (nat) -> nat => (((le) (a)) (b)) -> ((le) (((plus_body) (O)) (a))) ((y) (b)))) (((sym_eq_plus_body_O) (fun y : (nat) -> nat => (((le) (a)) (b)) -> ((le) ((y) (a))) (b))) (fun auto : ((le) (a)) (b) => auto)))))))) (fun m : nat => fun H : (((le) (a)) (b)) -> ((le) (((plus) (m)) (a))) (((plus) (m)) (b)) => fun leab : ((le) (a)) (b) => (((sym_eq_plus) ((S) (m))) (fun y : (nat) -> nat => ((le) (((plus) ((S) (m))) (a))) ((y) (b)))) ((((sym_eq_plus) ((S) (m))) (fun y : (nat) -> nat => ((le) ((y) (a))) (((((filter_nat_type) ((nat) -> nat)) (plus_body)) ((S) (m))) (b)))) ((((((sym_eq_filter_nat_type_S) ((nat) -> nat)) (plus_body)) (m)) (fun y : (nat) -> nat => ((le) ((y) (a))) (((((filter_nat_type) ((nat) -> nat)) (plus_body)) ((S) (m))) (b)))) ((((((sym_eq_filter_nat_type_S) ((nat) -> nat)) (plus_body)) (m)) (fun y : (nat) -> nat => ((le) (((plus_body) ((S) (m))) (a))) ((y) (b)))) ((((sym_eq_plus_body_S) (m)) (fun y : (nat) -> nat => ((le) (((plus_body) ((S) (m))) (a))) ((y) (b)))) ((((sym_eq_plus_body_S) (m)) (fun y : (nat) -> nat => ((le) ((y) (a))) ((S) (((plus) (m)) (b))))) ((((le_S_S) (((plus) (m)) (a))) (((plus) (m)) (b))) ((H) (leab)))))))))) (n).
Definition monotonic_le_plus_l : forall m : nat, (((monotonic) (nat)) (le)) (fun n : nat => ((plus) (n)) (m)) := fun m : nat => fun x : nat => fun y : nat => fun auto : ((le) (x)) (y) => ((((eq_coerc) (((le) (((plus) (m)) (x))) (((plus) (m)) (y)))) (((le) (((plus) (x)) (m))) (((plus) (y)) (m)))) (((((monotonic_le_plus_r) (m)) (x)) (y)) (auto))) (((((((rewrite_r) (nat)) (((plus) (m)) (x))) (fun Joker_ : nat => (((eq) Prop) (((le) (((plus) (m)) (x))) (((plus) (m)) (y)))) (((le) (Joker_)) (((plus) (y)) (m))))) (((((((rewrite_r) (nat)) (((plus) (m)) (y))) (fun Joker_ : nat => (((eq) Prop) (((le) (((plus) (m)) (x))) (((plus) (m)) (y)))) (((le) (((plus) (m)) (x))) (Joker_)))) (((refl) Prop) (((le) (((plus) (m)) (x))) (((plus) (m)) (y))))) (((plus) (y)) (m))) (((commutative_plus) (y)) (m)))) (((plus) (x)) (m))) (((commutative_plus) (x)) (m))).
Definition le_plus : forall n1 : nat, forall n2 : nat, forall m1 : nat, forall m2 : nat, (((le) (n1)) (n2)) -> (((le) (m1)) (m2)) -> ((le) (((plus) (n1)) (m1))) (((plus) (n2)) (m2)) := fun n1 : nat => fun n2 : nat => fun m1 : nat => fun m2 : nat => fun len : ((le) (n1)) (n2) => fun lem : ((le) (m1)) (m2) => (((((transitive_le) (((plus) (n1)) (m1))) (((plus) (n1)) (m2))) (((plus) (n2)) (m2))) (((((monotonic_le_plus_r) (n1)) (m1)) (m2)) (lem))) (((((monotonic_le_plus_l) (m2)) (n1)) (n2)) (len)).
Definition le_plus_n : forall n : nat, forall m : nat, ((le) (m)) (((plus) (n)) (m)) := fun n : nat => fun m : nat => ((((eq_coerc) (((le) (((plus) (O)) (m))) (((plus) (n)) (m)))) (((le) (m)) (((plus) (n)) (m)))) (((((monotonic_le_plus_l) (m)) (O)) (n)) ((le_O_n) (n)))) (((((((rewrite_l) (nat)) (m)) (fun Joker_ : nat => (((eq) Prop) (((le) (Joker_)) (((plus) (n)) (m)))) (((le) (m)) (((plus) (n)) (m))))) (((refl) Prop) (((le) (m)) (((plus) (n)) (m))))) (((plus) (O)) (m))) ((plus_O_n) (m))).
Definition le_plus_b : forall b : nat, forall n : nat, forall m : nat, (((le) (((plus) (n)) (b))) (m)) -> ((le) (n)) (m) := fun b : nat => fun n : nat => fun m : nat => fun auto : ((le) (((plus) (n)) (b))) (m) => (((((transitive_le) (n)) (((plus) (n)) (b))) (m)) (((((eq_coerc) (((le) (n)) (((plus) (b)) (n)))) (((le) (n)) (((plus) (n)) (b)))) (((le_plus_n) (b)) (n))) (((((((rewrite_r) (nat)) (((plus) (b)) (n))) (fun Joker_ : nat => (((eq) Prop) (((le) (n)) (((plus) (b)) (n)))) (((le) (n)) (Joker_)))) (((refl) Prop) (((le) (n)) (((plus) (b)) (n))))) (((plus) (n)) (b))) (((commutative_plus) (n)) (b))))) (auto).
Definition le_plus_n_r : forall n : nat, forall m : nat, ((le) (m)) (((plus) (m)) (n)) := fun n : nat => fun m : nat => ((((eq_coerc) (((le) (m)) (((plus) (n)) (m)))) (((le) (m)) (((plus) (m)) (n)))) (((le_plus_n) (n)) (m))) (((((((rewrite_r) (nat)) (((plus) (n)) (m))) (fun Joker_ : nat => (((eq) Prop) (((le) (m)) (((plus) (n)) (m)))) (((le) (m)) (Joker_)))) (((refl) Prop) (((le) (m)) (((plus) (n)) (m))))) (((plus) (m)) (n))) (((commutative_plus) (m)) (n))).
Definition le_plus_to_le : forall a : nat, forall n : nat, forall m : nat, (((le) (((plus) (a)) (n))) (((plus) (a)) (m))) -> ((le) (n)) (m) := fun a : nat => ((((nat_ind) (fun Jokerx_365 : nat => forall n : nat, forall m : nat, (((le) (((plus) (Jokerx_365)) (n))) (((plus) (Jokerx_365)) (m))) -> ((le) (n)) (m))) (fun n : nat => fun m : nat => (((sym_eq_plus) (O)) (fun y : (nat) -> nat => (((le) (((plus) (O)) (n))) ((y) (m))) -> ((le) (n)) (m))) ((((sym_eq_plus) (O)) (fun y : (nat) -> nat => (((le) ((y) (n))) (((((filter_nat_type) ((nat) -> nat)) (plus_body)) (O)) (m))) -> ((le) (n)) (m))) (((((sym_eq_filter_nat_type_O) ((nat) -> nat)) (plus_body)) (fun y : (nat) -> nat => (((le) ((y) (n))) (((((filter_nat_type) ((nat) -> nat)) (plus_body)) (O)) (m))) -> ((le) (n)) (m))) (((((sym_eq_filter_nat_type_O) ((nat) -> nat)) (plus_body)) (fun y : (nat) -> nat => (((le) (((plus_body) (O)) (n))) ((y) (m))) -> ((le) (n)) (m))) (((sym_eq_plus_body_O) (fun y : (nat) -> nat => (((le) (((plus_body) (O)) (n))) ((y) (m))) -> ((le) (n)) (m))) (((sym_eq_plus_body_O) (fun y : (nat) -> nat => (((le) ((y) (n))) (m)) -> ((le) (n)) (m))) (fun auto : ((le) (n)) (m) => auto)))))))) (fun x_366 : nat => fun Jokerx_368 : forall n : nat, forall m : nat, (((le) (((plus) (x_366)) (n))) (((plus) (x_366)) (m))) -> ((le) (n)) (m) => fun n : nat => fun m : nat => (((sym_eq_plus) ((S) (x_366))) (fun y : (nat) -> nat => (((le) (((plus) ((S) (x_366))) (n))) ((y) (m))) -> ((le) (n)) (m))) ((((sym_eq_plus) ((S) (x_366))) (fun y : (nat) -> nat => (((le) ((y) (n))) (((((filter_nat_type) ((nat) -> nat)) (plus_body)) ((S) (x_366))) (m))) -> ((le) (n)) (m))) ((((((sym_eq_filter_nat_type_S) ((nat) -> nat)) (plus_body)) (x_366)) (fun y : (nat) -> nat => (((le) ((y) (n))) (((((filter_nat_type) ((nat) -> nat)) (plus_body)) ((S) (x_366))) (m))) -> ((le) (n)) (m))) ((((((sym_eq_filter_nat_type_S) ((nat) -> nat)) (plus_body)) (x_366)) (fun y : (nat) -> nat => (((le) (((plus_body) ((S) (x_366))) (n))) ((y) (m))) -> ((le) (n)) (m))) ((((sym_eq_plus_body_S) (x_366)) (fun y : (nat) -> nat => (((le) (((plus_body) ((S) (x_366))) (n))) ((y) (m))) -> ((le) (n)) (m))) ((((sym_eq_plus_body_S) (x_366)) (fun y : (nat) -> nat => (((le) ((y) (n))) ((S) (((plus) (x_366)) (m)))) -> ((le) (n)) (m))) (fun auto : ((le) ((S) (((plus) (x_366)) (n)))) ((S) (((plus) (x_366)) (m))) => ((((eq_coerc) (((le) ((pred) ((S) (n)))) ((pred) ((S) (m))))) (((le) (n)) (m))) ((((monotonic_pred) ((S) (n))) ((S) (m))) ((((Jokerx_368) ((S) (n))) ((S) (m))) (((((eq_coerc) (((le) ((S) (((plus) (x_366)) (n)))) ((S) (((plus) (x_366)) (m))))) (((le) (((plus) (x_366)) ((S) (n)))) (((plus) (x_366)) ((S) (m))))) (auto)) (((((((rewrite_r) (nat)) (((plus) (x_366)) ((S) (n)))) (fun Joker_ : nat => (((eq) Prop) (((le) (Joker_)) ((S) (((plus) (x_366)) (m))))) (((le) (((plus) (x_366)) ((S) (n)))) (((plus) (x_366)) ((S) (m)))))) (((((((rewrite_r) (nat)) (((plus) (x_366)) ((S) (m)))) (fun Joker_ : nat => (((eq) Prop) (((le) (((plus) (x_366)) ((S) (n)))) (Joker_))) (((le) (((plus) (x_366)) ((S) (n)))) (((plus) (x_366)) ((S) (m)))))) (((refl) Prop) (((le) (((plus) (x_366)) ((S) (n)))) (((plus) (x_366)) ((S) (m)))))) ((S) (((plus) (x_366)) (m)))) (((plus_n_Sm) (x_366)) (m)))) ((S) (((plus) (x_366)) (n)))) (((plus_n_Sm) (x_366)) (n))))))) (((((((rewrite_l) (nat)) (n)) (fun Joker_ : nat => (((eq) Prop) (((le) (Joker_)) ((pred) ((S) (m))))) (((le) (n)) (m)))) (((((((rewrite_l) (nat)) (m)) (fun Joker_ : nat => (((eq) Prop) (((le) (n)) (Joker_))) (((le) (n)) (m)))) (((refl) Prop) (((le) (n)) (m)))) ((pred) ((S) (m)))) ((pred_Sn) (m)))) ((pred) ((S) (n)))) ((pred_Sn) (n))))))))))) (a).
Definition le_plus_to_le_r : forall a : nat, forall n : nat, forall m : nat, (((le) (((plus) (n)) (a))) (((plus) (m)) (a))) -> ((le) (n)) (m) := fun a : nat => fun n : nat => fun m : nat => fun auto : ((le) (((plus) (n)) (a))) (((plus) (m)) (a)) => ((((le_plus_to_le) (a)) (n)) (m)) (((((eq_coerc) (((le) (((plus) (n)) (a))) (((plus) (m)) (a)))) (((le) (((plus) (a)) (n))) (((plus) (a)) (m)))) (auto)) (((((((rewrite_r) (nat)) (((plus) (a)) (n))) (fun Joker_ : nat => (((eq) Prop) (((le) (Joker_)) (((plus) (m)) (a)))) (((le) (((plus) (a)) (n))) (((plus) (a)) (m))))) (((((((rewrite_r) (nat)) (((plus) (a)) (m))) (fun Joker_ : nat => (((eq) Prop) (((le) (((plus) (a)) (n))) (Joker_))) (((le) (((plus) (a)) (n))) (((plus) (a)) (m))))) (((refl) Prop) (((le) (((plus) (a)) (n))) (((plus) (a)) (m))))) (((plus) (m)) (a))) (((commutative_plus) (m)) (a)))) (((plus) (n)) (a))) (((commutative_plus) (n)) (a)))).
Definition monotonic_le_times_r : forall n : nat, (((monotonic) (nat)) (le)) (fun m : nat => ((times) (n)) (m)) := fun n : nat => fun x : nat => fun y : nat => fun lexy : ((le) (x)) (y) => ((((nat_ind) (fun Jokerx_365 : nat => ((le) (((times) (Jokerx_365)) (x))) (((times) (Jokerx_365)) (y)))) ((((sym_eq_times) (O)) (fun z : (nat) -> nat => ((le) (((times) (O)) (x))) ((z) (y)))) ((((sym_eq_times) (O)) (fun z : (nat) -> nat => ((le) ((z) (x))) (((((filter_nat_type) ((nat) -> nat)) (times_body)) (O)) (y)))) (((((sym_eq_filter_nat_type_O) ((nat) -> nat)) (times_body)) (fun z : (nat) -> nat => ((le) ((z) (x))) (((((filter_nat_type) ((nat) -> nat)) (times_body)) (O)) (y)))) (((((sym_eq_filter_nat_type_O) ((nat) -> nat)) (times_body)) (fun z : (nat) -> nat => ((le) (((times_body) (O)) (x))) ((z) (y)))) (((sym_eq_times_body_O) (fun z : (nat) -> nat => ((le) (((times_body) (O)) (x))) ((z) (y)))) (((sym_eq_times_body_O) (fun z : (nat) -> nat => ((le) ((z) (x))) (O))) ((le_O_n) (O))))))))) (fun a : nat => fun lea : ((le) (((times) (a)) (x))) (((times) (a)) (y)) => (((sym_eq_times) ((S) (a))) (fun z : (nat) -> nat => ((le) (((times) ((S) (a))) (x))) ((z) (y)))) ((((sym_eq_times) ((S) (a))) (fun z : (nat) -> nat => ((le) ((z) (x))) (((((filter_nat_type) ((nat) -> nat)) (times_body)) ((S) (a))) (y)))) ((((((sym_eq_filter_nat_type_S) ((nat) -> nat)) (times_body)) (a)) (fun z : (nat) -> nat => ((le) ((z) (x))) (((((filter_nat_type) ((nat) -> nat)) (times_body)) ((S) (a))) (y)))) ((((((sym_eq_filter_nat_type_S) ((nat) -> nat)) (times_body)) (a)) (fun z : (nat) -> nat => ((le) (((times_body) ((S) (a))) (x))) ((z) (y)))) ((((sym_eq_times_body_S) (a)) (fun z : (nat) -> nat => ((le) (((times_body) ((S) (a))) (x))) ((z) (y)))) ((((sym_eq_times_body_S) (a)) (fun z : (nat) -> nat => ((le) ((z) (x))) (((plus) (y)) (((times) (a)) (y))))) (((((((le_plus) (x)) (y)) (((times) (a)) (x))) (((times) (a)) (y))) (lexy)) (lea))))))))) (n).
Definition le_times : forall n1 : nat, forall n2 : nat, forall m1 : nat, forall m2 : nat, (((le) (n1)) (n2)) -> (((le) (m1)) (m2)) -> ((le) (((times) (n1)) (m1))) (((times) (n2)) (m2)) := fun n1 : nat => fun n2 : nat => fun m1 : nat => fun m2 : nat => fun len : ((le) (n1)) (n2) => fun lem : ((le) (m1)) (m2) => (((((transitive_le) (((times) (n1)) (m1))) (((times) (n1)) (m2))) (((times) (n2)) (m2))) (((((monotonic_le_times_r) (n1)) (m1)) (m2)) (lem))) (((((eq_coerc) (((le) (((times) (m2)) (n1))) (((times) (m2)) (n2)))) (((le) (((times) (n1)) (m2))) (((times) (n2)) (m2)))) (((((monotonic_le_times_r) (m2)) (n1)) (n2)) (len))) (((((((rewrite_r) (nat)) (((times) (n1)) (m2))) (fun Joker_ : nat => (((eq) Prop) (((le) (Joker_)) (((times) (m2)) (n2)))) (((le) (((times) (n1)) (m2))) (((times) (n2)) (m2))))) (((((((rewrite_r) (nat)) (((times) (n2)) (m2))) (fun Joker_ : nat => (((eq) Prop) (((le) (((times) (n1)) (m2))) (Joker_))) (((le) (((times) (n1)) (m2))) (((times) (n2)) (m2))))) (((refl) Prop) (((le) (((times) (n1)) (m2))) (((times) (n2)) (m2))))) (((times) (m2)) (n2))) (((commutative_times) (m2)) (n2)))) (((times) (m2)) (n1))) (((commutative_times) (m2)) (n1)))).
Definition le_plus_minus_m_m : forall n : nat, forall m : nat, ((le) (n)) (((plus) (((minus) (n)) (m))) (m)) := fun n : nat => ((((nat_ind) (fun Jokerx_365 : nat => forall m : nat, ((le) (Jokerx_365)) (((plus) (((minus) (Jokerx_365)) (m))) (m)))) ((((sym_eq_minus) (O)) (fun y : (nat) -> nat => forall m : nat, ((le) (O)) (((plus) ((y) (m))) (m)))) (((((sym_eq_filter_nat_type_O) ((nat) -> nat)) (minus_body)) (fun y : (nat) -> nat => forall m : nat, ((le) (O)) (((plus) ((y) (m))) (m)))) (((sym_eq_minus_body_O) (fun y : (nat) -> nat => forall m : nat, ((le) (O)) (((plus) ((y) (m))) (m)))) (fun m : nat => ((le_plus_n_r) (m)) (O)))))) (fun a : nat => fun Hind : forall m : nat, ((le) (a)) (((plus) (((minus) (a)) (m))) (m)) => fun m : nat => ((((match_nat_prop) (fun Joker_ : nat => ((le) ((S) (a))) (((plus) (((minus) ((S) (a))) (Joker_))) (Joker_)))) ((((sym_eq_minus) ((S) (a))) (fun y : (nat) -> nat => ((le) ((S) (a))) (((plus) ((y) (O))) (O)))) ((((((sym_eq_filter_nat_type_S) ((nat) -> nat)) (minus_body)) (a)) (fun y : (nat) -> nat => ((le) ((S) (a))) (((plus) ((y) (O))) (O)))) ((((sym_eq_minus_body_S) (a)) (fun y : (nat) -> nat => ((le) ((S) (a))) (((plus) ((y) (O))) (O)))) ((((((sym_eq_match_nat_type_O) (nat)) ((S) (a))) (fun q : nat => ((minus) (a)) (q))) (fun y : nat => ((le) ((S) (a))) (((plus) (y)) (O)))) (((le_plus_n_r) (O)) ((S) (a)))))))) (fun n0 : nat => (((sym_eq_minus) ((S) (a))) (fun y : (nat) -> nat => ((le) ((S) (a))) (((plus) ((y) ((S) (n0)))) ((S) (n0))))) ((((((sym_eq_filter_nat_type_S) ((nat) -> nat)) (minus_body)) (a)) (fun y : (nat) -> nat => ((le) ((S) (a))) (((plus) ((y) ((S) (n0)))) ((S) (n0))))) ((((sym_eq_minus_body_S) (a)) (fun y : (nat) -> nat => ((le) ((S) (a))) (((plus) ((y) ((S) (n0)))) ((S) (n0))))) (((((((sym_eq_match_nat_type_S) (nat)) ((S) (a))) (fun q : nat => ((minus) (a)) (q))) (n0)) (fun y : nat => ((le) ((S) (a))) (((plus) (y)) ((S) (n0))))) (((((eq_coerc) (((le) ((S) (a))) ((S) (((plus) (((minus) (a)) (n0))) (n0))))) (((le) ((S) (a))) (((plus) (((minus) (a)) (n0))) ((S) (n0))))) ((((le_S_S) (a)) (((plus) (((minus) (a)) (n0))) (n0))) ((Hind) (n0)))) (((((((rewrite_r) (nat)) (((plus) (((minus) (a)) (n0))) ((S) (n0)))) (fun Joker_ : nat => (((eq) Prop) (((le) ((S) (a))) (Joker_))) (((le) ((S) (a))) (((plus) (((minus) (a)) (n0))) ((S) (n0)))))) (((refl) Prop) (((le) ((S) (a))) (((plus) (((minus) (a)) (n0))) ((S) (n0)))))) ((S) (((plus) (((minus) (a)) (n0))) (n0)))) (((plus_n_Sm) (((minus) (a)) (n0))) (n0))))))))) (m))) (n).
Definition le_plus_to_minus_r : forall a : nat, forall b : nat, forall c : nat, (((le) (((plus) (a)) (b))) (c)) -> ((le) (a)) (((minus) (c)) (b)) := fun a : nat => fun b : nat => fun c : nat => fun H : ((le) (((plus) (a)) (b))) (c) => ((((le_plus_to_le_r) (b)) (a)) (((minus) (c)) (b))) ((((((transitive_le) (((plus) (a)) (b))) (c)) (((plus) (((minus) (c)) (b))) (b))) (H)) (((le_plus_minus_m_m) (c)) (b))).
Definition lt_to_le : forall x : nat, forall y : nat, (((lt) (x)) (y)) -> ((le) (x)) (y) := fun x : nat => fun y : nat => fun auto : ((lt) (x)) (y) => ((((le_plus_b) ((S) (O))) (x)) (y)) (((((eq_coerc) (((le) ((S) (x))) (y))) (((le) (((plus) (x)) ((S) (O)))) (y))) (auto)) (((((((rewrite_r) (nat)) (((plus) (x)) ((S) (O)))) (fun Joker_ : nat => (((eq) Prop) (((le) (Joker_)) (y))) (((le) (((plus) (x)) ((S) (O)))) (y)))) (((refl) Prop) (((le) (((plus) (x)) ((S) (O)))) (y)))) ((S) (x))) (((((((rewrite_r) (nat)) (((plus) (x)) (O))) (fun Joker_ : nat => (((eq) (nat)) ((S) (Joker_))) (((plus) (x)) ((S) (O))))) (((plus_n_Sm) (x)) (O))) (x)) ((plus_n_O) (x))))).
Definition transitive_lt : ((transitive) (nat)) (lt) := fun a : nat => fun b : nat => fun c : nat => fun ltab : ((lt) (a)) (b) => fun ltbc : ((lt) (b)) (c) => ((((((le_ind) ((S) (b))) (fun x_417 : nat => ((lt) (a)) (x_417))) ((((le_S) ((S) (a))) (b)) (ltab))) (fun m : nat => fun Jokerx_419 : ((le) ((S) (b))) (m) => fun Jokerx_421 : ((lt) (a)) (m) => (((le_S) ((S) (a))) (m)) (Jokerx_421))) (c)) (ltbc).
Definition lt_to_le_to_lt : forall n : nat, forall m : nat, forall p : nat, (((lt) (n)) (m)) -> (((le) (m)) (p)) -> ((lt) (n)) (p) := fun n : nat => fun m : nat => fun p : nat => fun H : ((lt) (n)) (m) => fun H1 : ((le) (m)) (p) => ((((((le_ind) (m)) (fun x_417 : nat => ((lt) (n)) (x_417))) (H)) (fun m0 : nat => fun Jokerx_419 : ((le) (m)) (m0) => fun Jokerx_421 : ((lt) (n)) (m0) => (((((transitive_lt) (n)) (m0)) ((S) (m0))) (Jokerx_421)) (((((eq_coerc) (((le) ((S) (m0))) (((plus) (O)) ((S) (m0))))) (((le) ((S) (m0))) ((S) (m0)))) (((le_plus_n) (O)) ((S) (m0)))) (((((((rewrite_l) (nat)) ((S) (m0))) (fun Joker_ : nat => (((eq) Prop) (((le) ((S) (m0))) (Joker_))) (((le) ((S) (m0))) ((S) (m0))))) (((refl) Prop) (((le) ((S) (m0))) ((S) (m0))))) (((plus) (O)) ((S) (m0)))) ((plus_O_n) ((S) (m0))))))) (p)) (H1).
Definition le_to_lt_to_lt : forall n : nat, forall m : nat, forall p : nat, (((le) (n)) (m)) -> (((lt) (m)) (p)) -> ((lt) (n)) (p) := fun n : nat => fun m : nat => fun p : nat => fun H : ((le) (n)) (m) => ((((((le_ind) (n)) (fun x_417 : nat => (((lt) (x_417)) (p)) -> ((lt) (n)) (p))) (fun auto : ((lt) (n)) (p) => auto)) (fun m0 : nat => fun Jokerx_419 : ((le) (n)) (m0) => fun Jokerx_421 : (((lt) (m0)) (p)) -> ((lt) (n)) (p) => fun auto : ((lt) ((S) (m0))) (p) => (Jokerx_421) ((((((transitive_lt) (m0)) ((S) (m0))) (p)) (((((eq_coerc) (((le) ((S) (m0))) (((plus) (O)) ((S) (m0))))) (((le) ((S) (m0))) ((S) (m0)))) (((le_plus_n) (O)) ((S) (m0)))) (((((((rewrite_l) (nat)) ((S) (m0))) (fun Joker_ : nat => (((eq) Prop) (((le) ((S) (m0))) (Joker_))) (((le) ((S) (m0))) ((S) (m0))))) (((refl) Prop) (((le) ((S) (m0))) ((S) (m0))))) (((plus) (O)) ((S) (m0)))) ((plus_O_n) ((S) (m0)))))) (auto)))) (m)) (H).
Definition lt_S_to_lt : forall n : nat, forall m : nat, (((lt) ((S) (n))) (m)) -> ((lt) (n)) (m) := fun n : nat => fun m : nat => fun auto : ((lt) ((S) (n))) (m) => (((((transitive_lt) (n)) ((S) (n))) (m)) (((((eq_coerc) (((le) ((S) (n))) (((plus) (O)) ((S) (n))))) (((le) ((S) (n))) ((S) (n)))) (((le_plus_n) (O)) ((S) (n)))) (((((((rewrite_l) (nat)) ((S) (n))) (fun Joker_ : nat => (((eq) Prop) (((le) ((S) (n))) (Joker_))) (((le) ((S) (n))) ((S) (n))))) (((refl) Prop) (((le) ((S) (n))) ((S) (n))))) (((plus) (O)) ((S) (n)))) ((plus_O_n) ((S) (n)))))) (auto).
Definition ltn_to_ltO : forall n : nat, forall m : nat, (((lt) (n)) (m)) -> ((lt) (O)) (m) := fun n : nat => fun m : nat => fun auto : ((lt) (n)) (m) => (((((lt_to_le_to_lt) (O)) ((S) (n))) (m)) (((((eq_coerc) (((le) ((S) (O))) (((plus) (n)) ((S) (O))))) (((le) ((S) (O))) ((S) (n)))) (((le_plus_n) (n)) ((S) (O)))) (((((((rewrite_l) (nat)) ((S) (n))) (fun Joker_ : nat => (((eq) Prop) (((le) ((S) (O))) (Joker_))) (((le) ((S) (O))) ((S) (n))))) (((refl) Prop) (((le) ((S) (O))) ((S) (n))))) (((plus) (n)) ((S) (O)))) (((((((rewrite_r) (nat)) (((plus) (n)) (O))) (fun Joker_ : nat => (((eq) (nat)) ((S) (Joker_))) (((plus) (n)) ((S) (O))))) (((plus_n_Sm) (n)) (O))) (n)) ((plus_n_O) (n)))))) (auto).
Definition lt_O_S : forall n : nat, ((lt) (O)) ((S) (n)) := fun n : nat => (((ltn_to_ltO) (n)) ((S) (n))) (((((eq_coerc) (((le) ((S) (n))) (((plus) (O)) ((S) (n))))) (((le) ((S) (n))) ((S) (n)))) (((le_plus_n) (O)) ((S) (n)))) (((((((rewrite_l) (nat)) ((S) (n))) (fun Joker_ : nat => (((eq) Prop) (((le) ((S) (n))) (Joker_))) (((le) ((S) (n))) ((S) (n))))) (((refl) Prop) (((le) ((S) (n))) ((S) (n))))) (((plus) (O)) ((S) (n)))) ((plus_O_n) ((S) (n))))).
Definition monotonic_lt_plus_r : forall n : nat, (((monotonic) (nat)) (lt)) (fun m : nat => ((plus) (n)) (m)) := fun n : nat => fun x : nat => fun y : nat => fun auto : ((lt) (x)) (y) => ((((eq_coerc) (((le) (((plus) (n)) ((S) (x)))) (((plus) (n)) (y)))) (((le) ((S) (((plus) (n)) (x)))) (((plus) (n)) (y)))) (((((monotonic_le_plus_r) (n)) ((S) (x))) (y)) (auto))) (((((((rewrite_r) (nat)) (((plus) (n)) ((S) (x)))) (fun Joker_ : nat => (((eq) Prop) (((le) (((plus) (n)) ((S) (x)))) (((plus) (n)) (y)))) (((le) (Joker_)) (((plus) (n)) (y))))) (((refl) Prop) (((le) (((plus) (n)) ((S) (x)))) (((plus) (n)) (y))))) ((S) (((plus) (n)) (x)))) (((plus_n_Sm) (n)) (x))).
Definition monotonic_lt_plus_l : forall n : nat, (((monotonic) (nat)) (lt)) (fun m : nat => ((plus) (m)) (n)) := fun n : nat => fun x : nat => fun y : nat => fun auto : ((lt) (x)) (y) => ((((eq_coerc) (((le) (((plus) (n)) ((S) (x)))) (((plus) (n)) (y)))) (((le) ((S) (((plus) (x)) (n)))) (((plus) (y)) (n)))) (((((monotonic_le_plus_r) (n)) ((S) (x))) (y)) (auto))) (((((((rewrite_r) (nat)) (((plus) (n)) (x))) (fun Joker_ : nat => (((eq) Prop) (((le) (((plus) (n)) ((S) (x)))) (((plus) (n)) (y)))) (((le) ((S) (Joker_))) (((plus) (y)) (n))))) (((((((rewrite_r) (nat)) (((plus) (n)) ((S) (x)))) (fun Joker_ : nat => (((eq) Prop) (((le) (((plus) (n)) ((S) (x)))) (((plus) (n)) (y)))) (((le) (Joker_)) (((plus) (y)) (n))))) (((((((rewrite_r) (nat)) (((plus) (n)) (y))) (fun Joker_ : nat => (((eq) Prop) (((le) (((plus) (n)) ((S) (x)))) (((plus) (n)) (y)))) (((le) (((plus) (n)) ((S) (x)))) (Joker_)))) (((refl) Prop) (((le) (((plus) (n)) ((S) (x)))) (((plus) (n)) (y))))) (((plus) (y)) (n))) (((commutative_plus) (y)) (n)))) ((S) (((plus) (n)) (x)))) (((plus_n_Sm) (n)) (x)))) (((plus) (x)) (n))) (((commutative_plus) (x)) (n))).
Definition monotonic_lt_times_r : forall c : nat, (((lt) (O)) (c)) -> (((monotonic) (nat)) (lt)) (fun t : nat => ((times) (c)) (t)) := fun c : nat => fun posc : ((lt) (O)) (c) => fun n : nat => fun m : nat => fun ltnm : ((lt) (n)) (m) => ((((((le_ind) ((S) (n))) (fun x_417 : nat => ((lt) (((times) (c)) (n))) (((times) (c)) (x_417)))) (((((eq_coerc) (((le) ((S) (((plus) (O)) (((times) (c)) (n))))) (((plus) (c)) (((times) (c)) (n))))) (((le) ((S) (((times) (c)) (n)))) (((times) (c)) ((S) (n))))) (((((monotonic_lt_plus_l) (((times) (c)) (n))) (O)) (c)) (posc))) (((((((rewrite_r) (nat)) (((plus) (O)) ((S) (((times) (c)) (n))))) (fun Joker_ : nat => (((eq) Prop) (((le) (Joker_)) (((plus) (c)) (((times) (c)) (n))))) (((le) ((S) (((times) (c)) (n)))) (((times) (c)) ((S) (n)))))) (((((((rewrite_l) (nat)) (((plus) (c)) (((times) (c)) (n)))) (fun Joker_ : nat => (((eq) Prop) (((le) (((plus) (O)) ((S) (((times) (c)) (n))))) (((plus) (c)) (((times) (c)) (n))))) (((le) ((S) (((times) (c)) (n)))) (Joker_)))) (((((((rewrite_l) (nat)) ((S) (((times) (c)) (n)))) (fun Joker_ : nat => (((eq) Prop) (((le) (Joker_)) (((plus) (c)) (((times) (c)) (n))))) (((le) ((S) (((times) (c)) (n)))) (((plus) (c)) (((times) (c)) (n)))))) (((refl) Prop) (((le) ((S) (((times) (c)) (n)))) (((plus) (c)) (((times) (c)) (n)))))) (((plus) (O)) ((S) (((times) (c)) (n))))) ((plus_O_n) ((S) (((times) (c)) (n)))))) (((times) (c)) ((S) (n)))) (((times_n_Sm) (c)) (n)))) ((S) (((plus) (O)) (((times) (c)) (n))))) (((plus_n_Sm) (O)) (((times) (c)) (n)))))) (fun a : nat => fun Joker_ : ((le) ((S) (n))) (a) => fun lt1 : ((le) ((S) (((times) (c)) (n)))) (((times) (c)) (a)) => (((((transitive_le) ((S) (((times) (c)) (n)))) (((times) (c)) (a))) (((times) (c)) ((S) (a)))) (lt1)) (((((eq_coerc) (((le) (((times) (c)) (a))) (((plus) (((times) (c)) (a))) (c)))) (((le) (((times) (c)) (a))) (((times) (c)) ((S) (a))))) (((le_plus_n_r) (c)) (((times) (c)) (a)))) (((((((rewrite_l) (nat)) (((plus) (c)) (((times) (c)) (a)))) (fun Joker_1 : nat => (((eq) Prop) (((le) (((times) (c)) (a))) (((plus) (((times) (c)) (a))) (c)))) (((le) (((times) (c)) (a))) (Joker_1)))) (((((((rewrite_r) (nat)) (((plus) (c)) (((times) (c)) (a)))) (fun Joker_1 : nat => (((eq) Prop) (((le) (((times) (c)) (a))) (Joker_1))) (((le) (((times) (c)) (a))) (((plus) (c)) (((times) (c)) (a)))))) (((refl) Prop) (((le) (((times) (c)) (a))) (((plus) (c)) (((times) (c)) (a)))))) (((plus) (((times) (c)) (a))) (c))) (((commutative_plus) (((times) (c)) (a))) (c)))) (((times) (c)) ((S) (a)))) (((times_n_Sm) (c)) (a)))))) (m)) (ltnm).
Definition monotonic_lt_times_l : forall c : nat, (((lt) (O)) (c)) -> (((monotonic) (nat)) (lt)) (fun t : nat => ((times) (t)) (c)) := fun c : nat => fun auto : ((lt) (O)) (c) => fun x : nat => fun y : nat => fun auto' : ((lt) (x)) (y) => ((((eq_coerc) (((le) ((S) (((times) (c)) (x)))) (((times) (c)) (y)))) (((le) ((S) (((times) (x)) (c)))) (((times) (y)) (c)))) ((((((monotonic_lt_times_r) (c)) (auto)) (x)) (y)) (auto'))) (((((((rewrite_r) (nat)) (((times) (c)) (x))) (fun Joker_ : nat => (((eq) Prop) (((le) ((S) (((times) (c)) (x)))) (((times) (c)) (y)))) (((le) ((S) (Joker_))) (((times) (y)) (c))))) (((((((rewrite_r) (nat)) (((times) (c)) (y))) (fun Joker_ : nat => (((eq) Prop) (((le) ((S) (((times) (c)) (x)))) (((times) (c)) (y)))) (((le) ((S) (((times) (c)) (x)))) (Joker_)))) (((refl) Prop) (((le) ((S) (((times) (c)) (x)))) (((times) (c)) (y))))) (((times) (y)) (c))) (((commutative_times) (y)) (c)))) (((times) (x)) (c))) (((commutative_times) (x)) (c))).
Definition lt_to_le_to_lt_times : forall n : nat, forall m : nat, forall p : nat, forall q : nat, (((lt) (n)) (m)) -> (((le) (p)) (q)) -> (((lt) (O)) (q)) -> ((lt) (((times) (n)) (p))) (((times) (m)) (q)) := fun n : nat => fun m : nat => fun p : nat => fun q : nat => fun ltnm : ((lt) (n)) (m) => fun lepq : ((le) (p)) (q) => fun posq : ((lt) (O)) (q) => (((((le_to_lt_to_lt) (((times) (n)) (p))) (((times) (n)) (q))) (((times) (m)) (q))) (((((monotonic_le_times_r) (n)) (p)) (q)) (lepq))) ((((((monotonic_lt_times_l) (q)) (posq)) (n)) (m)) (ltnm)).
Definition lt_times : forall n : nat, forall m : nat, forall p : nat, forall q : nat, (((lt) (n)) (m)) -> (((lt) (p)) (q)) -> ((lt) (((times) (n)) (p))) (((times) (m)) (q)) := fun n : nat => fun m : nat => fun p : nat => fun q : nat => fun ltnm : ((lt) (n)) (m) => fun ltpq : ((lt) (p)) (q) => (((((((lt_to_le_to_lt_times) (n)) (m)) (p)) (q)) (ltnm)) ((((lt_to_le) (p)) (q)) (ltpq))) ((((ltn_to_ltO) (p)) (q)) (ltpq)).
Definition lt_plus_to_minus_r : forall a : nat, forall b : nat, forall c : nat, (((lt) (((plus) (a)) (b))) (c)) -> ((lt) (a)) (((minus) (c)) (b)) := fun a : nat => fun b : nat => fun c : nat => fun H : ((lt) (((plus) (a)) (b))) (c) => ((((le_plus_to_minus_r) ((S) (a))) (b)) (c)) ((((sym_eq_plus) ((S) (a))) (fun y : (nat) -> nat => ((le) ((y) (b))) (c))) ((((((sym_eq_filter_nat_type_S) ((nat) -> nat)) (plus_body)) (a)) (fun y : (nat) -> nat => ((le) ((y) (b))) (c))) ((((sym_eq_plus_body_S) (a)) (fun y : (nat) -> nat => ((le) ((y) (b))) (c))) (H)))).
Definition lt_plus_Sn_r : forall a : nat, forall x : nat, forall n : nat, ((lt) (a)) (((plus) (((plus) (a)) (x))) ((S) (n))) := fun a : nat => fun x : nat => fun n : nat => ((((eq_coerc) (((le) ((S) (a))) ((S) (((plus) (((plus) (a)) (x))) (n))))) (((le) ((S) (a))) (((plus) (((plus) (a)) (x))) ((S) (n))))) ((((le_S_S) (a)) (((plus) (((plus) (a)) (x))) (n))) (((((eq_coerc) (((le) (a)) (((plus) (a)) (((plus) (x)) (n))))) (((le) (a)) (((plus) (((plus) (a)) (x))) (n)))) (((le_plus_n_r) (((plus) (x)) (n))) (a))) (((((((rewrite_r) (nat)) (((plus) (n)) (((plus) (a)) (x)))) (fun Joker_ : nat => (((eq) Prop) (((le) (a)) (((plus) (a)) (((plus) (x)) (n))))) (((le) (a)) (Joker_)))) (((((((rewrite_r) (nat)) (((plus) (a)) (((plus) (n)) (x)))) (fun Joker_ : nat => (((eq) Prop) (((le) (a)) (((plus) (a)) (((plus) (x)) (n))))) (((le) (a)) (Joker_)))) (((((((rewrite_r) (nat)) (((plus) (x)) (n))) (fun Joker_ : nat => (((eq) Prop) (((le) (a)) (((plus) (a)) (((plus) (x)) (n))))) (((le) (a)) (((plus) (a)) (Joker_))))) (((refl) Prop) (((le) (a)) (((plus) (a)) (((plus) (x)) (n)))))) (((plus) (n)) (x))) (((commutative_plus) (n)) (x)))) (((plus) (n)) (((plus) (a)) (x)))) (((((((rewrite_l) (nat)) (((plus) (((plus) (a)) (n))) (x))) (fun Joker_ : nat => (((eq) (nat)) (((plus) (n)) (((plus) (a)) (x)))) (Joker_))) ((((assoc_plus1) (x)) (a)) (n))) (((plus) (a)) (((plus) (n)) (x)))) ((((associative_plus) (a)) (n)) (x))))) (((plus) (((plus) (a)) (x))) (n))) (((commutative_plus) (((plus) (a)) (x))) (n)))))) (((((((rewrite_r) (nat)) (((plus) (a)) (((plus) (x)) ((S) (n))))) (fun Joker_ : nat => (((eq) Prop) (((le) ((S) (a))) ((S) (((plus) (((plus) (a)) (x))) (n))))) (((le) ((S) (a))) (Joker_)))) (((((((rewrite_r) (nat)) (((plus) (((plus) (a)) (x))) ((S) (n)))) (fun Joker_ : nat => (((eq) Prop) (((le) ((S) (a))) (Joker_))) (((le) ((S) (a))) (((plus) (a)) (((plus) (x)) ((S) (n))))))) (((((((rewrite_r) (nat)) (((plus) (a)) (((plus) (x)) ((S) (n))))) (fun Joker_ : nat => (((eq) Prop) (((le) ((S) (a))) (Joker_))) (((le) ((S) (a))) (((plus) (a)) (((plus) (x)) ((S) (n))))))) (((refl) Prop) (((le) ((S) (a))) (((plus) (a)) (((plus) (x)) ((S) (n))))))) (((plus) (((plus) (a)) (x))) ((S) (n)))) ((((associative_plus) (a)) (x)) ((S) (n))))) ((S) (((plus) (((plus) (a)) (x))) (n)))) (((plus_n_Sm) (((plus) (a)) (x))) (n)))) (((plus) (((plus) (a)) (x))) ((S) (n)))) ((((associative_plus) (a)) (x)) ((S) (n)))).
Definition not_le_Sn_O : forall n : nat, (Not) (((le) ((S) (n))) (O)) := fun n : nat => fun Hlen0 : ((le) ((S) (n))) (O) => (((((eq_match_nat_type_O) Prop) (False)) (fun p : nat => True)) (fun y : Prop => y)) ((((lt_to_not_zero) (n)) (O)) (Hlen0)).
Definition not_le_to_not_le_S_S : forall n : nat, forall m : nat, ((Not) (((le) (n)) (m))) -> (Not) (((le) ((S) (n))) ((S) (m))) := fun n : nat => fun m : nat => fun auto : (Not) (((le) (n)) (m)) => ((((not_to_not) (((le) ((S) (n))) ((S) (m)))) (((le) (n)) (m))) (fun auto' : ((le) ((S) (n))) ((S) (m)) => ((((eq_coerc) (((le) ((pred) ((S) (n)))) ((pred) ((S) (m))))) (((le) (n)) (m))) ((((monotonic_pred) ((S) (n))) ((S) (m))) (auto'))) (((((((rewrite_l) (nat)) (n)) (fun Joker_ : nat => (((eq) Prop) (((le) (Joker_)) ((pred) ((S) (m))))) (((le) (n)) (m)))) (((((((rewrite_l) (nat)) (m)) (fun Joker_ : nat => (((eq) Prop) (((le) (n)) (Joker_))) (((le) (n)) (m)))) (((refl) Prop) (((le) (n)) (m)))) ((pred) ((S) (m)))) ((pred_Sn) (m)))) ((pred) ((S) (n)))) ((pred_Sn) (n))))) (auto).
Definition not_le_S_S_to_not_le : forall n : nat, forall m : nat, ((Not) (((le) ((S) (n))) ((S) (m)))) -> (Not) (((le) (n)) (m)) := fun n : nat => fun m : nat => fun auto : (Not) (((le) ((S) (n))) ((S) (m))) => ((((not_to_not) (((le) (n)) (m))) (((le) ((S) (n))) ((S) (m)))) (fun auto' : ((le) (n)) (m) => (((le_S_S) (n)) (m)) (auto'))) (auto).
Definition not_le_Sn_n : forall n : nat, (Not) (((le) ((S) (n))) (n)) := fun n : nat => ((((nat_ind) (fun Jokerx_365 : nat => (Not) (((le) ((S) (Jokerx_365))) (Jokerx_365)))) ((not_le_Sn_O) (O))) (fun x_366 : nat => fun Jokerx_368 : (Not) (((le) ((S) (x_366))) (x_366)) => (((not_le_to_not_le_S_S) ((S) (x_366))) (x_366)) (Jokerx_368))) (n).
Definition lt_to_not_le : forall n : nat, forall m : nat, (((lt) (n)) (m)) -> (Not) (((le) (m)) (n)) := fun n : nat => fun m : nat => fun Hltnm : ((lt) (n)) (m) => ((((((le_ind) ((S) (n))) (fun x_417 : nat => (Not) (((le) (x_417)) (n)))) ((not_le_Sn_n) (n))) (fun m0 : nat => fun Jokerx_419 : ((le) ((S) (n))) (m0) => fun Jokerx_421 : (Not) (((le) (m0)) (n)) => ((((not_to_not) (((le) ((S) (m0))) (n))) (((le) (m0)) (n))) (fun auto : ((le) ((S) (m0))) (n) => (((lt_to_le) (m0)) (n)) (auto))) (Jokerx_421))) (m)) (Hltnm).
Definition not_le_to_lt : forall n : nat, forall m : nat, ((Not) (((le) (n)) (m))) -> ((lt) (m)) (n) := ((((nat_elim2) (fun Joker_ : nat => fun Joker0 : nat => ((Not) (((le) (Joker_)) (Joker0))) -> ((lt) (Joker0)) (Joker_))) (fun n : nat => fun abs : (Not) (((le) (O)) (n)) => ((falsity) (((lt) (n)) (O))) ((((absurd) (((le) (O)) (n))) (((((eq_coerc) (((le) (O)) (((plus) (n)) (O)))) (((le) (O)) (n))) (((le_plus_n) (n)) (O))) (((((((rewrite_l) (nat)) (n)) (fun Joker_ : nat => (((eq) Prop) (((le) (O)) (Joker_))) (((le) (O)) (n)))) (((refl) Prop) (((le) (O)) (n)))) (((plus) (n)) (O))) ((plus_n_O) (n))))) (abs)))) (fun n : nat => fun auto : (Not) (((le) ((S) (n))) (O)) => (lt_O_S) (n))) (fun n : nat => fun m : nat => fun Hind : ((Not) (((le) (n)) (m))) -> ((lt) (m)) (n) => fun HnotleSS : (Not) (((le) ((S) (n))) ((S) (m))) => (((le_S_S) ((S) (m))) (n)) ((Hind) ((((not_le_S_S_to_not_le) (n)) (m)) (HnotleSS)))).
Definition not_lt_to_le : forall n : nat, forall m : nat, ((Not) (((lt) (n)) (m))) -> ((le) (m)) (n) := fun n : nat => fun m : nat => fun H : (Not) (((lt) (n)) (m)) => (((le_S_S_to_le) (m)) (n)) ((((not_le_to_lt) ((S) (n))) (m)) (((((not_to_not) (((le) ((S) (n))) (m))) (((lt) (n)) (m))) (fun auto : ((le) ((S) (n))) (m) => auto)) (H))).
Definition le_to_not_lt : forall n : nat, forall m : nat, (((le) (n)) (m)) -> (Not) (((lt) (m)) (n)) := fun n : nat => fun m : nat => fun H : ((le) (n)) (m) => (((lt_to_not_le) (n)) ((S) (m))) ((((((le_to_lt_to_lt) (n)) (m)) ((S) (m))) (H)) (((((eq_coerc) (((le) ((S) (m))) (((plus) (O)) ((S) (m))))) (((le) ((S) (m))) ((S) (m)))) (((le_plus_n) (O)) ((S) (m)))) (((((((rewrite_l) (nat)) ((S) (m))) (fun Joker_ : nat => (((eq) Prop) (((le) ((S) (m))) (Joker_))) (((le) ((S) (m))) ((S) (m))))) (((refl) Prop) (((le) ((S) (m))) ((S) (m))))) (((plus) (O)) ((S) (m)))) ((plus_O_n) ((S) (m)))))).
Definition decidable_le : forall n : nat, forall m : nat, (decidable) (((le) (n)) (m)) := ((((nat_elim2) (fun Joker_ : nat => fun Joker0 : nat => (decidable) (((le) (Joker_)) (Joker0)))) (fun n : nat => fun z : Prop => fun l : (((le) (O)) (n)) -> z => fun r : ((Not) (((le) (O)) (n))) -> z => (l) ((le_O_n) (n)))) (fun n : nat => fun z : Prop => fun l : (((le) ((S) (n))) (O)) -> z => fun r : ((Not) (((le) ((S) (n))) (O))) -> z => (r) ((not_le_Sn_O) (n)))) (fun n : nat => fun m : nat => fun Jokerclearme : (decidable) (((le) (n)) (m)) => ((((((match_Or_prop) (((le) (n)) (m))) ((Not) (((le) (n)) (m)))) ((decidable) (((le) ((S) (n))) ((S) (m))))) (fun auto : ((le) (n)) (m) => fun z : Prop => fun l : (((le) ((S) (n))) ((S) (m))) -> z => fun r : ((Not) (((le) ((S) (n))) ((S) (m)))) -> z => (l) ((((le_S_S) (n)) (m)) (auto)))) (fun auto : (Not) (((le) (n)) (m)) => fun z : Prop => fun l : (((le) ((S) (n))) ((S) (m))) -> z => fun r : ((Not) (((le) ((S) (n))) ((S) (m)))) -> z => (r) ((((not_le_to_not_le_S_S) (n)) (m)) (auto)))) (Jokerclearme)).
Definition decidable_lt : forall n : nat, forall m : nat, (decidable) (((lt) (n)) (m)) := fun n : nat => fun m : nat => ((decidable_le) ((S) (n))) (m).
Definition le_to_or_lt_eq : forall n : nat, forall m : nat, (((le) (n)) (m)) -> ((Or) (((lt) (n)) (m))) ((((eq) (nat)) (n)) (m)) := fun n : nat => fun m : nat => fun lenm : ((le) (n)) (m) => ((((((le_ind) (n)) (fun x_417 : nat => ((Or) (((lt) (n)) (x_417))) ((((eq) (nat)) (n)) (x_417)))) ((((RC_reflexive) (nat)) (lt)) (n))) (fun m0 : nat => fun Jokerx_419 : ((le) (n)) (m0) => fun Jokerx_421 : ((Or) (((lt) (n)) (m0))) ((((eq) (nat)) (n)) (m0)) => fun z : Prop => fun l : (((lt) (n)) ((S) (m0))) -> z => fun r : ((((eq) (nat)) (n)) ((S) (m0))) -> z => (l) ((((((le_to_lt_to_lt) (n)) (m0)) ((S) (m0))) (Jokerx_419)) (((((eq_coerc) (((le) ((S) (m0))) (((plus) (O)) ((S) (m0))))) (((le) ((S) (m0))) ((S) (m0)))) (((le_plus_n) (O)) ((S) (m0)))) (((((((rewrite_l) (nat)) ((S) (m0))) (fun Joker_ : nat => (((eq) Prop) (((le) ((S) (m0))) (Joker_))) (((le) ((S) (m0))) ((S) (m0))))) (((refl) Prop) (((le) ((S) (m0))) ((S) (m0))))) (((plus) (O)) ((S) (m0)))) ((plus_O_n) ((S) (m0)))))))) (m)) (lenm).
Definition lt_O_n_elim : forall n : nat, (((lt) (O)) (n)) -> forall P : (nat) -> Prop, (forall m : nat, (P) ((S) (m))) -> (P) (n) := fun n : nat => ((((nat_ind) (fun Jokerx_365 : nat => (((lt) (O)) (Jokerx_365)) -> forall P : (nat) -> Prop, (forall m : nat, (P) ((S) (m))) -> (P) (Jokerx_365))) (fun abs : ((lt) (O)) (O) => ((falsity) (forall P : (nat) -> Prop, (forall m : nat, (P) ((S) (m))) -> (P) (O))) ((((absurd) (((le) ((S) (O))) (O))) (abs)) ((not_le_Sn_O) (O))))) (fun x_366 : nat => fun Jokerx_368 : (((lt) (O)) (x_366)) -> forall P : (nat) -> Prop, (forall m : nat, (P) ((S) (m))) -> (P) (x_366) => fun auto : ((lt) (O)) ((S) (x_366)) => fun P : (nat) -> Prop => fun auto' : forall m : nat, (P) ((S) (m)) => (auto') (x_366))) (n).
Definition le_n_O_elim : forall n : nat, (((le) (n)) (O)) -> forall P : (nat) -> Prop, ((P) (O)) -> (P) (n) := fun n : nat => ((((match_nat_prop) (fun Joker_ : nat => (((le) (Joker_)) (O)) -> forall P : (nat) -> Prop, ((P) (O)) -> (P) (Joker_))) (fun auto : ((le) (O)) (O) => fun P : (nat) -> Prop => fun auto' : (P) (O) => auto')) (fun a : nat => fun abs : ((le) ((S) (a))) (O) => ((falsity) (forall P : (nat) -> Prop, ((P) (O)) -> (P) ((S) (a)))) ((((absurd) (((le) ((S) (a))) (O))) (abs)) ((not_le_Sn_O) (a))))) (n).
Definition lt_to_not_eq : forall n : nat, forall m : nat, (((lt) (n)) (m)) -> (Not) ((((eq) (nat)) (n)) (m)) := fun n : nat => fun m : nat => fun H : ((lt) (n)) (m) => ((((not_to_not) ((((eq) (nat)) (n)) (m))) (False)) (fun auto : (((eq) (nat)) (n)) (m) => (((absurd) (((le) ((S) (n))) (n))) (((((eq_coerc) (((le) ((S) (n))) (m))) (((le) ((S) (n))) (n))) (H)) (((((((rewrite_l) (nat)) (n)) (fun Joker_ : nat => (((eq) Prop) (((le) ((S) (n))) (Joker_))) (((le) ((S) (n))) (n)))) (((refl) Prop) (((le) ((S) (n))) (n)))) (m)) (auto)))) ((not_le_Sn_n) (n)))) (fun auto : False => auto).
Definition le_n_O_to_eq : forall n : nat, (((le) (n)) (O)) -> (((eq) (nat)) (O)) (n) := fun n : nat => ((((match_nat_prop) (fun Joker_ : nat => (((le) (Joker_)) (O)) -> (((eq) (nat)) (O)) (Joker_))) (fun auto : ((le) (O)) (O) => ((refl) (nat)) (O))) (fun a : nat => fun abs : ((le) ((S) (a))) (O) => ((falsity) ((((eq) (nat)) (O)) ((S) (a)))) ((((absurd) (((le) ((S) (a))) (O))) (abs)) ((not_le_Sn_O) (a))))) (n).
Definition le_to_le_to_eq : forall n : nat, forall m : nat, (((le) (n)) (m)) -> (((le) (m)) (n)) -> (((eq) (nat)) (n)) (m) := ((((nat_elim2) (fun Joker_ : nat => fun Joker0 : nat => (((le) (Joker_)) (Joker0)) -> (((le) (Joker0)) (Joker_)) -> (((eq) (nat)) (Joker_)) (Joker0))) (fun n : nat => fun auto : ((le) (O)) (n) => fun auto' : ((le) (n)) (O) => ((((sym_eq) (nat)) (n)) (O)) (((((sym_eq) (nat)) (O)) (n)) (((((eq_coerc) ((((eq) (nat)) (O)) (n))) ((((eq) (nat)) (O)) (n))) (((le_n_O_to_eq) (n)) (auto'))) (((refl) Prop) ((((eq) (nat)) (O)) (n))))))) (fun n : nat => fun auto : ((le) ((S) (n))) (O) => fun auto' : ((le) (O)) ((S) (n)) => ((((sym_eq) (nat)) (O)) ((S) (n))) (((le_n_O_to_eq) ((S) (n))) (auto)))) (fun n : nat => fun m : nat => fun auto : (((le) (n)) (m)) -> (((le) (m)) (n)) -> (((eq) (nat)) (n)) (m) => fun auto' : ((le) ((S) (n))) ((S) (m)) => fun auto'' : ((le) ((S) (m))) ((S) (n)) => ((((((eq_f) (nat)) (nat)) (S)) (n)) (m)) (((auto) (((((eq_coerc) (((le) ((pred) ((S) (n)))) ((pred) ((S) (m))))) (((le) (n)) (m))) ((((monotonic_pred) ((S) (n))) ((S) (m))) (auto'))) (((((((rewrite_l) (nat)) (n)) (fun Joker_ : nat => (((eq) Prop) (((le) (Joker_)) ((pred) ((S) (m))))) (((le) (n)) (m)))) (((((((rewrite_l) (nat)) (m)) (fun Joker_ : nat => (((eq) Prop) (((le) (n)) (Joker_))) (((le) (n)) (m)))) (((refl) Prop) (((le) (n)) (m)))) ((pred) ((S) (m)))) ((pred_Sn) (m)))) ((pred) ((S) (n)))) ((pred_Sn) (n))))) (((((eq_coerc) (((le) ((pred) ((S) (m)))) ((pred) ((S) (n))))) (((le) (m)) (n))) ((((monotonic_pred) ((S) (m))) ((S) (n))) (auto''))) (((((((rewrite_l) (nat)) (m)) (fun Joker_ : nat => (((eq) Prop) (((le) (Joker_)) ((pred) ((S) (n))))) (((le) (m)) (n)))) (((((((rewrite_l) (nat)) (n)) (fun Joker_ : nat => (((eq) Prop) (((le) (m)) (Joker_))) (((le) (m)) (n)))) (((refl) Prop) (((le) (m)) (n)))) ((pred) ((S) (n)))) ((pred_Sn) (n)))) ((pred) ((S) (m)))) ((pred_Sn) (m)))))).
Definition plus_minus : forall m : nat, forall n : nat, forall p : nat, (((le) (m)) (n)) -> (((eq) (nat)) (((plus) (((minus) (n)) (m))) (p))) (((minus) (((plus) (n)) (p))) (m)) := ((((nat_elim2) (fun Joker_ : nat => fun Joker0 : nat => forall p : nat, (((le) (Joker_)) (Joker0)) -> (((eq) (nat)) (((plus) (((minus) (Joker0)) (Joker_))) (p))) (((minus) (((plus) (Joker0)) (p))) (Joker_)))) (fun n : nat => fun p : nat => fun auto : ((le) (O)) (n) => ((((((rewrite_l) (nat)) (n)) (fun Joker_ : nat => (((eq) (nat)) (((plus) (Joker_)) (p))) (((minus) (((plus) (n)) (p))) (O)))) (((((((rewrite_l) (nat)) (((plus) (n)) (p))) (fun Joker_ : nat => (((eq) (nat)) (((plus) (n)) (p))) (Joker_))) (((refl) (nat)) (((plus) (n)) (p)))) (((minus) (((plus) (n)) (p))) (O))) ((minus_n_O) (((plus) (n)) (p))))) (((minus) (n)) (O))) ((minus_n_O) (n)))) (fun n : nat => fun p : nat => fun abs : ((le) ((S) (n))) (O) => ((falsity) ((((eq) (nat)) (((plus) (((minus) (O)) ((S) (n)))) (p))) (((minus) (((plus) (O)) (p))) ((S) (n))))) ((((absurd) (((le) ((S) (n))) (O))) (abs)) ((not_le_Sn_O) (n))))) (fun n : nat => fun m : nat => (((sym_eq_minus) ((S) (m))) (fun y : (nat) -> nat => (forall p : nat, (((le) (n)) (m)) -> (((eq) (nat)) (((plus) (((minus) (m)) (n))) (p))) (((minus) (((plus) (m)) (p))) (n))) -> forall p : nat, (((le) ((S) (n))) ((S) (m))) -> (((eq) (nat)) (((plus) ((y) ((S) (n)))) (p))) (((minus) (((plus) ((S) (m))) (p))) ((S) (n))))) ((((((sym_eq_filter_nat_type_S) ((nat) -> nat)) (minus_body)) (m)) (fun y : (nat) -> nat => (forall p : nat, (((le) (n)) (m)) -> (((eq) (nat)) (((plus) (((minus) (m)) (n))) (p))) (((minus) (((plus) (m)) (p))) (n))) -> forall p : nat, (((le) ((S) (n))) ((S) (m))) -> (((eq) (nat)) (((plus) ((y) ((S) (n)))) (p))) (((minus) (((plus) ((S) (m))) (p))) ((S) (n))))) ((((sym_eq_minus_body_S) (m)) (fun y : (nat) -> nat => (forall p : nat, (((le) (n)) (m)) -> (((eq) (nat)) (((plus) (((minus) (m)) (n))) (p))) (((minus) (((plus) (m)) (p))) (n))) -> forall p : nat, (((le) ((S) (n))) ((S) (m))) -> (((eq) (nat)) (((plus) ((y) ((S) (n)))) (p))) (((minus) (((plus) ((S) (m))) (p))) ((S) (n))))) (fun auto : forall p : nat, (((le) (n)) (m)) -> (((eq) (nat)) (((plus) (((minus) (m)) (n))) (p))) (((minus) (((plus) (m)) (p))) (n)) => fun p : nat => ((((((sym_eq_match_nat_type_S) (nat)) ((S) (m))) (fun q : nat => ((minus) (m)) (q))) (n)) (fun y : nat => (((le) ((S) (n))) ((S) (m))) -> (((eq) (nat)) (((plus) (y)) (p))) (((minus) (((plus) ((S) (m))) (p))) ((S) (n))))) ((((sym_eq_minus) (((plus) ((S) (m))) (p))) (fun y : (nat) -> nat => (((le) ((S) (n))) ((S) (m))) -> (((eq) (nat)) (((plus) (((minus) (m)) (n))) (p))) ((y) ((S) (n))))) ((((sym_eq_plus) ((S) (m))) (fun y : (nat) -> nat => (((le) ((S) (n))) ((S) (m))) -> (((eq) (nat)) (((plus) (((minus) (m)) (n))) (p))) (((((filter_nat_type) ((nat) -> nat)) (minus_body)) ((y) (p))) ((S) (n))))) ((((((sym_eq_filter_nat_type_S) ((nat) -> nat)) (plus_body)) (m)) (fun y : (nat) -> nat => (((le) ((S) (n))) ((S) (m))) -> (((eq) (nat)) (((plus) (((minus) (m)) (n))) (p))) (((((filter_nat_type) ((nat) -> nat)) (minus_body)) ((y) (p))) ((S) (n))))) ((((sym_eq_plus_body_S) (m)) (fun y : (nat) -> nat => (((le) ((S) (n))) ((S) (m))) -> (((eq) (nat)) (((plus) (((minus) (m)) (n))) (p))) (((((filter_nat_type) ((nat) -> nat)) (minus_body)) ((y) (p))) ((S) (n))))) ((((((sym_eq_filter_nat_type_S) ((nat) -> nat)) (minus_body)) (((plus) (m)) (p))) (fun y : (nat) -> nat => (((le) ((S) (n))) ((S) (m))) -> (((eq) (nat)) (((plus) (((minus) (m)) (n))) (p))) ((y) ((S) (n))))) ((((eq_plus_body_S) (m)) (fun y : (nat) -> nat => (((le) ((S) (n))) ((S) (m))) -> (((eq) (nat)) (((plus) (((minus) (m)) (n))) (p))) (((minus_body) ((y) (p))) ((S) (n))))) ((((((eq_filter_nat_type_S) ((nat) -> nat)) (plus_body)) (m)) (fun y : (nat) -> nat => (((le) ((S) (n))) ((S) (m))) -> (((eq) (nat)) (((plus) (((minus) (m)) (n))) (p))) (((minus_body) ((y) (p))) ((S) (n))))) ((((eq_plus) ((S) (m))) (fun y : (nat) -> nat => (((le) ((S) (n))) ((S) (m))) -> (((eq) (nat)) (((plus) (((minus) (m)) (n))) (p))) (((minus_body) ((y) (p))) ((S) (n))))) ((((sym_eq_plus) ((S) (m))) (fun y : (nat) -> nat => (((le) ((S) (n))) ((S) (m))) -> (((eq) (nat)) (((plus) (((minus) (m)) (n))) (p))) (((minus_body) ((y) (p))) ((S) (n))))) ((((((sym_eq_filter_nat_type_S) ((nat) -> nat)) (plus_body)) (m)) (fun y : (nat) -> nat => (((le) ((S) (n))) ((S) (m))) -> (((eq) (nat)) (((plus) (((minus) (m)) (n))) (p))) (((minus_body) ((y) (p))) ((S) (n))))) ((((sym_eq_plus_body_S) (m)) (fun y : (nat) -> nat => (((le) ((S) (n))) ((S) (m))) -> (((eq) (nat)) (((plus) (((minus) (m)) (n))) (p))) (((minus_body) ((y) (p))) ((S) (n))))) ((((sym_eq_minus_body_S) (((plus) (m)) (p))) (fun y : (nat) -> nat => (((le) ((S) (n))) ((S) (m))) -> (((eq) (nat)) (((plus) (((minus) (m)) (n))) (p))) ((y) ((S) (n))))) (((((((sym_eq_match_nat_type_S) (nat)) ((S) (((plus) (m)) (p)))) (fun q : nat => ((minus) (((plus) (m)) (p))) (q))) (n)) (fun y : nat => (((le) ((S) (n))) ((S) (m))) -> (((eq) (nat)) (((plus) (((minus) (m)) (n))) (p))) (y))) (fun auto' : ((le) ((S) (n))) ((S) (m)) => ((auto) (p)) (((((eq_coerc) (((le) ((pred) ((S) (n)))) ((pred) ((S) (m))))) (((le) (n)) (m))) ((((monotonic_pred) ((S) (n))) ((S) (m))) (auto'))) (((((((rewrite_l) (nat)) (n)) (fun Joker_ : nat => (((eq) Prop) (((le) (Joker_)) ((pred) ((S) (m))))) (((le) (n)) (m)))) (((((((rewrite_l) (nat)) (m)) (fun Joker_ : nat => (((eq) Prop) (((le) (n)) (Joker_))) (((le) (n)) (m)))) (((refl) Prop) (((le) (n)) (m)))) ((pred) ((S) (m)))) ((pred_Sn) (m)))) ((pred) ((S) (n)))) ((pred_Sn) (n)))))))))))))))))))))).
Definition minus_plus_m_m : forall n : nat, forall m : nat, (((eq) (nat)) (n)) (((minus) (((plus) (n)) (m))) (m)) := fun n : nat => fun m : nat => ((((eq_coerc) ((((eq) (nat)) (((plus) (((minus) (m)) (m))) (n))) (((minus) (((plus) (m)) (n))) (m)))) ((((eq) (nat)) (n)) (((minus) (((plus) (n)) (m))) (m)))) (((((plus_minus) (m)) (m)) (n)) ((le_n) (m)))) (((((((rewrite_l) (nat)) (O)) (fun Joker_ : nat => (((eq) Prop) ((((eq) (nat)) (((plus) (Joker_)) (n))) (((minus) (((plus) (m)) (n))) (m)))) ((((eq) (nat)) (n)) (((minus) (((plus) (n)) (m))) (m))))) (((((((rewrite_l) (nat)) (n)) (fun Joker_ : nat => (((eq) Prop) ((((eq) (nat)) (Joker_)) (((minus) (((plus) (m)) (n))) (m)))) ((((eq) (nat)) (n)) (((minus) (((plus) (n)) (m))) (m))))) (((((((rewrite_r) (nat)) (((plus) (n)) (m))) (fun Joker_ : nat => (((eq) Prop) ((((eq) (nat)) (n)) (((minus) (Joker_)) (m)))) ((((eq) (nat)) (n)) (((minus) (((plus) (n)) (m))) (m))))) (((refl) Prop) ((((eq) (nat)) (n)) (((minus) (((plus) (n)) (m))) (m))))) (((plus) (m)) (n))) (((commutative_plus) (m)) (n)))) (((plus) (O)) (n))) ((plus_O_n) (n)))) (((minus) (m)) (m))) ((minus_n_n) (m))).
Definition plus_minus_m_m : forall n : nat, forall m : nat, (((le) (m)) (n)) -> (((eq) (nat)) (n)) (((plus) (((minus) (n)) (m))) (m)) := fun n : nat => fun m : nat => fun lemn : ((le) (m)) (n) => ((((sym_eq) (nat)) (((plus) (((minus) (n)) (m))) (m))) (n)) (((((eq_coerc) ((((eq) (nat)) (((plus) (((minus) (n)) (m))) (m))) (((minus) (((plus) (n)) (m))) (m)))) ((((eq) (nat)) (((plus) (((minus) (n)) (m))) (m))) (n))) (((((plus_minus) (m)) (n)) (m)) (lemn))) (((((((rewrite_r) (nat)) (((plus) (m)) (((minus) (n)) (m)))) (fun Joker_ : nat => (((eq) Prop) ((((eq) (nat)) (((plus) (((minus) (n)) (m))) (m))) (((minus) (((plus) (n)) (m))) (m)))) ((((eq) (nat)) (Joker_)) (n)))) (((((((rewrite_r) (nat)) (((plus) (m)) (((minus) (n)) (m)))) (fun Joker_ : nat => (((eq) Prop) ((((eq) (nat)) (Joker_)) (((minus) (((plus) (n)) (m))) (m)))) ((((eq) (nat)) (((plus) (m)) (((minus) (n)) (m)))) (n)))) (((((((rewrite_l) (nat)) (n)) (fun Joker_ : nat => (((eq) Prop) ((((eq) (nat)) (((plus) (m)) (((minus) (n)) (m)))) (Joker_))) ((((eq) (nat)) (((plus) (m)) (((minus) (n)) (m)))) (n)))) (((refl) Prop) ((((eq) (nat)) (((plus) (m)) (((minus) (n)) (m)))) (n)))) (((minus) (((plus) (n)) (m))) (m))) (((minus_plus_m_m) (n)) (m)))) (((plus) (((minus) (n)) (m))) (m))) (((commutative_plus) (((minus) (n)) (m))) (m)))) (((plus) (((minus) (n)) (m))) (m))) (((commutative_plus) (((minus) (n)) (m))) (m)))).
Definition minus_to_plus : forall n : nat, forall m : nat, forall p : nat, (((le) (m)) (n)) -> ((((eq) (nat)) (((minus) (n)) (m))) (p)) -> (((eq) (nat)) (n)) (((plus) (m)) (p)) := fun n : nat => fun m : nat => fun p : nat => fun lemn : ((le) (m)) (n) => fun eqp : (((eq) (nat)) (((minus) (n)) (m))) (p) => ((((eq_coerc) ((((eq) (nat)) (n)) (((plus) (((minus) (n)) (m))) (m)))) ((((eq) (nat)) (n)) (((plus) (m)) (p)))) ((((plus_minus_m_m) (n)) (m)) (lemn))) (((((((rewrite_r) (nat)) (((plus) (m)) (((minus) (n)) (m)))) (fun Joker_ : nat => (((eq) Prop) ((((eq) (nat)) (n)) (Joker_))) ((((eq) (nat)) (n)) (((plus) (m)) (p))))) (((((((rewrite_r) (nat)) (p)) (fun Joker_ : nat => (((eq) Prop) ((((eq) (nat)) (n)) (((plus) (m)) (Joker_)))) ((((eq) (nat)) (n)) (((plus) (m)) (p))))) (((refl) Prop) ((((eq) (nat)) (n)) (((plus) (m)) (p))))) (((minus) (n)) (m))) (eqp))) (((plus) (((minus) (n)) (m))) (m))) (((commutative_plus) (((minus) (n)) (m))) (m))).
Definition plus_to_minus : forall n : nat, forall m : nat, forall p : nat, ((((eq) (nat)) (n)) (((plus) (m)) (p))) -> (((eq) (nat)) (((minus) (n)) (m))) (p) := fun n : nat => fun m : nat => fun p : nat => fun eqp : (((eq) (nat)) (n)) (((plus) (m)) (p)) => ((((sym_eq) (nat)) (p)) (((minus) (n)) (m))) (((((eq_coerc) ((((eq) (nat)) (p)) (((minus) (((plus) (p)) (m))) (m)))) ((((eq) (nat)) (p)) (((minus) (n)) (m)))) (((minus_plus_m_m) (p)) (m))) (((((((rewrite_r) (nat)) (((plus) (m)) (p))) (fun Joker_ : nat => (((eq) Prop) ((((eq) (nat)) (p)) (((minus) (Joker_)) (m)))) ((((eq) (nat)) (p)) (((minus) (n)) (m))))) (((((((rewrite_l) (nat)) (n)) (fun Joker_ : nat => (((eq) Prop) ((((eq) (nat)) (p)) (((minus) (Joker_)) (m)))) ((((eq) (nat)) (p)) (((minus) (n)) (m))))) (((refl) Prop) ((((eq) (nat)) (p)) (((minus) (n)) (m))))) (((plus) (m)) (p))) (eqp))) (((plus) (p)) (m))) (((commutative_plus) (p)) (m)))).
Definition monotonic_le_minus_l : forall p : nat, forall q : nat, forall n : nat, (((le) (q)) (p)) -> ((le) (((minus) (q)) (n))) (((minus) (p)) (n)) := ((((nat_elim2) (fun Joker_ : nat => fun Joker0 : nat => forall n : nat, (((le) (Joker0)) (Joker_)) -> ((le) (((minus) (Joker0)) (n))) (((minus) (Joker_)) (n)))) (fun p : nat => fun q : nat => fun lePO : ((le) (p)) (O) => ((((le_n_O_elim) (p)) (lePO)) (fun Joker_ : nat => ((le) (((minus) (Joker_)) (q))) (((minus) (O)) (q)))) ((le_n) (((minus) (O)) (q))))) (fun p : nat => fun q : nat => (((sym_eq_minus) ((S) (p))) (fun y : (nat) -> nat => (((le) (O)) ((S) (p))) -> ((le) (((minus) (O)) (q))) ((y) (q)))) ((((((sym_eq_filter_nat_type_S) ((nat) -> nat)) (minus_body)) (p)) (fun y : (nat) -> nat => (((le) (O)) ((S) (p))) -> ((le) (((minus) (O)) (q))) ((y) (q)))) ((((sym_eq_minus_body_S) (p)) (fun y : (nat) -> nat => (((le) (O)) ((S) (p))) -> ((le) (((minus) (O)) (q))) ((y) (q)))) (((eq_plus_body_O) (fun y : (nat) -> nat => (((le) (O)) ((S) (p))) -> ((le) (((minus) (O)) (q))) ((y) (((((match_nat_type) (nat)) ((S) (p))) (fun q0 : nat => ((minus) (p)) (q0))) (q))))) (((((eq_filter_nat_type_O) ((nat) -> nat)) (plus_body)) (fun y : (nat) -> nat => (((le) (O)) ((S) (p))) -> ((le) (((minus) (O)) (q))) ((y) (((((match_nat_type) (nat)) ((S) (p))) (fun q0 : nat => ((minus) (p)) (q0))) (q))))) ((((eq_plus) (O)) (fun y : (nat) -> nat => (((le) (O)) ((S) (p))) -> ((le) (((minus) (O)) (q))) ((y) (((((match_nat_type) (nat)) ((S) (p))) (fun q0 : nat => ((minus) (p)) (q0))) (q))))) (((eq_minus_body_O) (fun y : (nat) -> nat => (((le) (O)) ((S) (p))) -> ((le) (((minus) (O)) (q))) (((plus) ((y) (((((match_nat_type) (nat)) ((S) (p))) (fun q0 : nat => ((minus) (p)) (q0))) (q)))) (((((match_nat_type) (nat)) ((S) (p))) (fun q0 : nat => ((minus) (p)) (q0))) (q))))) (((((eq_filter_nat_type_O) ((nat) -> nat)) (minus_body)) (fun y : (nat) -> nat => (((le) (O)) ((S) (p))) -> ((le) (((minus) (O)) (q))) (((plus) ((y) (((((match_nat_type) (nat)) ((S) (p))) (fun q0 : nat => ((minus) (p)) (q0))) (q)))) (((((match_nat_type) (nat)) ((S) (p))) (fun q0 : nat => ((minus) (p)) (q0))) (q))))) ((((eq_minus) (O)) (fun y : (nat) -> nat => (((le) (O)) ((S) (p))) -> ((le) (((minus) (O)) (q))) (((plus) ((y) (((((match_nat_type) (nat)) ((S) (p))) (fun q0 : nat => ((minus) (p)) (q0))) (q)))) (((((match_nat_type) (nat)) ((S) (p))) (fun q0 : nat => ((minus) (p)) (q0))) (q))))) (((eq_minus_body_O) (fun y : (nat) -> nat => (((le) (O)) ((S) (p))) -> ((le) (((minus) (O)) (q))) (((plus) (((minus) ((y) (q))) (((((match_nat_type) (nat)) ((S) (p))) (fun q0 : nat => ((minus) (p)) (q0))) (q)))) (((((match_nat_type) (nat)) ((S) (p))) (fun q0 : nat => ((minus) (p)) (q0))) (q))))) (((((eq_filter_nat_type_O) ((nat) -> nat)) (minus_body)) (fun y : (nat) -> nat => (((le) (O)) ((S) (p))) -> ((le) (((minus) (O)) (q))) (((plus) (((minus) ((y) (q))) (((((match_nat_type) (nat)) ((S) (p))) (fun q0 : nat => ((minus) (p)) (q0))) (q)))) (((((match_nat_type) (nat)) ((S) (p))) (fun q0 : nat => ((minus) (p)) (q0))) (q))))) ((((eq_minus) (O)) (fun y : (nat) -> nat => (((le) (O)) ((S) (p))) -> ((le) (((minus) (O)) (q))) (((plus) (((minus) ((y) (q))) (((((match_nat_type) (nat)) ((S) (p))) (fun q0 : nat => ((minus) (p)) (q0))) (q)))) (((((match_nat_type) (nat)) ((S) (p))) (fun q0 : nat => ((minus) (p)) (q0))) (q))))) (fun auto : ((le) (O)) ((S) (p)) => ((le_plus_minus_m_m) (((minus) (O)) (q))) (((((match_nat_type) (nat)) ((S) (p))) (fun q0 : nat => ((minus) (p)) (q0))) (q)))))))))))))))) (fun p : nat => fun q : nat => fun Hind : forall n0 : nat, (((le) (q)) (p)) -> ((le) (((minus) (q)) (n0))) (((minus) (p)) (n0)) => fun n : nat => ((((match_nat_prop) (fun Joker_ : nat => (((le) ((S) (q))) ((S) (p))) -> ((le) (((minus) ((S) (q))) (Joker_))) (((minus) ((S) (p))) (Joker_)))) ((((sym_eq_minus) ((S) (q))) (fun y : (nat) -> nat => (((le) ((S) (q))) ((S) (p))) -> ((le) ((y) (O))) (((minus) ((S) (p))) (O)))) ((((((sym_eq_filter_nat_type_S) ((nat) -> nat)) (minus_body)) (q)) (fun y : (nat) -> nat => (((le) ((S) (q))) ((S) (p))) -> ((le) ((y) (O))) (((minus) ((S) (p))) (O)))) ((((sym_eq_minus_body_S) (q)) (fun y : (nat) -> nat => (((le) ((S) (q))) ((S) (p))) -> ((le) ((y) (O))) (((minus) ((S) (p))) (O)))) ((((((sym_eq_match_nat_type_O) (nat)) ((S) (q))) (fun z : nat => ((minus) (q)) (z))) (fun y : nat => (((le) ((S) (q))) ((S) (p))) -> ((le) (y)) (((minus) ((S) (p))) (O)))) ((((sym_eq_minus) ((S) (p))) (fun y : (nat) -> nat => (((le) ((S) (q))) ((S) (p))) -> ((le) ((S) (q))) ((y) (O)))) ((((((sym_eq_filter_nat_type_S) ((nat) -> nat)) (minus_body)) (p)) (fun y : (nat) -> nat => (((le) ((S) (q))) ((S) (p))) -> ((le) ((S) (q))) ((y) (O)))) ((((sym_eq_minus_body_S) (p)) (fun y : (nat) -> nat => (((le) ((S) (q))) ((S) (p))) -> ((le) ((S) (q))) ((y) (O)))) ((((((sym_eq_match_nat_type_O) (nat)) ((S) (p))) (fun q0 : nat => ((minus) (p)) (q0))) (fun y : nat => (((le) ((S) (q))) ((S) (p))) -> ((le) ((S) (q))) (y))) (fun auto : ((le) ((S) (q))) ((S) (p)) => auto)))))))))) ((((sym_eq_minus) ((S) (q))) (fun y : (nat) -> nat => forall a : nat, (((le) ((S) (q))) ((S) (p))) -> ((le) ((y) ((S) (a)))) (((minus) ((S) (p))) ((S) (a))))) ((((((sym_eq_filter_nat_type_S) ((nat) -> nat)) (minus_body)) (q)) (fun y : (nat) -> nat => forall a : nat, (((le) ((S) (q))) ((S) (p))) -> ((le) ((y) ((S) (a)))) (((minus) ((S) (p))) ((S) (a))))) ((((sym_eq_minus_body_S) (q)) (fun y : (nat) -> nat => forall a : nat, (((le) ((S) (q))) ((S) (p))) -> ((le) ((y) ((S) (a)))) (((minus) ((S) (p))) ((S) (a))))) (fun a : nat => ((((((sym_eq_match_nat_type_S) (nat)) ((S) (q))) (fun z : nat => ((minus) (q)) (z))) (a)) (fun y : nat => (((le) ((S) (q))) ((S) (p))) -> ((le) (y)) (((minus) ((S) (p))) ((S) (a))))) ((((sym_eq_minus) ((S) (p))) (fun y : (nat) -> nat => (((le) ((S) (q))) ((S) (p))) -> ((le) (((minus) (q)) (a))) ((y) ((S) (a))))) ((((((sym_eq_filter_nat_type_S) ((nat) -> nat)) (minus_body)) (p)) (fun y : (nat) -> nat => (((le) ((S) (q))) ((S) (p))) -> ((le) (((minus) (q)) (a))) ((y) ((S) (a))))) ((((sym_eq_minus_body_S) (p)) (fun y : (nat) -> nat => (((le) ((S) (q))) ((S) (p))) -> ((le) (((minus) (q)) (a))) ((y) ((S) (a))))) (((((((sym_eq_match_nat_type_S) (nat)) ((S) (p))) (fun q0 : nat => ((minus) (p)) (q0))) (a)) (fun y : nat => (((le) ((S) (q))) ((S) (p))) -> ((le) (((minus) (q)) (a))) (y))) (fun leSS : ((le) ((S) (q))) ((S) (p)) => ((Hind) (a)) (((((eq_coerc) (((le) ((pred) ((S) (q)))) ((pred) ((S) (p))))) (((le) (q)) (p))) ((((monotonic_pred) ((S) (q))) ((S) (p))) (leSS))) (((((((rewrite_l) (nat)) (q)) (fun Joker_ : nat => (((eq) Prop) (((le) (Joker_)) ((pred) ((S) (p))))) (((le) (q)) (p)))) (((((((rewrite_l) (nat)) (p)) (fun Joker_ : nat => (((eq) Prop) (((le) (q)) (Joker_))) (((le) (q)) (p)))) (((refl) Prop) (((le) (q)) (p)))) ((pred) ((S) (p)))) ((pred_Sn) (p)))) ((pred) ((S) (q)))) ((pred_Sn) (q)))))))))))))) (n)).
Definition le_plus_to_minus : forall n : nat, forall m : nat, forall p : nat, (((le) (n)) (((plus) (p)) (m))) -> ((le) (((minus) (n)) (m))) (p) := fun n : nat => fun m : nat => fun p : nat => fun lep : ((le) (n)) (((plus) (p)) (m)) => ((((eq_coerc) (((le) (((minus) (n)) (m))) (((minus) (((plus) (p)) (m))) (m)))) (((le) (((minus) (n)) (m))) (p))) (((((monotonic_le_minus_l) (((plus) (p)) (m))) (n)) (m)) (lep))) (((((((rewrite_l) (nat)) (p)) (fun Joker_ : nat => (((eq) Prop) (((le) (((minus) (n)) (m))) (Joker_))) (((le) (((minus) (n)) (m))) (p)))) (((refl) Prop) (((le) (((minus) (n)) (m))) (p)))) (((minus) (((plus) (p)) (m))) (m))) (((minus_plus_m_m) (p)) (m))).
Definition monotonic_le_minus_r : forall p : nat, forall q : nat, forall n : nat, (((le) (q)) (p)) -> ((le) (((minus) (n)) (p))) (((minus) (n)) (q)) := fun p : nat => fun q : nat => fun n : nat => fun lepq : ((le) (q)) (p) => ((((le_plus_to_minus) (n)) (p)) (((minus) (n)) (q))) ((((((transitive_le) (n)) (((plus) (((minus) (n)) (q))) (q))) (((plus) (((minus) (n)) (q))) (p))) (((le_plus_minus_m_m) (n)) (q))) (((((monotonic_le_plus_r) (((minus) (n)) (q))) (q)) (p)) (lepq))).
Definition minus_le : forall x : nat, forall y : nat, ((le) (((minus) (x)) (y))) (x) := fun x : nat => fun y : nat => ((((eq_coerc) (((le) (((minus) (x)) (y))) (((minus) (((plus) (x)) (y))) (y)))) (((le) (((minus) (x)) (y))) (x))) (((((monotonic_le_minus_l) (((plus) (x)) (y))) (x)) (y)) (((le_plus_n_r) (y)) (x)))) (((((((rewrite_l) (nat)) (x)) (fun Joker_ : nat => (((eq) Prop) (((le) (((minus) (x)) (y))) (Joker_))) (((le) (((minus) (x)) (y))) (x)))) (((refl) Prop) (((le) (((minus) (x)) (y))) (x)))) (((minus) (((plus) (x)) (y))) (y))) (((minus_plus_m_m) (x)) (y))).
Definition not_eq_to_le_to_lt : forall n : nat, forall m : nat, ((Not) ((((eq) (nat)) (n)) (m))) -> (((le) (n)) (m)) -> ((lt) (n)) (m) := fun n : nat => fun m : nat => fun Hneq : (Not) ((((eq) (nat)) (n)) (m)) => fun Hle : ((le) (n)) (m) => ((((((match_Or_prop) (((lt) (n)) (m))) ((((eq) (nat)) (n)) (m))) (((lt) (n)) (m))) (fun auto : ((lt) (n)) (m) => auto)) (fun Heq : (((eq) (nat)) (n)) (m) => (((not_le_to_lt) (m)) (n)) (((((not_to_not) (((le) (m)) (n))) ((((eq) (nat)) (n)) (m))) (fun auto : ((le) (m)) (n) => ((((((rewrite_l) (nat)) (n)) (fun Joker_ : nat => (((eq) (nat)) (n)) (Joker_))) (((refl) (nat)) (n))) (m)) (Heq))) (Hneq)))) ((((le_to_or_lt_eq) (n)) (m)) (Hle)).
Definition eq_minus_O : forall n : nat, forall m : nat, (((le) (n)) (m)) -> (((eq) (nat)) (((minus) (n)) (m))) (O) := fun n : nat => fun m : nat => fun lenm : ((le) (n)) (m) => ((((le_n_O_elim) (((minus) (n)) (m))) (((((eq_coerc) (((le) (((minus) (n)) (m))) (((minus) (n)) (n)))) (((le) (((minus) (n)) (m))) (O))) (((((monotonic_le_minus_r) (m)) (n)) (n)) (lenm))) (((((((rewrite_l) (nat)) (O)) (fun Joker_ : nat => (((eq) Prop) (((le) (((minus) (n)) (m))) (Joker_))) (((le) (((minus) (n)) (m))) (O)))) (((refl) Prop) (((le) (((minus) (n)) (m))) (O)))) (((minus) (n)) (n))) ((minus_n_n) (n))))) (fun Joker_ : nat => (((eq) (nat)) (Joker_)) (O))) (((refl) (nat)) (O)).
Definition distributive_times_minus : (((distributive) (nat)) (times)) (minus) := fun a : nat => fun b : nat => fun c : nat => ((((((match_Or_prop) (((lt) (b)) (c))) ((Not) (((lt) (b)) (c)))) ((((eq) (nat)) (((times) (a)) (((minus) (b)) (c)))) (((minus) (((times) (a)) (b))) (((times) (a)) (c))))) (fun Hbc : ((lt) (b)) (c) => ((((((eq_ind_r) (nat)) (O)) (fun x : nat => (((eq) (nat)) (((times) (a)) (x))) (((minus) (((times) (a)) (b))) (((times) (a)) (c))))) (((((((eq_ind_r) (nat)) (O)) (fun x : nat => (((eq) (nat)) (((times) (a)) (O))) (x))) (((((((rewrite_l) (nat)) (O)) (fun Joker_ : nat => (((eq) (nat)) (Joker_)) (O))) (((refl) (nat)) (O))) (((times) (a)) (O))) ((times_n_O) (a)))) (((minus) (((times) (a)) (b))) (((times) (a)) (c)))) ((((eq_minus_O) (((times) (a)) (b))) (((times) (a)) (c))) (((((monotonic_le_times_r) (a)) (b)) (c)) ((((lt_to_le) (b)) (c)) (Hbc)))))) (((minus) (b)) (c))) ((((eq_minus_O) (b)) (c)) ((((lt_to_le) (b)) (c)) (Hbc))))) (fun Hbc : (Not) (((lt) (b)) (c)) => ((((sym_eq) (nat)) (((minus) (((times) (a)) (b))) (((times) (a)) (c)))) (((times) (a)) (((minus) (b)) (c)))) (((((eq_coerc) ((((eq) (nat)) (((minus) (((times) (a)) (b))) (((times) (a)) (c)))) (((times) (a)) (((minus) (b)) (c))))) ((((eq) (nat)) (((minus) (((times) (a)) (b))) (((times) (a)) (c)))) (((times) (a)) (((minus) (b)) (c))))) (((((plus_to_minus) (((times) (a)) (b))) (((times) (a)) (c))) (((times) (a)) (((minus) (b)) (c)))) (((((((eq_ind) (nat)) (((times) (a)) (((plus) (c)) (((minus) (b)) (c))))) (fun x_1 : nat => (((eq) (nat)) (((times) (a)) (b))) (x_1))) (((((((eq_f) (nat)) (nat)) ((times) (a))) (b)) (((plus) (c)) (((minus) (b)) (c)))) (((((eq_coerc) ((((eq) (nat)) (b)) (((plus) (((minus) (b)) (c))) (c)))) ((((eq) (nat)) (b)) (((plus) (c)) (((minus) (b)) (c))))) ((((plus_minus_m_m) (b)) (c)) ((((not_lt_to_le) (b)) (c)) (Hbc)))) (((((((rewrite_r) (nat)) (((plus) (c)) (((minus) (b)) (c)))) (fun Joker_ : nat => (((eq) Prop) ((((eq) (nat)) (b)) (Joker_))) ((((eq) (nat)) (b)) (((plus) (c)) (((minus) (b)) (c)))))) (((refl) Prop) ((((eq) (nat)) (b)) (((plus) (c)) (((minus) (b)) (c)))))) (((plus) (((minus) (b)) (c))) (c))) (((commutative_plus) (((minus) (b)) (c))) (c)))))) (((plus) (((times) (a)) (c))) (((times) (a)) (((minus) (b)) (c))))) ((((distributive_times_plus) (a)) (c)) (((minus) (b)) (c)))))) (((refl) Prop) ((((eq) (nat)) (((minus) (((times) (a)) (b))) (((times) (a)) (c)))) (((times) (a)) (((minus) (b)) (c)))))))) (((decidable_lt) (b)) (c)).
Definition minus_plus : forall n : nat, forall m : nat, forall p : nat, (((eq) (nat)) (((minus) (((minus) (n)) (m))) (p))) (((minus) (n)) (((plus) (m)) (p))) := fun n : nat => fun m : nat => fun p : nat => ((((((match_Or_prop) (((le) (((plus) (m)) (p))) (n))) ((Not) (((le) (((plus) (m)) (p))) (n)))) ((((eq) (nat)) (((minus) (((minus) (n)) (m))) (p))) (((minus) (n)) (((plus) (m)) (p))))) (fun Hlt : ((le) (((plus) (m)) (p))) (n) => ((((plus_to_minus) (((minus) (n)) (m))) (p)) (((minus) (n)) (((plus) (m)) (p)))) (((((plus_to_minus) (n)) (m)) (((plus) (p)) (((minus) (n)) (((plus) (m)) (p))))) (((((((eq_ind) (nat)) (((plus) (((plus) (m)) (p))) (((minus) (n)) (((plus) (m)) (p))))) (fun x_1 : nat => (((eq) (nat)) (n)) (x_1))) ((((((minus_to_plus) (n)) (((plus) (m)) (p))) (((minus) (n)) (((plus) (m)) (p)))) (Hlt)) (((refl) (nat)) (((minus) (n)) (((plus) (m)) (p)))))) (((plus) (m)) (((plus) (p)) (((minus) (n)) (((plus) (m)) (p)))))) ((((associative_plus) (m)) (p)) (((minus) (n)) (((plus) (m)) (p)))))))) (fun Hlt : (Not) (((le) (((plus) (m)) (p))) (n)) => ((((((eq_ind_r) (nat)) (O)) (fun x : nat => (((eq) (nat)) (x)) (((minus) (n)) (((plus) (m)) (p))))) (((((sym_eq) (nat)) (((minus) (n)) (((plus) (m)) (p)))) (O)) (((((eq_coerc) ((((eq) (nat)) (((minus) (n)) (((plus) (m)) (p)))) (O))) ((((eq) (nat)) (((minus) (n)) (((plus) (m)) (p)))) (O))) ((((eq_minus_O) (n)) (((plus) (m)) (p))) ((((((transitive_le) (n)) ((S) (n))) (((plus) (m)) (p))) ((le_n_Sn) (n))) ((((not_le_to_lt) (((plus) (m)) (p))) (n)) (Hlt))))) (((refl) Prop) ((((eq) (nat)) (((minus) (n)) (((plus) (m)) (p)))) (O)))))) (((minus) (((minus) (n)) (m))) (p))) ((((eq_minus_O) (((minus) (n)) (m))) (p)) (((((eq_coerc) (((le) (((minus) (n)) (m))) (((minus) (((plus) (p)) (m))) (m)))) (((le) (((minus) (n)) (m))) (p))) (((((monotonic_le_minus_l) (((plus) (p)) (m))) (n)) (m)) (((((eq_coerc) (((le) (n)) (((plus) (m)) (p)))) (((le) (n)) (((plus) (p)) (m)))) ((((((transitive_le) (n)) ((S) (n))) (((plus) (m)) (p))) ((le_n_Sn) (n))) ((((not_le_to_lt) (((plus) (m)) (p))) (n)) (Hlt)))) (((((((rewrite_r) (nat)) (((plus) (m)) (p))) (fun Joker_ : nat => (((eq) Prop) (((le) (n)) (((plus) (m)) (p)))) (((le) (n)) (Joker_)))) (((refl) Prop) (((le) (n)) (((plus) (m)) (p))))) (((plus) (p)) (m))) (((commutative_plus) (p)) (m)))))) (((((((rewrite_l) (nat)) (p)) (fun Joker_ : nat => (((eq) Prop) (((le) (((minus) (n)) (m))) (Joker_))) (((le) (((minus) (n)) (m))) (p)))) (((refl) Prop) (((le) (((minus) (n)) (m))) (p)))) (((minus) (((plus) (p)) (m))) (m))) (((minus_plus_m_m) (p)) (m))))))) (((decidable_le) (((plus) (m)) (p))) (n)).
Definition minus_minus : forall n : nat, forall m : nat, forall p : nat, (((le) (p)) (m)) -> (((le) (m)) (n)) -> (((eq) (nat)) (((plus) (p)) (((minus) (n)) (m)))) (((minus) (n)) (((minus) (m)) (p))) := fun n : nat => fun m : nat => fun p : nat => fun lepm : ((le) (p)) (m) => fun lemn : ((le) (m)) (n) => ((((sym_eq) (nat)) (((minus) (n)) (((minus) (m)) (p)))) (((plus) (p)) (((minus) (n)) (m)))) (((((plus_to_minus) (n)) (((minus) (m)) (p))) (((plus) (p)) (((minus) (n)) (m)))) (((((((eq_ind) (nat)) (((plus) (((plus) (((minus) (m)) (p))) (p))) (((minus) (n)) (m)))) (fun x_1 : nat => (((eq) (nat)) (n)) (x_1))) (((((((eq_ind) (nat)) (m)) (fun x_1 : nat => (((eq) (nat)) (n)) (((plus) (x_1)) (((minus) (n)) (m))))) (((((((eq_ind) (nat)) (((plus) (((minus) (n)) (m))) (m))) (fun x_1 : nat => (((eq) (nat)) (n)) (x_1))) (((((((eq_ind) (nat)) (n)) (fun x_1 : nat => (((eq) (nat)) (n)) (x_1))) (((refl) (nat)) (n))) (((plus) (((minus) (n)) (m))) (m))) ((((plus_minus_m_m) (n)) (m)) (lemn)))) (((plus) (m)) (((minus) (n)) (m)))) (((commutative_plus) (((minus) (n)) (m))) (m)))) (((plus) (((minus) (m)) (p))) (p))) ((((plus_minus_m_m) (m)) (p)) (lepm)))) (((plus) (((minus) (m)) (p))) (((plus) (p)) (((minus) (n)) (m))))) ((((associative_plus) (((minus) (m)) (p))) (p)) (((minus) (n)) (m))))).
Definition minus_minus_comm : forall a : nat, forall b : nat, forall c : nat, (((eq) (nat)) (((minus) (((minus) (a)) (b))) (c))) (((minus) (((minus) (a)) (c))) (b)) := fun a : nat => fun b : nat => fun c : nat => ((((le_to_le_to_eq) (((minus) (((minus) (a)) (b))) (c))) (((minus) (((minus) (a)) (c))) (b))) (((((eq_coerc) (((le) (((minus) (((minus) (a)) (b))) (c))) (((minus) (((plus) (((minus) (((minus) (a)) (c))) (b))) (c))) (c)))) (((le) (((minus) (((minus) (a)) (b))) (c))) (((minus) (((minus) (a)) (c))) (b)))) (((((monotonic_le_minus_l) (((plus) (((minus) (((minus) (a)) (c))) (b))) (c))) (((minus) (a)) (b))) (c)) (((((eq_coerc) (((le) (((minus) (a)) (b))) (((plus) (((minus) (((minus) (a)) (b))) (c))) (c)))) (((le) (((minus) (a)) (b))) (((plus) (((minus) (((minus) (a)) (c))) (b))) (c)))) (((le_plus_minus_m_m) (((minus) (a)) (b))) (c))) (((((((rewrite_r) (nat)) (((minus) (a)) (((plus) (b)) (c)))) (fun Joker_ : nat => (((eq) Prop) (((le) (((minus) (a)) (b))) (((plus) (Joker_)) (c)))) (((le) (((minus) (a)) (b))) (((plus) (((minus) (((minus) (a)) (c))) (b))) (c))))) (((((((rewrite_r) (nat)) (((plus) (c)) (((minus) (a)) (((plus) (b)) (c))))) (fun Joker_ : nat => (((eq) Prop) (((le) (((minus) (a)) (b))) (Joker_))) (((le) (((minus) (a)) (b))) (((plus) (((minus) (((minus) (a)) (c))) (b))) (c))))) (((((((rewrite_r) (nat)) (((plus) (c)) (((minus) (((minus) (a)) (c))) (b)))) (fun Joker_ : nat => (((eq) Prop) (((le) (((minus) (a)) (b))) (((plus) (c)) (((minus) (a)) (((plus) (b)) (c)))))) (((le) (((minus) (a)) (b))) (Joker_)))) (((((((rewrite_l) (nat)) (((minus) (((minus) (a)) (c))) (b))) (fun Joker_ : nat => (((eq) Prop) (((le) (((minus) (a)) (b))) (((plus) (c)) (Joker_)))) (((le) (((minus) (a)) (b))) (((plus) (c)) (((minus) (((minus) (a)) (c))) (b)))))) (((refl) Prop) (((le) (((minus) (a)) (b))) (((plus) (c)) (((minus) (((minus) (a)) (c))) (b)))))) (((minus) (a)) (((plus) (b)) (c)))) (((((((rewrite_l) (nat)) (((plus) (c)) (b))) (fun Joker_ : nat => (((eq) (nat)) (((minus) (((minus) (a)) (c))) (b))) (((minus) (a)) (Joker_)))) ((((minus_plus) (a)) (c)) (b))) (((plus) (b)) (c))) (((commutative_plus) (c)) (b))))) (((plus) (((minus) (((minus) (a)) (c))) (b))) (c))) (((commutative_plus) (((minus) (((minus) (a)) (c))) (b))) (c)))) (((plus) (((minus) (a)) (((plus) (b)) (c)))) (c))) (((commutative_plus) (((minus) (a)) (((plus) (b)) (c)))) (c)))) (((minus) (((minus) (a)) (b))) (c))) ((((minus_plus) (a)) (b)) (c)))))) (((((((rewrite_l) (nat)) (((minus) (((minus) (a)) (c))) (b))) (fun Joker_ : nat => (((eq) Prop) (((le) (((minus) (((minus) (a)) (b))) (c))) (Joker_))) (((le) (((minus) (((minus) (a)) (b))) (c))) (((minus) (((minus) (a)) (c))) (b))))) (((refl) Prop) (((le) (((minus) (((minus) (a)) (b))) (c))) (((minus) (((minus) (a)) (c))) (b))))) (((minus) (((plus) (((minus) (((minus) (a)) (c))) (b))) (c))) (c))) (((minus_plus_m_m) (((minus) (((minus) (a)) (c))) (b))) (c))))) (((((eq_coerc) (((le) (((minus) (((minus) (a)) (c))) (b))) (((minus) (((plus) (((minus) (((minus) (a)) (b))) (c))) (b))) (b)))) (((le) (((minus) (((minus) (a)) (c))) (b))) (((minus) (((minus) (a)) (b))) (c)))) (((((monotonic_le_minus_l) (((plus) (((minus) (((minus) (a)) (b))) (c))) (b))) (((minus) (a)) (c))) (b)) (((((eq_coerc) (((le) (((minus) (a)) (c))) (((plus) (((minus) (((minus) (a)) (c))) (b))) (b)))) (((le) (((minus) (a)) (c))) (((plus) (((minus) (((minus) (a)) (b))) (c))) (b)))) (((le_plus_minus_m_m) (((minus) (a)) (c))) (b))) (((((((rewrite_r) (nat)) (((minus) (a)) (((plus) (c)) (b)))) (fun Joker_ : nat => (((eq) Prop) (((le) (((minus) (a)) (c))) (((plus) (Joker_)) (b)))) (((le) (((minus) (a)) (c))) (((plus) (((minus) (((minus) (a)) (b))) (c))) (b))))) (((((((rewrite_r) (nat)) (((plus) (b)) (((minus) (a)) (((plus) (c)) (b))))) (fun Joker_ : nat => (((eq) Prop) (((le) (((minus) (a)) (c))) (Joker_))) (((le) (((minus) (a)) (c))) (((plus) (((minus) (((minus) (a)) (b))) (c))) (b))))) (((((((rewrite_r) (nat)) (((plus) (b)) (((minus) (((minus) (a)) (b))) (c)))) (fun Joker_ : nat => (((eq) Prop) (((le) (((minus) (a)) (c))) (((plus) (b)) (((minus) (a)) (((plus) (c)) (b)))))) (((le) (((minus) (a)) (c))) (Joker_)))) (((((((rewrite_l) (nat)) (((minus) (((minus) (a)) (b))) (c))) (fun Joker_ : nat => (((eq) Prop) (((le) (((minus) (a)) (c))) (((plus) (b)) (Joker_)))) (((le) (((minus) (a)) (c))) (((plus) (b)) (((minus) (((minus) (a)) (b))) (c)))))) (((refl) Prop) (((le) (((minus) (a)) (c))) (((plus) (b)) (((minus) (((minus) (a)) (b))) (c)))))) (((minus) (a)) (((plus) (c)) (b)))) (((((((rewrite_l) (nat)) (((plus) (b)) (c))) (fun Joker_ : nat => (((eq) (nat)) (((minus) (((minus) (a)) (b))) (c))) (((minus) (a)) (Joker_)))) ((((minus_plus) (a)) (b)) (c))) (((plus) (c)) (b))) (((commutative_plus) (b)) (c))))) (((plus) (((minus) (((minus) (a)) (b))) (c))) (b))) (((commutative_plus) (((minus) (((minus) (a)) (b))) (c))) (b)))) (((plus) (((minus) (a)) (((plus) (c)) (b)))) (b))) (((commutative_plus) (((minus) (a)) (((plus) (c)) (b)))) (b)))) (((minus) (((minus) (a)) (c))) (b))) ((((minus_plus) (a)) (c)) (b)))))) (((((((rewrite_l) (nat)) (((minus) (((minus) (a)) (b))) (c))) (fun Joker_ : nat => (((eq) Prop) (((le) (((minus) (((minus) (a)) (c))) (b))) (Joker_))) (((le) (((minus) (((minus) (a)) (c))) (b))) (((minus) (((minus) (a)) (b))) (c))))) (((refl) Prop) (((le) (((minus) (((minus) (a)) (c))) (b))) (((minus) (((minus) (a)) (b))) (c))))) (((minus) (((plus) (((minus) (((minus) (a)) (b))) (c))) (b))) (b))) (((minus_plus_m_m) (((minus) (((minus) (a)) (b))) (c))) (b)))).
Definition minus_le_minus_minus_comm : forall b : nat, forall c : nat, forall a : nat, (((le) (c)) (b)) -> (((eq) (nat)) (((minus) (a)) (((minus) (b)) (c)))) (((minus) (((plus) (a)) (c))) (b)) := fun b : nat => fun c : nat => fun a : nat => fun H : ((le) (c)) (b) => ((((((eq_ind_r) (nat)) (((plus) (((minus) (b)) (c))) (c))) (fun x : nat => (((eq) (nat)) (((minus) (a)) (((minus) (b)) (c)))) (((minus) (((plus) (a)) (c))) (x)))) (((((((rewrite_r) (nat)) (((plus) (c)) (a))) (fun Joker_ : nat => (((eq) (nat)) (((minus) (a)) (((minus) (b)) (c)))) (((minus) (Joker_)) (((plus) (((minus) (b)) (c))) (c))))) (((((((rewrite_r) (nat)) (((plus) (c)) (((minus) (b)) (c)))) (fun Joker_ : nat => (((eq) (nat)) (((minus) (a)) (((minus) (b)) (c)))) (((minus) (((plus) (c)) (a))) (Joker_)))) (((((((rewrite_l) (nat)) (((minus) (((minus) (((plus) (c)) (a))) (c))) (((minus) (b)) (c)))) (fun Joker_ : nat => (((eq) (nat)) (((minus) (a)) (((minus) (b)) (c)))) (Joker_))) (((((((rewrite_r) (nat)) (((minus) (((plus) (c)) (a))) (c))) (fun Joker_ : nat => (((eq) (nat)) (((minus) (Joker_)) (((minus) (b)) (c)))) (((minus) (((minus) (((plus) (c)) (a))) (c))) (((minus) (b)) (c))))) (((refl) (nat)) (((minus) (((minus) (((plus) (c)) (a))) (c))) (((minus) (b)) (c))))) (a)) (((((((rewrite_l) (nat)) (((plus) (a)) (c))) (fun Joker_ : nat => (((eq) (nat)) (a)) (((minus) (Joker_)) (c)))) (((minus_plus_m_m) (a)) (c))) (((plus) (c)) (a))) (((commutative_plus) (a)) (c))))) (((minus) (((plus) (c)) (a))) (((plus) (c)) (((minus) (b)) (c))))) ((((minus_plus) (((plus) (c)) (a))) (c)) (((minus) (b)) (c))))) (((plus) (((minus) (b)) (c))) (c))) (((commutative_plus) (((minus) (b)) (c))) (c)))) (((plus) (a)) (c))) (((commutative_plus) (a)) (c)))) (b)) ((((plus_minus_m_m) (b)) (c)) (H)).
Definition minus_plus_plus_l : forall x : nat, forall y : nat, forall h : nat, (((eq) (nat)) (((minus) (((plus) (x)) (h))) (((plus) (y)) (h)))) (((minus) (x)) (y)) := fun x : nat => fun y : nat => fun h : nat => ((((((rewrite_l) (nat)) (((minus) (((minus) (((plus) (x)) (h))) (y))) (h))) (fun Joker_ : nat => (((eq) (nat)) (Joker_)) (((minus) (x)) (y)))) (((((((rewrite_r) (nat)) (((minus) (x)) (y))) (fun Joker_ : nat => (((eq) (nat)) (Joker_)) (((minus) (x)) (y)))) (((refl) (nat)) (((minus) (x)) (y)))) (((minus) (((minus) (((plus) (x)) (h))) (y))) (h))) (((((((rewrite_r) (nat)) (((minus) (((plus) (x)) (h))) (h))) (fun Joker_ : nat => (((eq) (nat)) (((minus) (((minus) (((plus) (x)) (h))) (y))) (h))) (((minus) (Joker_)) (y)))) ((((minus_minus_comm) (((plus) (x)) (h))) (y)) (h))) (x)) (((minus_plus_m_m) (x)) (h))))) (((minus) (((plus) (x)) (h))) (((plus) (y)) (h)))) ((((minus_plus) (((plus) (x)) (h))) (y)) (h)).
Parameter eqb : (nat) -> (nat) -> bool.
Parameter eqb_body : (nat) -> (nat) -> bool.
Axiom eq_eqb : forall n : nat, (((leibniz) ((nat) -> bool)) ((eqb) (n))) ((((filter_nat_type) ((nat) -> bool)) (eqb_body)) (n)).
Definition sym_eq_eqb : forall n : nat, (((leibniz) ((nat) -> bool)) ((((filter_nat_type) ((nat) -> bool)) (eqb_body)) (n))) ((eqb) (n)) := fun n : nat => ((((sym_leibniz) ((nat) -> bool)) ((eqb) (n))) ((((filter_nat_type) ((nat) -> bool)) (eqb_body)) (n))) ((eq_eqb) (n)).
Axiom eq_eqb_body_O : (((leibniz) ((nat) -> bool)) ((eqb_body) (O))) (fun m : nat => ((((match_nat_type) (bool)) (true)) (fun q : nat => false)) (m)).
Definition sym_eq_eqb_body_O : (((leibniz) ((nat) -> bool)) (fun m : nat => ((((match_nat_type) (bool)) (true)) (fun q : nat => false)) (m))) ((eqb_body) (O)) := ((((sym_leibniz) ((nat) -> bool)) ((eqb_body) (O))) (fun m : nat => ((((match_nat_type) (bool)) (true)) (fun q : nat => false)) (m))) (eq_eqb_body_O).
Axiom eq_eqb_body_S : forall n : nat, (((leibniz) ((nat) -> bool)) ((eqb_body) ((S) (n)))) (fun m : nat => ((((match_nat_type) (bool)) (false)) (fun q : nat => ((eqb) (n)) (q))) (m)).
Definition sym_eq_eqb_body_S : forall n : nat, (((leibniz) ((nat) -> bool)) (fun m : nat => ((((match_nat_type) (bool)) (false)) (fun q : nat => ((eqb) (n)) (q))) (m))) ((eqb_body) ((S) (n))) := fun n : nat => ((((sym_leibniz) ((nat) -> bool)) ((eqb_body) ((S) (n)))) (fun m : nat => ((((match_nat_type) (bool)) (false)) (fun q : nat => ((eqb) (n)) (q))) (m))) ((eq_eqb_body_S) (n)).
Definition eqb_elim : forall n : nat, forall m : nat, forall P : (bool) -> Prop, (((((eq) (nat)) (n)) (m)) -> (P) (true)) -> (((Not) ((((eq) (nat)) (n)) (m))) -> (P) (false)) -> (P) (((eqb) (n)) (m)) := ((((nat_elim2) (fun Joker_ : nat => fun Joker0 : nat => forall P : (bool) -> Prop, (((((eq) (nat)) (Joker_)) (Joker0)) -> (P) (true)) -> (((Not) ((((eq) (nat)) (Joker_)) (Joker0))) -> (P) (false)) -> (P) (((eqb) (Joker_)) (Joker0)))) (fun n : nat => ((((match_nat_prop) (fun Joker_ : nat => forall P : (bool) -> Prop, (((((eq) (nat)) (O)) (Joker_)) -> (P) (true)) -> (((Not) ((((eq) (nat)) (O)) (Joker_))) -> (P) (false)) -> (P) (((eqb) (O)) (Joker_)))) ((((sym_eq_eqb) (O)) (fun y : (nat) -> bool => forall P : (bool) -> Prop, (((((eq) (nat)) (O)) (O)) -> (P) (true)) -> (((Not) ((((eq) (nat)) (O)) (O))) -> (P) (false)) -> (P) ((y) (O)))) (((((sym_eq_filter_nat_type_O) ((nat) -> bool)) (eqb_body)) (fun y : (nat) -> bool => forall P : (bool) -> Prop, (((((eq) (nat)) (O)) (O)) -> (P) (true)) -> (((Not) ((((eq) (nat)) (O)) (O))) -> (P) (false)) -> (P) ((y) (O)))) (((sym_eq_eqb_body_O) (fun y : (nat) -> bool => forall P : (bool) -> Prop, (((((eq) (nat)) (O)) (O)) -> (P) (true)) -> (((Not) ((((eq) (nat)) (O)) (O))) -> (P) (false)) -> (P) ((y) (O)))) ((((((sym_eq_match_nat_type_O) (bool)) (true)) (fun q : nat => false)) (fun y : bool => forall P : (bool) -> Prop, (((((eq) (nat)) (O)) (O)) -> (P) (true)) -> (((Not) ((((eq) (nat)) (O)) (O))) -> (P) (false)) -> (P) (y))) (fun P : (bool) -> Prop => fun auto : ((((eq) (nat)) (O)) (O)) -> (P) (true) => fun auto' : ((Not) ((((eq) (nat)) (O)) (O))) -> (P) (false) => (auto) (((refl) (nat)) (O)))))))) (fun auto : nat => (((sym_eq_eqb) (O)) (fun y : (nat) -> bool => forall P : (bool) -> Prop, (((((eq) (nat)) (O)) ((S) (auto))) -> (P) (true)) -> (((Not) ((((eq) (nat)) (O)) ((S) (auto)))) -> (P) (false)) -> (P) ((y) ((S) (auto))))) (((((sym_eq_filter_nat_type_O) ((nat) -> bool)) (eqb_body)) (fun y : (nat) -> bool => forall P : (bool) -> Prop, (((((eq) (nat)) (O)) ((S) (auto))) -> (P) (true)) -> (((Not) ((((eq) (nat)) (O)) ((S) (auto)))) -> (P) (false)) -> (P) ((y) ((S) (auto))))) (((sym_eq_eqb_body_O) (fun y : (nat) -> bool => forall P : (bool) -> Prop, (((((eq) (nat)) (O)) ((S) (auto))) -> (P) (true)) -> (((Not) ((((eq) (nat)) (O)) ((S) (auto)))) -> (P) (false)) -> (P) ((y) ((S) (auto))))) (((((((sym_eq_match_nat_type_S) (bool)) (true)) (fun q : nat => false)) (auto)) (fun y : bool => forall P : (bool) -> Prop, (((((eq) (nat)) (O)) ((S) (auto))) -> (P) (true)) -> (((Not) ((((eq) (nat)) (O)) ((S) (auto)))) -> (P) (false)) -> (P) (y))) (fun P : (bool) -> Prop => fun auto' : ((((eq) (nat)) (O)) ((S) (auto))) -> (P) (true) => fun auto'' : ((Not) ((((eq) (nat)) (O)) ((S) (auto)))) -> (P) (false) => (auto'') ((not_eq_O_S) (auto)))))))) (n))) (fun n : nat => (((sym_eq_eqb) ((S) (n))) (fun y : (nat) -> bool => forall P : (bool) -> Prop, (((((eq) (nat)) ((S) (n))) (O)) -> (P) (true)) -> (((Not) ((((eq) (nat)) ((S) (n))) (O))) -> (P) (false)) -> (P) ((y) (O)))) ((((((sym_eq_filter_nat_type_S) ((nat) -> bool)) (eqb_body)) (n)) (fun y : (nat) -> bool => forall P : (bool) -> Prop, (((((eq) (nat)) ((S) (n))) (O)) -> (P) (true)) -> (((Not) ((((eq) (nat)) ((S) (n))) (O))) -> (P) (false)) -> (P) ((y) (O)))) ((((sym_eq_eqb_body_S) (n)) (fun y : (nat) -> bool => forall P : (bool) -> Prop, (((((eq) (nat)) ((S) (n))) (O)) -> (P) (true)) -> (((Not) ((((eq) (nat)) ((S) (n))) (O))) -> (P) (false)) -> (P) ((y) (O)))) ((((((sym_eq_match_nat_type_O) (bool)) (false)) (fun q : nat => ((eqb) (n)) (q))) (fun y : bool => forall P : (bool) -> Prop, (((((eq) (nat)) ((S) (n))) (O)) -> (P) (true)) -> (((Not) ((((eq) (nat)) ((S) (n))) (O))) -> (P) (false)) -> (P) (y))) (fun P : (bool) -> Prop => fun auto : ((((eq) (nat)) ((S) (n))) (O)) -> (P) (true) => fun auto' : ((Not) ((((eq) (nat)) ((S) (n))) (O))) -> (P) (false) => (auto') (((((sym_not_eq) (nat)) (O)) ((S) (n))) ((not_eq_O_S) (n))))))))) (fun n : nat => fun m : nat => (((sym_eq_eqb) ((S) (n))) (fun y : (nat) -> bool => (forall P : (bool) -> Prop, (((((eq) (nat)) (n)) (m)) -> (P) (true)) -> (((Not) ((((eq) (nat)) (n)) (m))) -> (P) (false)) -> (P) (((eqb) (n)) (m))) -> forall P : (bool) -> Prop, (((((eq) (nat)) ((S) (n))) ((S) (m))) -> (P) (true)) -> (((Not) ((((eq) (nat)) ((S) (n))) ((S) (m)))) -> (P) (false)) -> (P) ((y) ((S) (m))))) ((((((sym_eq_filter_nat_type_S) ((nat) -> bool)) (eqb_body)) (n)) (fun y : (nat) -> bool => (forall P : (bool) -> Prop, (((((eq) (nat)) (n)) (m)) -> (P) (true)) -> (((Not) ((((eq) (nat)) (n)) (m))) -> (P) (false)) -> (P) (((eqb) (n)) (m))) -> forall P : (bool) -> Prop, (((((eq) (nat)) ((S) (n))) ((S) (m))) -> (P) (true)) -> (((Not) ((((eq) (nat)) ((S) (n))) ((S) (m)))) -> (P) (false)) -> (P) ((y) ((S) (m))))) ((((sym_eq_eqb_body_S) (n)) (fun y : (nat) -> bool => (forall P : (bool) -> Prop, (((((eq) (nat)) (n)) (m)) -> (P) (true)) -> (((Not) ((((eq) (nat)) (n)) (m))) -> (P) (false)) -> (P) (((eqb) (n)) (m))) -> forall P : (bool) -> Prop, (((((eq) (nat)) ((S) (n))) ((S) (m))) -> (P) (true)) -> (((Not) ((((eq) (nat)) ((S) (n))) ((S) (m)))) -> (P) (false)) -> (P) ((y) ((S) (m))))) (((((((sym_eq_match_nat_type_S) (bool)) (false)) (fun q : nat => ((eqb) (n)) (q))) (m)) (fun y : bool => (forall P : (bool) -> Prop, (((((eq) (nat)) (n)) (m)) -> (P) (true)) -> (((Not) ((((eq) (nat)) (n)) (m))) -> (P) (false)) -> (P) (((eqb) (n)) (m))) -> forall P : (bool) -> Prop, (((((eq) (nat)) ((S) (n))) ((S) (m))) -> (P) (true)) -> (((Not) ((((eq) (nat)) ((S) (n))) ((S) (m)))) -> (P) (false)) -> (P) (y))) (fun auto : forall P : (bool) -> Prop, (((((eq) (nat)) (n)) (m)) -> (P) (true)) -> (((Not) ((((eq) (nat)) (n)) (m))) -> (P) (false)) -> (P) (((eqb) (n)) (m)) => fun P : (bool) -> Prop => fun auto' : ((((eq) (nat)) ((S) (n))) ((S) (m))) -> (P) (true) => fun auto'' : ((Not) ((((eq) (nat)) ((S) (n))) ((S) (m)))) -> (P) (false) => (((auto) (P)) (fun auto''' : (((eq) (nat)) (n)) (m) => (auto') (((((((rewrite_l) (nat)) (n)) (fun Joker_ : nat => (((eq) (nat)) ((S) (n))) ((S) (Joker_)))) (((refl) (nat)) ((S) (n)))) (m)) (auto''')))) (fun auto''' : (Not) ((((eq) (nat)) (n)) (m)) => (auto'') ((((not_eq_S) (n)) (m)) (auto''')))))))).
Definition eqb_n_n : forall n : nat, (((eq) (bool)) (((eqb) (n)) (n))) (true) := fun n : nat => ((((nat_ind) (fun Jokerx_365 : nat => (((eq) (bool)) (((eqb) (Jokerx_365)) (Jokerx_365))) (true))) ((((sym_eq_eqb) (O)) (fun y : (nat) -> bool => (((eq) (bool)) ((y) (O))) (true))) (((((sym_eq_filter_nat_type_O) ((nat) -> bool)) (eqb_body)) (fun y : (nat) -> bool => (((eq) (bool)) ((y) (O))) (true))) (((sym_eq_eqb_body_O) (fun y : (nat) -> bool => (((eq) (bool)) ((y) (O))) (true))) ((((((sym_eq_match_nat_type_O) (bool)) (true)) (fun q : nat => false)) (fun y : bool => (((eq) (bool)) (y)) (true))) (((refl) (bool)) (true))))))) (fun x_366 : nat => (((sym_eq_eqb) ((S) (x_366))) (fun y : (nat) -> bool => ((((eq) (bool)) (((eqb) (x_366)) (x_366))) (true)) -> (((eq) (bool)) ((y) ((S) (x_366)))) (true))) ((((((sym_eq_filter_nat_type_S) ((nat) -> bool)) (eqb_body)) (x_366)) (fun y : (nat) -> bool => ((((eq) (bool)) (((eqb) (x_366)) (x_366))) (true)) -> (((eq) (bool)) ((y) ((S) (x_366)))) (true))) ((((sym_eq_eqb_body_S) (x_366)) (fun y : (nat) -> bool => ((((eq) (bool)) (((eqb) (x_366)) (x_366))) (true)) -> (((eq) (bool)) ((y) ((S) (x_366)))) (true))) (((((((sym_eq_match_nat_type_S) (bool)) (false)) (fun q : nat => ((eqb) (x_366)) (q))) (x_366)) (fun y : bool => ((((eq) (bool)) (((eqb) (x_366)) (x_366))) (true)) -> (((eq) (bool)) (y)) (true))) (fun Jokerx_368 : (((eq) (bool)) (((eqb) (x_366)) (x_366))) (true) => ((((((rewrite_r) (bool)) (true)) (fun Joker_ : bool => (((eq) (bool)) (Joker_)) (true))) (((refl) (bool)) (true))) (((eqb) (x_366)) (x_366))) (Jokerx_368))))))) (n).
Definition eqb_true_to_eq : forall n : nat, forall m : nat, ((((eq) (bool)) (((eqb) (n)) (m))) (true)) -> (((eq) (nat)) (n)) (m) := fun n : nat => fun m : nat => (((((eqb_elim) (n)) (m)) (fun Joker_ : bool => ((((eq) (bool)) (Joker_)) (true)) -> (((eq) (nat)) (n)) (m))) (fun auto : (((eq) (nat)) (n)) (m) => fun auto' : (((eq) (bool)) (true)) (true) => ((((((rewrite_l) (nat)) (n)) (fun Joker_ : nat => (((eq) (nat)) (n)) (Joker_))) (((refl) (nat)) (n))) (m)) (auto))) (fun Joker_ : (Not) ((((eq) (nat)) (n)) (m)) => fun abs : (((eq) (bool)) (false)) (true) => ((falsity) ((((eq) (nat)) (n)) (m))) ((((absurd) ((((eq) (bool)) (true)) (false))) (((((((rewrite_r) (bool)) (true)) (fun Joker_1 : bool => (((eq) (bool)) (true)) (Joker_1))) (((refl) (bool)) (true))) (false)) (abs))) (not_eq_true_false))).
Definition eqb_false_to_not_eq : forall n : nat, forall m : nat, ((((eq) (bool)) (((eqb) (n)) (m))) (false)) -> (Not) ((((eq) (nat)) (n)) (m)) := fun n : nat => fun m : nat => (((((eqb_elim) (n)) (m)) (fun Joker_ : bool => ((((eq) (bool)) (Joker_)) (false)) -> (Not) ((((eq) (nat)) (n)) (m)))) (fun auto : (((eq) (nat)) (n)) (m) => fun auto' : (((eq) (bool)) (true)) (false) => ((((not_to_not) ((((eq) (nat)) (n)) (m))) ((((eq) (bool)) (true)) (false))) (fun auto'' : (((eq) (nat)) (n)) (m) => ((((((rewrite_l) (bool)) (true)) (fun Joker_ : bool => (((eq) (bool)) (true)) (Joker_))) (((refl) (bool)) (true))) (false)) (auto'))) (not_eq_true_false))) (fun auto : (Not) ((((eq) (nat)) (n)) (m)) => fun auto' : (((eq) (bool)) (false)) (false) => auto).
Definition eq_to_eqb_true : forall n : nat, forall m : nat, ((((eq) (nat)) (n)) (m)) -> (((eq) (bool)) (((eqb) (n)) (m))) (true) := fun n : nat => fun m : nat => fun auto : (((eq) (nat)) (n)) (m) => ((((((rewrite_l) (nat)) (n)) (fun Joker_ : nat => (((eq) (bool)) (((eqb) (n)) (Joker_))) (true))) (((((((rewrite_r) (bool)) (true)) (fun Joker_ : bool => (((eq) (bool)) (Joker_)) (true))) (((refl) (bool)) (true))) (((eqb) (n)) (n))) ((eqb_n_n) (n)))) (m)) (auto).
Definition not_eq_to_eqb_false : forall n : nat, forall m : nat, ((Not) ((((eq) (nat)) (n)) (m))) -> (((eq) (bool)) (((eqb) (n)) (m))) (false) := fun n : nat => fun m : nat => fun noteq : (Not) ((((eq) (nat)) (n)) (m)) => (((((eqb_elim) (n)) (m)) (fun Joker_ : bool => (((eq) (bool)) (Joker_)) (false))) (fun Heq : (((eq) (nat)) (n)) (m) => ((falsity) ((((eq) (bool)) (true)) (false))) ((((absurd) ((((eq) (nat)) (n)) (m))) (((((((rewrite_l) (nat)) (n)) (fun Joker_ : nat => (((eq) (nat)) (n)) (Joker_))) (((refl) (nat)) (n))) (m)) (Heq))) (noteq)))) (fun auto : (Not) ((((eq) (nat)) (n)) (m)) => ((refl) (bool)) (false)).
Parameter leb : (nat) -> (nat) -> bool.
Parameter leb_body : (nat) -> (nat) -> bool.
Axiom eq_leb : forall n : nat, (((leibniz) ((nat) -> bool)) ((leb) (n))) ((((filter_nat_type) ((nat) -> bool)) (leb_body)) (n)).
Definition sym_eq_leb : forall n : nat, (((leibniz) ((nat) -> bool)) ((((filter_nat_type) ((nat) -> bool)) (leb_body)) (n))) ((leb) (n)) := fun n : nat => ((((sym_leibniz) ((nat) -> bool)) ((leb) (n))) ((((filter_nat_type) ((nat) -> bool)) (leb_body)) (n))) ((eq_leb) (n)).
Axiom eq_leb_body_O : (((leibniz) ((nat) -> bool)) ((leb_body) (O))) (fun m : nat => true).
Definition sym_eq_leb_body_O : (((leibniz) ((nat) -> bool)) (fun m : nat => true)) ((leb_body) (O)) := ((((sym_leibniz) ((nat) -> bool)) ((leb_body) (O))) (fun m : nat => true)) (eq_leb_body_O).
Axiom eq_leb_body_S : forall n : nat, (((leibniz) ((nat) -> bool)) ((leb_body) ((S) (n)))) (fun m : nat => ((((match_nat_type) (bool)) (false)) (fun q : nat => ((leb) (n)) (q))) (m)).
Definition sym_eq_leb_body_S : forall n : nat, (((leibniz) ((nat) -> bool)) (fun m : nat => ((((match_nat_type) (bool)) (false)) (fun q : nat => ((leb) (n)) (q))) (m))) ((leb_body) ((S) (n))) := fun n : nat => ((((sym_leibniz) ((nat) -> bool)) ((leb_body) ((S) (n)))) (fun m : nat => ((((match_nat_type) (bool)) (false)) (fun q : nat => ((leb) (n)) (q))) (m))) ((eq_leb_body_S) (n)).
Definition leb_elim : forall n : nat, forall m : nat, forall P : (bool) -> Prop, ((((le) (n)) (m)) -> (P) (true)) -> (((Not) (((le) (n)) (m))) -> (P) (false)) -> (P) (((leb) (n)) (m)) := ((((nat_elim2) (fun Joker_ : nat => fun Joker0 : nat => forall P : (bool) -> Prop, ((((le) (Joker_)) (Joker0)) -> (P) (true)) -> (((Not) (((le) (Joker_)) (Joker0))) -> (P) (false)) -> (P) (((leb) (Joker_)) (Joker0)))) (fun n : nat => (((sym_eq_leb) (O)) (fun y : (nat) -> bool => forall P : (bool) -> Prop, ((((le) (O)) (n)) -> (P) (true)) -> (((Not) (((le) (O)) (n))) -> (P) (false)) -> (P) ((y) (n)))) (((((sym_eq_filter_nat_type_O) ((nat) -> bool)) (leb_body)) (fun y : (nat) -> bool => forall P : (bool) -> Prop, ((((le) (O)) (n)) -> (P) (true)) -> (((Not) (((le) (O)) (n))) -> (P) (false)) -> (P) ((y) (n)))) (((sym_eq_leb_body_O) (fun y : (nat) -> bool => forall P : (bool) -> Prop, ((((le) (O)) (n)) -> (P) (true)) -> (((Not) (((le) (O)) (n))) -> (P) (false)) -> (P) ((y) (n)))) (fun P : (bool) -> Prop => fun auto : (((le) (O)) (n)) -> (P) (true) => fun auto' : ((Not) (((le) (O)) (n))) -> (P) (false) => (auto) ((le_O_n) (n))))))) (fun n : nat => (((sym_eq_leb) ((S) (n))) (fun y : (nat) -> bool => forall P : (bool) -> Prop, ((((le) ((S) (n))) (O)) -> (P) (true)) -> (((Not) (((le) ((S) (n))) (O))) -> (P) (false)) -> (P) ((y) (O)))) ((((((sym_eq_filter_nat_type_S) ((nat) -> bool)) (leb_body)) (n)) (fun y : (nat) -> bool => forall P : (bool) -> Prop, ((((le) ((S) (n))) (O)) -> (P) (true)) -> (((Not) (((le) ((S) (n))) (O))) -> (P) (false)) -> (P) ((y) (O)))) ((((sym_eq_leb_body_S) (n)) (fun y : (nat) -> bool => forall P : (bool) -> Prop, ((((le) ((S) (n))) (O)) -> (P) (true)) -> (((Not) (((le) ((S) (n))) (O))) -> (P) (false)) -> (P) ((y) (O)))) ((((((sym_eq_match_nat_type_O) (bool)) (false)) (fun q : nat => ((leb) (n)) (q))) (fun y : bool => forall P : (bool) -> Prop, ((((le) ((S) (n))) (O)) -> (P) (true)) -> (((Not) (((le) ((S) (n))) (O))) -> (P) (false)) -> (P) (y))) (fun P : (bool) -> Prop => fun auto : (((le) ((S) (n))) (O)) -> (P) (true) => fun auto' : ((Not) (((le) ((S) (n))) (O))) -> (P) (false) => (auto') ((not_le_Sn_O) (n)))))))) (fun n : nat => fun m : nat => (((sym_eq_leb) ((S) (n))) (fun y : (nat) -> bool => (forall P : (bool) -> Prop, ((((le) (n)) (m)) -> (P) (true)) -> (((Not) (((le) (n)) (m))) -> (P) (false)) -> (P) (((leb) (n)) (m))) -> forall P : (bool) -> Prop, ((((le) ((S) (n))) ((S) (m))) -> (P) (true)) -> (((Not) (((le) ((S) (n))) ((S) (m)))) -> (P) (false)) -> (P) ((y) ((S) (m))))) ((((((sym_eq_filter_nat_type_S) ((nat) -> bool)) (leb_body)) (n)) (fun y : (nat) -> bool => (forall P : (bool) -> Prop, ((((le) (n)) (m)) -> (P) (true)) -> (((Not) (((le) (n)) (m))) -> (P) (false)) -> (P) (((leb) (n)) (m))) -> forall P : (bool) -> Prop, ((((le) ((S) (n))) ((S) (m))) -> (P) (true)) -> (((Not) (((le) ((S) (n))) ((S) (m)))) -> (P) (false)) -> (P) ((y) ((S) (m))))) ((((sym_eq_leb_body_S) (n)) (fun y : (nat) -> bool => (forall P : (bool) -> Prop, ((((le) (n)) (m)) -> (P) (true)) -> (((Not) (((le) (n)) (m))) -> (P) (false)) -> (P) (((leb) (n)) (m))) -> forall P : (bool) -> Prop, ((((le) ((S) (n))) ((S) (m))) -> (P) (true)) -> (((Not) (((le) ((S) (n))) ((S) (m)))) -> (P) (false)) -> (P) ((y) ((S) (m))))) (((((((sym_eq_match_nat_type_S) (bool)) (false)) (fun q : nat => ((leb) (n)) (q))) (m)) (fun y : bool => (forall P : (bool) -> Prop, ((((le) (n)) (m)) -> (P) (true)) -> (((Not) (((le) (n)) (m))) -> (P) (false)) -> (P) (((leb) (n)) (m))) -> forall P : (bool) -> Prop, ((((le) ((S) (n))) ((S) (m))) -> (P) (true)) -> (((Not) (((le) ((S) (n))) ((S) (m)))) -> (P) (false)) -> (P) (y))) (fun Hind : forall P : (bool) -> Prop, ((((le) (n)) (m)) -> (P) (true)) -> (((Not) (((le) (n)) (m))) -> (P) (false)) -> (P) (((leb) (n)) (m)) => fun P : (bool) -> Prop => fun Pt : (((le) ((S) (n))) ((S) (m))) -> (P) (true) => fun Pf : ((Not) (((le) ((S) (n))) ((S) (m)))) -> (P) (false) => (((Hind) (P)) (fun lenm : ((le) (n)) (m) => (Pt) ((((le_S_S) (n)) (m)) (lenm)))) (fun nlenm : (Not) (((le) (n)) (m)) => (Pf) ((((not_le_to_not_le_S_S) (n)) (m)) (nlenm)))))))).
Definition leb_true_to_le : forall n : nat, forall m : nat, ((((eq) (bool)) (((leb) (n)) (m))) (true)) -> ((le) (n)) (m) := fun n : nat => fun m : nat => (((((leb_elim) (n)) (m)) (fun Joker_ : bool => ((((eq) (bool)) (Joker_)) (true)) -> ((le) (n)) (m))) (fun auto : ((le) (n)) (m) => fun auto' : (((eq) (bool)) (true)) (true) => auto)) (fun Joker_ : (Not) (((le) (n)) (m)) => fun abs : (((eq) (bool)) (false)) (true) => ((falsity) (((le) (n)) (m))) ((((absurd) ((((eq) (bool)) (true)) (false))) (((((((rewrite_r) (bool)) (true)) (fun Joker_1 : bool => (((eq) (bool)) (true)) (Joker_1))) (((refl) (bool)) (true))) (false)) (abs))) (not_eq_true_false))).
Definition le_to_leb_true : forall n : nat, forall m : nat, (((le) (n)) (m)) -> (((eq) (bool)) (((leb) (n)) (m))) (true) := fun n : nat => fun m : nat => (((((leb_elim) (n)) (m)) (fun Joker_ : bool => (((le) (n)) (m)) -> (((eq) (bool)) (Joker_)) (true))) (fun auto : ((le) (n)) (m) => fun auto' : ((le) (n)) (m) => ((refl) (bool)) (true))) (fun H : (Not) (((le) (n)) (m)) => fun H1 : ((le) (n)) (m) => ((falsity) ((((eq) (bool)) (false)) (true))) ((((absurd) (((le) (n)) (m))) (H1)) (H))).
Definition not_le_to_leb_false : forall n : nat, forall m : nat, ((Not) (((le) (n)) (m))) -> (((eq) (bool)) (((leb) (n)) (m))) (false) := fun n : nat => fun m : nat => (((((leb_elim) (n)) (m)) (fun Joker_ : bool => ((Not) (((le) (n)) (m))) -> (((eq) (bool)) (Joker_)) (false))) (fun H : ((le) (n)) (m) => fun H1 : (Not) (((le) (n)) (m)) => ((falsity) ((((eq) (bool)) (true)) (false))) ((((absurd) (((le) (n)) (m))) (H)) (H1)))) (fun auto : (Not) (((le) (n)) (m)) => fun auto' : (Not) (((le) (n)) (m)) => ((refl) (bool)) (false)).
Parameter mod_aux : (nat) -> (nat) -> (nat) -> nat.
Parameter mod_aux_body : (nat) -> (nat) -> (nat) -> nat.
Axiom eq_mod_aux : forall p : nat, (((leibniz) ((nat) -> (nat) -> nat)) ((mod_aux) (p))) ((((filter_nat_type) ((nat) -> (nat) -> nat)) (mod_aux_body)) (p)).
Definition sym_eq_mod_aux : forall p : nat, (((leibniz) ((nat) -> (nat) -> nat)) ((((filter_nat_type) ((nat) -> (nat) -> nat)) (mod_aux_body)) (p))) ((mod_aux) (p)) := fun p : nat => ((((sym_leibniz) ((nat) -> (nat) -> nat)) ((mod_aux) (p))) ((((filter_nat_type) ((nat) -> (nat) -> nat)) (mod_aux_body)) (p))) ((eq_mod_aux) (p)).
Axiom eq_mod_aux_body_O : (((leibniz) ((nat) -> (nat) -> nat)) ((mod_aux_body) (O))) (fun m : nat => fun n : nat => m).
Definition sym_eq_mod_aux_body_O : (((leibniz) ((nat) -> (nat) -> nat)) (fun m : nat => fun n : nat => m)) ((mod_aux_body) (O)) := ((((sym_leibniz) ((nat) -> (nat) -> nat)) ((mod_aux_body) (O))) (fun m : nat => fun n : nat => m)) (eq_mod_aux_body_O).
Axiom eq_mod_aux_body_S : forall p : nat, (((leibniz) ((nat) -> (nat) -> nat)) ((mod_aux_body) ((S) (p)))) (fun m : nat => fun n : nat => ((((match_bool_type) (nat)) (m)) ((((mod_aux) (p)) (((minus) (m)) ((S) (n)))) (n))) (((leb) (m)) (n))).
Definition sym_eq_mod_aux_body_S : forall p : nat, (((leibniz) ((nat) -> (nat) -> nat)) (fun m : nat => fun n : nat => ((((match_bool_type) (nat)) (m)) ((((mod_aux) (p)) (((minus) (m)) ((S) (n)))) (n))) (((leb) (m)) (n)))) ((mod_aux_body) ((S) (p))) := fun p : nat => ((((sym_leibniz) ((nat) -> (nat) -> nat)) ((mod_aux_body) ((S) (p)))) (fun m : nat => fun n : nat => ((((match_bool_type) (nat)) (m)) ((((mod_aux) (p)) (((minus) (m)) ((S) (n)))) (n))) (((leb) (m)) (n)))) ((eq_mod_aux_body_S) (p)).
Definition mod : (nat) -> (nat) -> nat := fun n : nat => fun m : nat => ((((match_nat_type) (nat)) (n)) (fun p : nat => (((mod_aux) (n)) (n)) (p))) (m).
Parameter div_aux : (nat) -> (nat) -> (nat) -> nat.
Parameter div_aux_body : (nat) -> (nat) -> (nat) -> nat.
Axiom eq_div_aux : forall p : nat, (((leibniz) ((nat) -> (nat) -> nat)) ((div_aux) (p))) ((((filter_nat_type) ((nat) -> (nat) -> nat)) (div_aux_body)) (p)).
Definition sym_eq_div_aux : forall p : nat, (((leibniz) ((nat) -> (nat) -> nat)) ((((filter_nat_type) ((nat) -> (nat) -> nat)) (div_aux_body)) (p))) ((div_aux) (p)) := fun p : nat => ((((sym_leibniz) ((nat) -> (nat) -> nat)) ((div_aux) (p))) ((((filter_nat_type) ((nat) -> (nat) -> nat)) (div_aux_body)) (p))) ((eq_div_aux) (p)).
Axiom eq_div_aux_body_O : (((leibniz) ((nat) -> (nat) -> nat)) ((div_aux_body) (O))) (fun m : nat => fun n : nat => O).
Definition sym_eq_div_aux_body_O : (((leibniz) ((nat) -> (nat) -> nat)) (fun m : nat => fun n : nat => O)) ((div_aux_body) (O)) := ((((sym_leibniz) ((nat) -> (nat) -> nat)) ((div_aux_body) (O))) (fun m : nat => fun n : nat => O)) (eq_div_aux_body_O).
Axiom eq_div_aux_body_S : forall p : nat, (((leibniz) ((nat) -> (nat) -> nat)) ((div_aux_body) ((S) (p)))) (fun m : nat => fun n : nat => ((((match_bool_type) (nat)) (O)) ((S) ((((div_aux) (p)) (((minus) (m)) ((S) (n)))) (n)))) (((leb) (m)) (n))).
Definition sym_eq_div_aux_body_S : forall p : nat, (((leibniz) ((nat) -> (nat) -> nat)) (fun m : nat => fun n : nat => ((((match_bool_type) (nat)) (O)) ((S) ((((div_aux) (p)) (((minus) (m)) ((S) (n)))) (n)))) (((leb) (m)) (n)))) ((div_aux_body) ((S) (p))) := fun p : nat => ((((sym_leibniz) ((nat) -> (nat) -> nat)) ((div_aux_body) ((S) (p)))) (fun m : nat => fun n : nat => ((((match_bool_type) (nat)) (O)) ((S) ((((div_aux) (p)) (((minus) (m)) ((S) (n)))) (n)))) (((leb) (m)) (n)))) ((eq_div_aux_body_S) (p)).
Definition div : (nat) -> (nat) -> nat := fun n : nat => fun m : nat => ((((match_nat_type) (nat)) ((S) (n))) (fun p : nat => (((div_aux) (n)) (n)) (p))) (m).
Definition le_mod_aux_m_m : forall p : nat, forall n : nat, forall m : nat, (((le) (n)) (p)) -> ((le) ((((mod_aux) (p)) (n)) (m))) (m) := fun p : nat => ((((nat_ind) (fun Jokerx_365 : nat => forall n : nat, forall m : nat, (((le) (n)) (Jokerx_365)) -> ((le) ((((mod_aux) (Jokerx_365)) (n)) (m))) (m))) (fun n : nat => fun m : nat => (((sym_eq_mod_aux) (O)) (fun y : (nat) -> (nat) -> nat => (((le) (n)) (O)) -> ((le) (((y) (n)) (m))) (m))) (((((sym_eq_filter_nat_type_O) ((nat) -> (nat) -> nat)) (mod_aux_body)) (fun y : (nat) -> (nat) -> nat => (((le) (n)) (O)) -> ((le) (((y) (n)) (m))) (m))) (((sym_eq_mod_aux_body_O) (fun y : (nat) -> (nat) -> nat => (((le) (n)) (O)) -> ((le) (((y) (n)) (m))) (m))) (fun lenO : ((le) (n)) (O) => ((((le_n_O_elim) (n)) (lenO)) (fun Joker_ : nat => ((le) (Joker_)) (m))) ((le_O_n) (m))))))) (fun q : nat => (((sym_eq_mod_aux) ((S) (q))) (fun y : (nat) -> (nat) -> nat => (forall n : nat, forall m : nat, (((le) (n)) (q)) -> ((le) ((((mod_aux) (q)) (n)) (m))) (m)) -> forall n : nat, forall m : nat, (((le) (n)) ((S) (q))) -> ((le) (((y) (n)) (m))) (m))) ((((((sym_eq_filter_nat_type_S) ((nat) -> (nat) -> nat)) (mod_aux_body)) (q)) (fun y : (nat) -> (nat) -> nat => (forall n : nat, forall m : nat, (((le) (n)) (q)) -> ((le) ((((mod_aux) (q)) (n)) (m))) (m)) -> forall n : nat, forall m : nat, (((le) (n)) ((S) (q))) -> ((le) (((y) (n)) (m))) (m))) ((((sym_eq_mod_aux_body_S) (q)) (fun y : (nat) -> (nat) -> nat => (forall n : nat, forall m : nat, (((le) (n)) (q)) -> ((le) ((((mod_aux) (q)) (n)) (m))) (m)) -> forall n : nat, forall m : nat, (((le) (n)) ((S) (q))) -> ((le) (((y) (n)) (m))) (m))) (fun Hind : forall n : nat, forall m : nat, (((le) (n)) (q)) -> ((le) ((((mod_aux) (q)) (n)) (m))) (m) => fun n : nat => fun m : nat => fun len : ((le) (n)) ((S) (q)) => (((((leb_elim) (n)) (m)) (fun Joker_ : bool => ((le) (((((match_bool_type) (nat)) (n)) ((((mod_aux) (q)) (((minus) (n)) ((S) (m)))) (m))) (Joker_))) (m))) ((((((sym_eq_match_bool_type_true) (nat)) (n)) ((((mod_aux) (q)) (((minus) (n)) ((S) (m)))) (m))) (fun y : nat => (((le) (n)) (m)) -> ((le) (y)) (m))) (fun auto : ((le) (n)) (m) => auto))) ((((((sym_eq_match_bool_type_false) (nat)) (n)) ((((mod_aux) (q)) (((minus) (n)) ((S) (m)))) (m))) (fun y : nat => ((Not) (((le) (n)) (m))) -> ((le) (y)) (m))) (fun notlenm : (Not) (((le) (n)) (m)) => (((Hind) (((minus) (n)) ((S) (m)))) (m)) (((((le_plus_to_minus) (n)) ((S) (m))) (q)) ((((((transitive_le) (n)) ((S) (q))) (((plus) (q)) ((S) (m)))) (len)) (((((eq_coerc) (((le) ((S) (q))) (((plus) ((S) (q))) (m)))) (((le) ((S) (q))) (((plus) (q)) ((S) (m))))) (((le_plus_n_r) (m)) ((S) (q)))) (((((((rewrite_l) (nat)) (((plus) (m)) ((S) (q)))) (fun Joker_ : nat => (((eq) Prop) (((le) ((S) (q))) (Joker_))) (((le) ((S) (q))) (((plus) (q)) ((S) (m)))))) (((((((rewrite_r) (nat)) (((plus) (q)) ((S) (m)))) (fun Joker_ : nat => (((eq) Prop) (((le) ((S) (q))) (Joker_))) (((le) ((S) (q))) (((plus) (q)) ((S) (m)))))) (((refl) Prop) (((le) ((S) (q))) (((plus) (q)) ((S) (m)))))) (((plus) (m)) ((S) (q)))) (((((((rewrite_l) (nat)) ((S) (((plus) (m)) (q)))) (fun Joker_ : nat => (((eq) (nat)) (Joker_)) (((plus) (q)) ((S) (m))))) (((((((rewrite_l) (nat)) (((plus) (q)) (m))) (fun Joker_ : nat => (((eq) (nat)) ((S) (Joker_))) (((plus) (q)) ((S) (m))))) (((plus_n_Sm) (q)) (m))) (((plus) (m)) (q))) (((commutative_plus) (q)) (m)))) (((plus) (m)) ((S) (q)))) (((plus_n_Sm) (m)) (q))))) (((plus) ((S) (q))) (m))) (((commutative_plus) (m)) ((S) (q)))))))))))))) (p).
Definition lt_mod_m_m : forall n : nat, forall m : nat, (((lt) (O)) (m)) -> ((lt) (((mod) (n)) (m))) (m) := fun n : nat => fun m : nat => ((((match_nat_prop) (fun Joker_ : nat => (((lt) (O)) (Joker_)) -> ((lt) (((mod) (n)) (Joker_))) (Joker_))) (fun abs : ((lt) (O)) (O) => ((falsity) (((lt) (((mod) (n)) (O))) (O))) ((((absurd) (((le) ((S) (O))) (O))) (abs)) ((not_le_Sn_O) (O))))) (fun p : nat => ((((((sym_eq_match_nat_type_S) (nat)) (n)) (fun q : nat => (((mod_aux) (n)) (n)) (q))) (p)) (fun y : nat => (((lt) (O)) ((S) (p))) -> ((lt) (y)) ((S) (p)))) (fun Joker_ : ((lt) (O)) ((S) (p)) => (((le_S_S) ((((mod_aux) (n)) (n)) (p))) (p)) (((((le_mod_aux_m_m) (n)) (n)) (p)) ((le_n) (n)))))) (m).
Definition div_aux_mod_aux : forall p : nat, forall n : nat, forall m : nat, (((eq) (nat)) (n)) (((plus) (((times) ((((div_aux) (p)) (n)) (m))) ((S) (m)))) ((((mod_aux) (p)) (n)) (m))) := fun p : nat => ((((nat_ind) (fun Jokerx_365 : nat => forall n : nat, forall m : nat, (((eq) (nat)) (n)) (((plus) (((times) ((((div_aux) (Jokerx_365)) (n)) (m))) ((S) (m)))) ((((mod_aux) (Jokerx_365)) (n)) (m))))) (fun n : nat => fun m : nat => (((sym_eq_div_aux) (O)) (fun y : (nat) -> (nat) -> nat => (((eq) (nat)) (n)) (((plus) (((times) (((y) (n)) (m))) ((S) (m)))) ((((mod_aux) (O)) (n)) (m))))) (((((sym_eq_filter_nat_type_O) ((nat) -> (nat) -> nat)) (div_aux_body)) (fun y : (nat) -> (nat) -> nat => (((eq) (nat)) (n)) (((plus) (((times) (((y) (n)) (m))) ((S) (m)))) ((((mod_aux) (O)) (n)) (m))))) (((sym_eq_div_aux_body_O) (fun y : (nat) -> (nat) -> nat => (((eq) (nat)) (n)) (((plus) (((times) (((y) (n)) (m))) ((S) (m)))) ((((mod_aux) (O)) (n)) (m))))) ((((((eq_match_nat_type_O) (nat)) (O)) (fun q : nat => ((((match_bool_type) (nat)) (O)) ((S) ((((div_aux) (q)) (((minus) (n)) ((S) (m)))) (m)))) (((leb) (n)) (m)))) (fun y : nat => (((eq) (nat)) (n)) (((plus) (((times) (y)) ((S) (m)))) ((((mod_aux) (O)) (n)) (m))))) ((((sym_eq_mod_aux) (O)) (fun y : (nat) -> (nat) -> nat => (((eq) (nat)) (n)) (((plus) (((times) (((fun m0 : nat => fun n0 : nat => ((((match_nat_type) (nat)) (O)) (fun q : nat => ((((match_bool_type) (nat)) (O)) ((S) ((((div_aux) (q)) (((minus) (m0)) ((S) (n0)))) (n0)))) (((leb) (m0)) (n0)))) (O)) (n)) (m))) ((S) (m)))) (((y) (n)) (m))))) (((((sym_eq_filter_nat_type_O) ((nat) -> (nat) -> nat)) (mod_aux_body)) (fun y : (nat) -> (nat) -> nat => (((eq) (nat)) (n)) (((plus) (((times) (((fun m0 : nat => fun n0 : nat => ((((match_nat_type) (nat)) (O)) (fun q : nat => ((((match_bool_type) (nat)) (O)) ((S) ((((div_aux) (q)) (((minus) (m0)) ((S) (n0)))) (n0)))) (((leb) (m0)) (n0)))) (O)) (n)) (m))) ((S) (m)))) (((y) (n)) (m))))) (((sym_eq_mod_aux_body_O) (fun y : (nat) -> (nat) -> nat => (((eq) (nat)) (n)) (((plus) (((times) (((fun m0 : nat => fun n0 : nat => ((((match_nat_type) (nat)) (O)) (fun q : nat => ((((match_bool_type) (nat)) (O)) ((S) ((((div_aux) (q)) (((minus) (m0)) ((S) (n0)))) (n0)))) (((leb) (m0)) (n0)))) (O)) (n)) (m))) ((S) (m)))) (((y) (n)) (m))))) ((((((sym_eq_match_nat_type_O) (nat)) (O)) (fun q : nat => ((((match_bool_type) (nat)) (O)) ((S) ((((div_aux) (q)) (((minus) (n)) ((S) (m)))) (m)))) (((leb) (n)) (m)))) (fun y : nat => (((eq) (nat)) (n)) (((plus) (((times) (((fun m0 : nat => fun n0 : nat => y) (n)) (m))) ((S) (m)))) (n)))) ((((sym_eq_times) (O)) (fun y : (nat) -> nat => (((eq) (nat)) (n)) (((plus) ((y) ((S) (m)))) (n)))) (((((sym_eq_filter_nat_type_O) ((nat) -> nat)) (times_body)) (fun y : (nat) -> nat => (((eq) (nat)) (n)) (((plus) ((y) ((S) (m)))) (n)))) (((sym_eq_times_body_O) (fun y : (nat) -> nat => (((eq) (nat)) (n)) (((plus) ((y) ((S) (m)))) (n)))) ((((sym_eq_plus) (O)) (fun y : (nat) -> nat => (((eq) (nat)) (n)) ((y) (n)))) (((((sym_eq_filter_nat_type_O) ((nat) -> nat)) (plus_body)) (fun y : (nat) -> nat => (((eq) (nat)) (n)) ((y) (n)))) (((sym_eq_plus_body_O) (fun y : (nat) -> nat => (((eq) (nat)) (n)) ((y) (n)))) (((refl) (nat)) (n))))))))))))))))) (fun q : nat => (((sym_eq_div_aux) ((S) (q))) (fun y : (nat) -> (nat) -> nat => (forall n : nat, forall m : nat, (((eq) (nat)) (n)) (((plus) (((times) ((((div_aux) (q)) (n)) (m))) ((S) (m)))) ((((mod_aux) (q)) (n)) (m)))) -> forall n : nat, forall m : nat, (((eq) (nat)) (n)) (((plus) (((times) (((y) (n)) (m))) ((S) (m)))) ((((mod_aux) ((S) (q))) (n)) (m))))) ((((((sym_eq_filter_nat_type_S) ((nat) -> (nat) -> nat)) (div_aux_body)) (q)) (fun y : (nat) -> (nat) -> nat => (forall n : nat, forall m : nat, (((eq) (nat)) (n)) (((plus) (((times) ((((div_aux) (q)) (n)) (m))) ((S) (m)))) ((((mod_aux) (q)) (n)) (m)))) -> forall n : nat, forall m : nat, (((eq) (nat)) (n)) (((plus) (((times) (((y) (n)) (m))) ((S) (m)))) ((((mod_aux) ((S) (q))) (n)) (m))))) ((((sym_eq_div_aux_body_S) (q)) (fun y : (nat) -> (nat) -> nat => (forall n : nat, forall m : nat, (((eq) (nat)) (n)) (((plus) (((times) ((((div_aux) (q)) (n)) (m))) ((S) (m)))) ((((mod_aux) (q)) (n)) (m)))) -> forall n : nat, forall m : nat, (((eq) (nat)) (n)) (((plus) (((times) (((y) (n)) (m))) ((S) (m)))) ((((mod_aux) ((S) (q))) (n)) (m))))) (fun Hind : forall n : nat, forall m : nat, (((eq) (nat)) (n)) (((plus) (((times) ((((div_aux) (q)) (n)) (m))) ((S) (m)))) ((((mod_aux) (q)) (n)) (m))) => fun n : nat => fun m : nat => ((((((eq_match_nat_type_S) (nat)) (O)) (fun q0 : nat => ((((match_bool_type) (nat)) (O)) ((S) ((((div_aux) (q0)) (((minus) (n)) ((S) (m)))) (m)))) (((leb) (n)) (m)))) (q)) (fun y : nat => (((eq) (nat)) (n)) (((plus) (((times) (y)) ((S) (m)))) ((((mod_aux) ((S) (q))) (n)) (m))))) ((((sym_eq_mod_aux) ((S) (q))) (fun y : (nat) -> (nat) -> nat => (((eq) (nat)) (n)) (((plus) (((times) (((fun m0 : nat => fun n0 : nat => ((((match_nat_type) (nat)) (O)) (fun q0 : nat => ((((match_bool_type) (nat)) (O)) ((S) ((((div_aux) (q0)) (((minus) (m0)) ((S) (n0)))) (n0)))) (((leb) (m0)) (n0)))) ((S) (q))) (n)) (m))) ((S) (m)))) (((y) (n)) (m))))) ((((((sym_eq_filter_nat_type_S) ((nat) -> (nat) -> nat)) (mod_aux_body)) (q)) (fun y : (nat) -> (nat) -> nat => (((eq) (nat)) (n)) (((plus) (((times) (((fun m0 : nat => fun n0 : nat => ((((match_nat_type) (nat)) (O)) (fun q0 : nat => ((((match_bool_type) (nat)) (O)) ((S) ((((div_aux) (q0)) (((minus) (m0)) ((S) (n0)))) (n0)))) (((leb) (m0)) (n0)))) ((S) (q))) (n)) (m))) ((S) (m)))) (((y) (n)) (m))))) ((((sym_eq_mod_aux_body_S) (q)) (fun y : (nat) -> (nat) -> nat => (((eq) (nat)) (n)) (((plus) (((times) (((fun m0 : nat => fun n0 : nat => ((((match_nat_type) (nat)) (O)) (fun q0 : nat => ((((match_bool_type) (nat)) (O)) ((S) ((((div_aux) (q0)) (((minus) (m0)) ((S) (n0)))) (n0)))) (((leb) (m0)) (n0)))) ((S) (q))) (n)) (m))) ((S) (m)))) (((y) (n)) (m))))) (((((((sym_eq_match_nat_type_S) (nat)) (O)) (fun z : nat => ((((match_bool_type) (nat)) (O)) ((S) ((((div_aux) (z)) (((minus) (n)) ((S) (m)))) (m)))) (((leb) (n)) (m)))) (q)) (fun y : nat => (((eq) (nat)) (n)) (((plus) (((times) (y)) ((S) (m)))) (((((match_bool_type) (nat)) (n)) ((((mod_aux) (q)) (((minus) (n)) ((S) (m)))) (m))) (((leb) (n)) (m)))))) ((((((leb_elim) (n)) (m)) (fun Joker_ : bool => (((eq) (nat)) (n)) (((plus) (((times) (((((match_bool_type) (nat)) (O)) ((S) ((((div_aux) (q)) (((minus) (n)) ((S) (m)))) (m)))) (Joker_))) ((S) (m)))) (((((match_bool_type) (nat)) (n)) ((((mod_aux) (q)) (((minus) (n)) ((S) (m)))) (m))) (Joker_))))) ((((((sym_eq_match_bool_type_true) (nat)) (O)) ((S) ((((div_aux) (q)) (((minus) (n)) ((S) (m)))) (m)))) (fun x : nat => (((le) (n)) (m)) -> (((eq) (nat)) (n)) (((plus) (((times) (x)) ((S) (m)))) (((((match_bool_type) (nat)) (n)) ((((mod_aux) (q)) (((minus) (n)) ((S) (m)))) (m))) (true))))) ((((sym_eq_times) (O)) (fun y : (nat) -> nat => (((le) (n)) (m)) -> (((eq) (nat)) (n)) (((plus) ((y) ((S) (m)))) (((((match_bool_type) (nat)) (n)) ((((mod_aux) (q)) (((minus) (n)) ((S) (m)))) (m))) (true))))) (((((sym_eq_filter_nat_type_O) ((nat) -> nat)) (times_body)) (fun y : (nat) -> nat => (((le) (n)) (m)) -> (((eq) (nat)) (n)) (((plus) ((y) ((S) (m)))) (((((match_bool_type) (nat)) (n)) ((((mod_aux) (q)) (((minus) (n)) ((S) (m)))) (m))) (true))))) (((sym_eq_times_body_O) (fun y : (nat) -> nat => (((le) (n)) (m)) -> (((eq) (nat)) (n)) (((plus) ((y) ((S) (m)))) (((((match_bool_type) (nat)) (n)) ((((mod_aux) (q)) (((minus) (n)) ((S) (m)))) (m))) (true))))) ((((((sym_eq_match_bool_type_true) (nat)) (n)) ((((mod_aux) (q)) (((minus) (n)) ((S) (m)))) (m))) (fun y : nat => (((le) (n)) (m)) -> (((eq) (nat)) (n)) (((plus) (O)) (y)))) ((((sym_eq_plus) (O)) (fun y : (nat) -> nat => (((le) (n)) (m)) -> (((eq) (nat)) (n)) ((y) (n)))) (((((sym_eq_filter_nat_type_O) ((nat) -> nat)) (plus_body)) (fun y : (nat) -> nat => (((le) (n)) (m)) -> (((eq) (nat)) (n)) ((y) (n)))) (((sym_eq_plus_body_O) (fun y : (nat) -> nat => (((le) (n)) (m)) -> (((eq) (nat)) (n)) ((y) (n)))) (fun lenm : ((le) (n)) (m) => ((refl) (nat)) (n))))))))))) ((((((sym_eq_match_bool_type_false) (nat)) (n)) ((((mod_aux) (q)) (((minus) (n)) ((S) (m)))) (m))) (fun x : nat => ((Not) (((le) (n)) (m))) -> (((eq) (nat)) (n)) (((plus) (((times) (((((match_bool_type) (nat)) (O)) ((S) ((((div_aux) (q)) (((minus) (n)) ((S) (m)))) (m)))) (false))) ((S) (m)))) (x)))) ((((((sym_eq_match_bool_type_false) (nat)) (O)) ((S) ((((div_aux) (q)) (((minus) (n)) ((S) (m)))) (m)))) (fun y : nat => ((Not) (((le) (n)) (m))) -> (((eq) (nat)) (n)) (((plus) (((times) (y)) ((S) (m)))) ((((mod_aux) (q)) (((minus) (n)) ((S) (m)))) (m))))) ((((sym_eq_times) ((S) ((((div_aux) (q)) (((minus) (n)) ((S) (m)))) (m)))) (fun y : (nat) -> nat => ((Not) (((le) (n)) (m))) -> (((eq) (nat)) (n)) (((plus) ((y) ((S) (m)))) ((((mod_aux) (q)) (((minus) (n)) ((S) (m)))) (m))))) ((((((sym_eq_filter_nat_type_S) ((nat) -> nat)) (times_body)) ((((div_aux) (q)) (((minus) (n)) ((S) (m)))) (m))) (fun y : (nat) -> nat => ((Not) (((le) (n)) (m))) -> (((eq) (nat)) (n)) (((plus) ((y) ((S) (m)))) ((((mod_aux) (q)) (((minus) (n)) ((S) (m)))) (m))))) ((((sym_eq_times_body_S) ((((div_aux) (q)) (((minus) (n)) ((S) (m)))) (m))) (fun y : (nat) -> nat => ((Not) (((le) (n)) (m))) -> (((eq) (nat)) (n)) (((plus) ((y) ((S) (m)))) ((((mod_aux) (q)) (((minus) (n)) ((S) (m)))) (m))))) ((((sym_eq_plus) ((S) (m))) (fun y : (nat) -> nat => ((Not) (((le) (n)) (m))) -> (((eq) (nat)) (n)) (((plus) ((y) (((times) ((((div_aux) (q)) (((minus) (n)) ((S) (m)))) (m))) ((S) (m))))) ((((mod_aux) (q)) (((minus) (n)) ((S) (m)))) (m))))) ((((((sym_eq_filter_nat_type_S) ((nat) -> nat)) (plus_body)) (m)) (fun y : (nat) -> nat => ((Not) (((le) (n)) (m))) -> (((eq) (nat)) (n)) (((plus) ((y) (((times) ((((div_aux) (q)) (((minus) (n)) ((S) (m)))) (m))) ((S) (m))))) ((((mod_aux) (q)) (((minus) (n)) ((S) (m)))) (m))))) ((((sym_eq_plus_body_S) (m)) (fun y : (nat) -> nat => ((Not) (((le) (n)) (m))) -> (((eq) (nat)) (n)) (((plus) ((y) (((times) ((((div_aux) (q)) (((minus) (n)) ((S) (m)))) (m))) ((S) (m))))) ((((mod_aux) (q)) (((minus) (n)) ((S) (m)))) (m))))) ((((sym_eq_plus) ((S) (((plus) (m)) (((times) ((((div_aux) (q)) (((minus) (n)) ((S) (m)))) (m))) ((S) (m)))))) (fun y : (nat) -> nat => ((Not) (((le) (n)) (m))) -> (((eq) (nat)) (n)) ((y) ((((mod_aux) (q)) (((minus) (n)) ((S) (m)))) (m))))) ((((((sym_eq_filter_nat_type_S) ((nat) -> nat)) (plus_body)) (((plus) (m)) (((times) ((((div_aux) (q)) (((minus) (n)) ((S) (m)))) (m))) ((S) (m))))) (fun y : (nat) -> nat => ((Not) (((le) (n)) (m))) -> (((eq) (nat)) (n)) ((y) ((((mod_aux) (q)) (((minus) (n)) ((S) (m)))) (m))))) ((((sym_eq_plus_body_S) (((plus) (m)) (((times) ((((div_aux) (q)) (((minus) (n)) ((S) (m)))) (m))) ((S) (m))))) (fun y : (nat) -> nat => ((Not) (((le) (n)) (m))) -> (((eq) (nat)) (n)) ((y) ((((mod_aux) (q)) (((minus) (n)) ((S) (m)))) (m))))) (fun lenm : (Not) (((le) (n)) (m)) => ((((((eq_ind_r) (nat)) (((plus) (m)) (((plus) (((times) ((((div_aux) (q)) (((minus) (n)) ((S) (m)))) (m))) ((S) (m)))) ((((mod_aux) (q)) (((minus) (n)) ((S) (m)))) (m))))) (fun x : nat => (((eq) (nat)) (n)) ((S) (x)))) (((((((eq_ind) (nat)) (((minus) (n)) ((S) (m)))) (fun x_1 : nat => (((eq) (nat)) (n)) ((S) (((plus) (m)) (x_1))))) (((((eq_coerc) ((((eq) (nat)) (n)) (((plus) (((minus) (n)) ((S) (m)))) ((S) (m))))) ((((eq) (nat)) (n)) ((S) (((plus) (m)) (((minus) (n)) ((S) (m))))))) ((((plus_minus_m_m) (n)) ((S) (m))) ((((not_le_to_lt) (n)) (m)) (lenm)))) (((((((rewrite_r) (nat)) ((pred) (((minus) (n)) (m)))) (fun Joker_ : nat => (((eq) Prop) ((((eq) (nat)) (n)) (((plus) (Joker_)) ((S) (m))))) ((((eq) (nat)) (n)) ((S) (((plus) (m)) (((minus) (n)) ((S) (m)))))))) (((((((rewrite_r) (nat)) ((pred) (((minus) (n)) (m)))) (fun Joker_ : nat => (((eq) Prop) ((((eq) (nat)) (n)) (((plus) ((pred) (((minus) (n)) (m)))) ((S) (m))))) ((((eq) (nat)) (n)) ((S) (((plus) (m)) (Joker_)))))) (((((((rewrite_r) (nat)) (((plus) (m)) ((S) ((pred) (((minus) (n)) (m)))))) (fun Joker_ : nat => (((eq) Prop) ((((eq) (nat)) (n)) (((plus) ((pred) (((minus) (n)) (m)))) ((S) (m))))) ((((eq) (nat)) (n)) (Joker_)))) (((((((rewrite_r) (nat)) (((plus) (m)) ((S) ((pred) (((minus) (n)) (m)))))) (fun Joker_ : nat => (((eq) Prop) ((((eq) (nat)) (n)) (Joker_))) ((((eq) (nat)) (n)) (((plus) (m)) ((S) ((pred) (((minus) (n)) (m)))))))) (((refl) Prop) ((((eq) (nat)) (n)) (((plus) (m)) ((S) ((pred) (((minus) (n)) (m)))))))) (((plus) ((pred) (((minus) (n)) (m)))) ((S) (m)))) (((((((rewrite_l) (nat)) ((S) (((plus) ((pred) (((minus) (n)) (m)))) (m)))) (fun Joker_ : nat => (((eq) (nat)) (Joker_)) (((plus) (m)) ((S) ((pred) (((minus) (n)) (m))))))) (((((((rewrite_l) (nat)) (((plus) (m)) ((pred) (((minus) (n)) (m))))) (fun Joker_ : nat => (((eq) (nat)) ((S) (Joker_))) (((plus) (m)) ((S) ((pred) (((minus) (n)) (m))))))) (((plus_n_Sm) (m)) ((pred) (((minus) (n)) (m))))) (((plus) ((pred) (((minus) (n)) (m)))) (m))) (((commutative_plus) (m)) ((pred) (((minus) (n)) (m)))))) (((plus) ((pred) (((minus) (n)) (m)))) ((S) (m)))) (((plus_n_Sm) ((pred) (((minus) (n)) (m)))) (m))))) ((S) (((plus) (m)) ((pred) (((minus) (n)) (m)))))) (((plus_n_Sm) (m)) ((pred) (((minus) (n)) (m)))))) (((minus) (n)) ((S) (m)))) (((eq_minus_S_pred) (n)) (m)))) (((minus) (n)) ((S) (m)))) (((eq_minus_S_pred) (n)) (m))))) (((plus) (((times) ((((div_aux) (q)) (((minus) (n)) ((S) (m)))) (m))) ((S) (m)))) ((((mod_aux) (q)) (((minus) (n)) ((S) (m)))) (m)))) (((Hind) (((minus) (n)) ((S) (m)))) (m)))) (((plus) (((plus) (m)) (((times) ((((div_aux) (q)) (((minus) (n)) ((S) (m)))) (m))) ((S) (m))))) ((((mod_aux) (q)) (((minus) (n)) ((S) (m)))) (m)))) ((((associative_plus) (m)) (((times) ((((div_aux) (q)) (((minus) (n)) ((S) (m)))) (m))) ((S) (m)))) ((((mod_aux) (q)) (((minus) (n)) ((S) (m)))) (m))))))))))))))))))))))))) (p).
Definition div_mod : forall n : nat, forall m : nat, (((eq) (nat)) (n)) (((plus) (((times) (((div) (n)) (m))) (m))) (((mod) (n)) (m))) := fun n : nat => fun m : nat => ((((match_nat_prop) (fun Joker_ : nat => (((eq) (nat)) (n)) (((plus) (((times) (((div) (n)) (Joker_))) (Joker_))) (((mod) (n)) (Joker_))))) ((((sym_eq_times) (((div) (n)) (O))) (fun y : (nat) -> nat => (((eq) (nat)) (n)) (((plus) ((y) (O))) (((mod) (n)) (O))))) ((((((sym_eq_match_nat_type_O) (nat)) ((S) (n))) (fun p : nat => (((div_aux) (n)) (n)) (p))) (fun y : nat => (((eq) (nat)) (n)) (((plus) (((((filter_nat_type) ((nat) -> nat)) (times_body)) (y)) (O))) (((((match_nat_type) (nat)) (n)) (fun p : nat => (((mod_aux) (n)) (n)) (p))) (O))))) ((((((sym_eq_filter_nat_type_S) ((nat) -> nat)) (times_body)) (n)) (fun y : (nat) -> nat => (((eq) (nat)) (n)) (((plus) ((y) (O))) (((mod) (n)) (O))))) ((((sym_eq_times_body_S) (n)) (fun y : (nat) -> nat => (((eq) (nat)) (n)) (((plus) ((y) (O))) (((mod) (n)) (O))))) ((((((sym_eq_match_nat_type_O) (nat)) (n)) (fun p : nat => (((mod_aux) (n)) (n)) (p))) (fun y : nat => (((eq) (nat)) (n)) (((plus) (((plus) (O)) (((times) (n)) (O)))) (y)))) ((((sym_eq_plus) (O)) (fun y : (nat) -> nat => (((eq) (nat)) (n)) (((plus) ((y) (((times) (n)) (O)))) (n)))) (((((sym_eq_filter_nat_type_O) ((nat) -> nat)) (plus_body)) (fun y : (nat) -> nat => (((eq) (nat)) (n)) (((plus) ((y) (((times) (n)) (O)))) (n)))) (((sym_eq_plus_body_O) (fun y : (nat) -> nat => (((eq) (nat)) (n)) (((plus) ((y) (((times) (n)) (O)))) (n)))) (((((((rewrite_l) (nat)) (O)) (fun Joker_ : nat => (((eq) (nat)) (n)) (((plus) (Joker_)) (n)))) (((((((rewrite_r) (nat)) (((plus) (n)) (O))) (fun Joker_ : nat => (((eq) (nat)) (n)) (Joker_))) (((((((rewrite_l) (nat)) (n)) (fun Joker_ : nat => (((eq) (nat)) (n)) (Joker_))) (((refl) (nat)) (n))) (((plus) (n)) (O))) ((plus_n_O) (n)))) (((plus) (O)) (n))) (((commutative_plus) (O)) (n)))) (((times) (n)) (O))) ((times_n_O) (n)))))))))))) (fun auto : nat => ((((((sym_eq_match_nat_type_S) (nat)) ((S) (n))) (fun p : nat => (((div_aux) (n)) (n)) (p))) (auto)) (fun y : nat => (((eq) (nat)) (n)) (((plus) (((times) (y)) ((S) (auto)))) (((((match_nat_type) (nat)) (n)) (fun p : nat => (((mod_aux) (n)) (n)) (p))) ((S) (auto)))))) (((((((sym_eq_match_nat_type_S) (nat)) (n)) (fun p : nat => (((mod_aux) (n)) (n)) (p))) (auto)) (fun y : nat => (((eq) (nat)) (n)) (((plus) (((times) ((((div_aux) (n)) (n)) (auto))) ((S) (auto)))) (y)))) (((((((rewrite_r) (nat)) (((plus) (((times) ((((div_aux) (n)) (n)) (auto))) ((S) (auto)))) ((((mod_aux) (n)) (n)) (auto)))) (fun Joker_ : nat => (((eq) (nat)) (Joker_)) (((plus) (((times) ((((div_aux) (n)) (n)) (auto))) ((S) (auto)))) ((((mod_aux) (n)) (n)) (auto))))) (((refl) (nat)) (((plus) (((times) ((((div_aux) (n)) (n)) (auto))) ((S) (auto)))) ((((mod_aux) (n)) (n)) (auto))))) (n)) ((((div_aux_mod_aux) (n)) (n)) (auto)))))) (m).
Definition eq_times_div_minus_mod : forall a : nat, forall b : nat, (((eq) (nat)) (((times) (((div) (a)) (b))) (b))) (((minus) (a)) (((mod) (a)) (b))) := fun a : nat => fun b : nat => ((((eq_coerc) ((((eq) (nat)) (((times) (b)) (((div) (a)) (b)))) (((minus) (((plus) (((times) (b)) (((div) (a)) (b)))) (((mod) (a)) (b)))) (((mod) (a)) (b))))) ((((eq) (nat)) (((times) (((div) (a)) (b))) (b))) (((minus) (a)) (((mod) (a)) (b))))) (((minus_plus_m_m) (((times) (b)) (((div) (a)) (b)))) (((mod) (a)) (b)))) (((((((rewrite_r) (nat)) (((plus) (((mod) (a)) (b))) (((times) (b)) (((div) (a)) (b))))) (fun Joker_ : nat => (((eq) Prop) ((((eq) (nat)) (((times) (b)) (((div) (a)) (b)))) (((minus) (Joker_)) (((mod) (a)) (b))))) ((((eq) (nat)) (((times) (((div) (a)) (b))) (b))) (((minus) (a)) (((mod) (a)) (b)))))) (((((((rewrite_r) (nat)) (((times) (b)) (((div) (a)) (b)))) (fun Joker_ : nat => (((eq) Prop) ((((eq) (nat)) (((times) (b)) (((div) (a)) (b)))) (((minus) (((plus) (((mod) (a)) (b))) (((times) (b)) (((div) (a)) (b))))) (((mod) (a)) (b))))) ((((eq) (nat)) (Joker_)) (((minus) (a)) (((mod) (a)) (b)))))) (((((((rewrite_l) (nat)) (a)) (fun Joker_ : nat => (((eq) Prop) ((((eq) (nat)) (((times) (b)) (((div) (a)) (b)))) (((minus) (Joker_)) (((mod) (a)) (b))))) ((((eq) (nat)) (((times) (b)) (((div) (a)) (b)))) (((minus) (a)) (((mod) (a)) (b)))))) (((refl) Prop) ((((eq) (nat)) (((times) (b)) (((div) (a)) (b)))) (((minus) (a)) (((mod) (a)) (b)))))) (((plus) (((mod) (a)) (b))) (((times) (b)) (((div) (a)) (b))))) (((((((rewrite_l) (nat)) (((plus) (((times) (b)) (((div) (a)) (b)))) (((mod) (a)) (b)))) (fun Joker_ : nat => (((eq) (nat)) (a)) (Joker_))) (((((((rewrite_l) (nat)) (((times) (((div) (a)) (b))) (b))) (fun Joker_ : nat => (((eq) (nat)) (a)) (((plus) (Joker_)) (((mod) (a)) (b))))) (((div_mod) (a)) (b))) (((times) (b)) (((div) (a)) (b)))) (((commutative_times) (((div) (a)) (b))) (b)))) (((plus) (((mod) (a)) (b))) (((times) (b)) (((div) (a)) (b))))) (((commutative_plus) (((times) (b)) (((div) (a)) (b)))) (((mod) (a)) (b)))))) (((times) (((div) (a)) (b))) (b))) (((commutative_times) (((div) (a)) (b))) (b)))) (((plus) (((times) (b)) (((div) (a)) (b)))) (((mod) (a)) (b)))) (((commutative_plus) (((times) (b)) (((div) (a)) (b)))) (((mod) (a)) (b)))).
Parameter div_mod_spec : (nat) -> (nat) -> (nat) -> (nat) -> Prop.
Axiom div_mod_spec_intro : forall n : nat, forall m : nat, forall q : nat, forall r : nat, (((lt) (r)) (m)) -> ((((eq) (nat)) (n)) (((plus) (((times) (q)) (m))) (r))) -> ((((div_mod_spec) (n)) (m)) (q)) (r).
Axiom match_div_mod_spec_prop : forall n : nat, forall m : nat, forall q : nat, forall r : nat, forall return_ : Prop, ((((lt) (r)) (m)) -> ((((eq) (nat)) (n)) (((plus) (((times) (q)) (m))) (r))) -> return_) -> (((((div_mod_spec) (n)) (m)) (q)) (r)) -> return_.
Definition div_mod_spec_div_mod : forall n : nat, forall m : nat, (((lt) (O)) (m)) -> ((((div_mod_spec) (n)) (m)) (((div) (n)) (m))) (((mod) (n)) (m)) := fun n : nat => fun m : nat => fun posm : ((lt) (O)) (m) => ((((((div_mod_spec_intro) (n)) (m)) (((div) (n)) (m))) (((mod) (n)) (m))) ((((lt_mod_m_m) (n)) (m)) (posm))) (((((((rewrite_r) (nat)) (((times) (m)) (((div) (n)) (m)))) (fun Joker_ : nat => (((eq) (nat)) (n)) (((plus) (Joker_)) (((mod) (n)) (m))))) (((((((rewrite_r) (nat)) (((plus) (((mod) (n)) (m))) (((times) (m)) (((div) (n)) (m))))) (fun Joker_ : nat => (((eq) (nat)) (n)) (Joker_))) (((((((rewrite_l) (nat)) (n)) (fun Joker_ : nat => (((eq) (nat)) (n)) (Joker_))) (((refl) (nat)) (n))) (((plus) (((mod) (n)) (m))) (((times) (m)) (((div) (n)) (m))))) (((((((rewrite_l) (nat)) (((plus) (((times) (m)) (((div) (n)) (m)))) (((mod) (n)) (m)))) (fun Joker_ : nat => (((eq) (nat)) (n)) (Joker_))) (((((((rewrite_l) (nat)) (((times) (((div) (n)) (m))) (m))) (fun Joker_ : nat => (((eq) (nat)) (n)) (((plus) (Joker_)) (((mod) (n)) (m))))) (((div_mod) (n)) (m))) (((times) (m)) (((div) (n)) (m)))) (((commutative_times) (((div) (n)) (m))) (m)))) (((plus) (((mod) (n)) (m))) (((times) (m)) (((div) (n)) (m))))) (((commutative_plus) (((times) (m)) (((div) (n)) (m)))) (((mod) (n)) (m)))))) (((plus) (((times) (m)) (((div) (n)) (m)))) (((mod) (n)) (m)))) (((commutative_plus) (((times) (m)) (((div) (n)) (m)))) (((mod) (n)) (m))))) (((times) (((div) (n)) (m))) (m))) (((commutative_times) (((div) (n)) (m))) (m))).
Definition let_clause_1078 : forall a : nat, forall b : nat, forall q : nat, forall r : nat, forall q1 : nat, forall r1 : nat, (((((div_mod_spec) (a)) (b)) (q)) (r)) -> (((lt) (r)) (b)) -> ((((eq) (nat)) (a)) (((plus) (((times) (q)) (b))) (r))) -> (((((div_mod_spec) (a)) (b)) (q1)) (r1)) -> (((lt) (r1)) (b)) -> ((((eq) (nat)) (a)) (((plus) (((times) (q1)) (b))) (r1))) -> (((le) (q)) (q1)) -> (((lt) (q)) (q1)) -> (((eq) (nat)) (a)) (((plus) (r)) (((times) (b)) (q))) := fun a : nat => fun b : nat => fun q : nat => fun r : nat => fun q1 : nat => fun r1 : nat => fun Jokerclearme : ((((div_mod_spec) (a)) (b)) (q)) (r) => fun ltrb : ((lt) (r)) (b) => fun spec : (((eq) (nat)) (a)) (((plus) (((times) (q)) (b))) (r)) => fun Jokerclearme0 : ((((div_mod_spec) (a)) (b)) (q1)) (r1) => fun ltr1b : ((lt) (r1)) (b) => fun spec1 : (((eq) (nat)) (a)) (((plus) (((times) (q1)) (b))) (r1)) => fun leqq1 : ((le) (q)) (q1) => fun ltqq1 : ((lt) (q)) (q1) => ((((((rewrite_l) (nat)) (((plus) (((times) (b)) (q))) (r))) (fun Joker_ : nat => (((eq) (nat)) (a)) (Joker_))) (((((((rewrite_l) (nat)) (((times) (q)) (b))) (fun Joker_ : nat => (((eq) (nat)) (a)) (((plus) (Joker_)) (r)))) (spec)) (((times) (b)) (q))) (((commutative_times) (q)) (b)))) (((plus) (r)) (((times) (b)) (q)))) (((commutative_plus) (((times) (b)) (q))) (r)).
Definition let_clause_1062 : forall a : nat, forall b : nat, forall q : nat, forall r : nat, forall q1 : nat, forall r1 : nat, (((((div_mod_spec) (a)) (b)) (q)) (r)) -> (((lt) (r)) (b)) -> ((((eq) (nat)) (a)) (((plus) (((times) (q)) (b))) (r))) -> (((((div_mod_spec) (a)) (b)) (q1)) (r1)) -> (((lt) (r1)) (b)) -> ((((eq) (nat)) (a)) (((plus) (((times) (q1)) (b))) (r1))) -> ((Not) (((le) (q)) (q1))) -> (((eq) (nat)) (a)) (((plus) (r1)) (((times) (b)) (q1))) := fun a : nat => fun b : nat => fun q : nat => fun r : nat => fun q1 : nat => fun r1 : nat => fun Jokerclearme : ((((div_mod_spec) (a)) (b)) (q)) (r) => fun ltrb : ((lt) (r)) (b) => fun spec : (((eq) (nat)) (a)) (((plus) (((times) (q)) (b))) (r)) => fun Jokerclearme0 : ((((div_mod_spec) (a)) (b)) (q1)) (r1) => fun ltr1b : ((lt) (r1)) (b) => fun spec1 : (((eq) (nat)) (a)) (((plus) (((times) (q1)) (b))) (r1)) => fun leqq1 : (Not) (((le) (q)) (q1)) => ((((((rewrite_l) (nat)) (((plus) (((times) (b)) (q1))) (r1))) (fun Joker_ : nat => (((eq) (nat)) (a)) (Joker_))) (((((((rewrite_l) (nat)) (((times) (q1)) (b))) (fun Joker_ : nat => (((eq) (nat)) (a)) (((plus) (Joker_)) (r1)))) (spec1)) (((times) (b)) (q1))) (((commutative_times) (q1)) (b)))) (((plus) (r1)) (((times) (b)) (q1)))) (((commutative_plus) (((times) (b)) (q1))) (r1)).
Definition div_mod_spec_to_eq : forall a : nat, forall b : nat, forall q : nat, forall r : nat, forall q1 : nat, forall r1 : nat, (((((div_mod_spec) (a)) (b)) (q)) (r)) -> (((((div_mod_spec) (a)) (b)) (q1)) (r1)) -> (((eq) (nat)) (q)) (q1) := fun a : nat => fun b : nat => fun q : nat => fun r : nat => fun q1 : nat => fun r1 : nat => fun Jokerclearme : ((((div_mod_spec) (a)) (b)) (q)) (r) => (((((((match_div_mod_spec_prop) (a)) (b)) (q)) (r)) ((((((div_mod_spec) (a)) (b)) (q1)) (r1)) -> (((eq) (nat)) (q)) (q1))) (fun ltrb : ((lt) (r)) (b) => fun spec : (((eq) (nat)) (a)) (((plus) (((times) (q)) (b))) (r)) => fun Jokerclearme0 : ((((div_mod_spec) (a)) (b)) (q1)) (r1) => (((((((match_div_mod_spec_prop) (a)) (b)) (q1)) (r1)) ((((eq) (nat)) (q)) (q1))) (fun ltr1b : ((lt) (r1)) (b) => fun spec1 : (((eq) (nat)) (a)) (((plus) (((times) (q1)) (b))) (r1)) => (((((leb_elim) (q)) (q1)) (fun Joker_ : bool => (((eq) (nat)) (q)) (q1))) (fun leqq1 : ((le) (q)) (q1) => ((((((match_Or_prop) (((lt) (q)) (q1))) ((((eq) (nat)) (q)) (q1))) ((((eq) (nat)) (q)) (q1))) (fun ltqq1 : ((lt) (q)) (q1) => ((falsity) ((((eq) (nat)) (q)) (q1))) ((((absurd) (((le) ((S) (a))) (a))) ((((((lt_to_le_to_lt) (a)) (((times) ((S) (q))) (b))) (a)) (((((((eq_ind_r) (nat)) (((plus) (((times) (q)) (b))) (r))) (fun x : nat => ((lt) (x)) (((times) ((S) (q))) (b)))) (((((eq_coerc) (((lt) (((plus) (((times) (q)) (b))) (r))) (((plus) (((times) (q)) (b))) (b)))) (((lt) (((plus) (((times) (q)) (b))) (r))) (((times) ((S) (q))) (b)))) (((((monotonic_lt_plus_r) (((times) (q)) (b))) (r)) (b)) (ltrb))) (((((((rewrite_r) (nat)) (((times) (b)) (q))) (fun Joker_ : nat => (((eq) Prop) (((lt) (((plus) (Joker_)) (r))) (((plus) (Joker_)) (b)))) (((lt) (((plus) (Joker_)) (r))) (((times) ((S) (q))) (b))))) (((((((rewrite_r) (nat)) (((plus) (r)) (((times) (b)) (q)))) (fun Joker_ : nat => (((eq) Prop) (((lt) (((plus) (((times) (b)) (q))) (r))) (((plus) (((times) (b)) (q))) (b)))) (((lt) (Joker_)) (((times) ((S) (q))) (b))))) (((((((rewrite_l) (nat)) (a)) (fun Joker_ : nat => (((eq) Prop) (((lt) (((plus) (((times) (b)) (q))) (r))) (((plus) (((times) (b)) (q))) (b)))) (((lt) (Joker_)) (((times) ((S) (q))) (b))))) (((((((rewrite_r) (nat)) (((times) (b)) ((S) (q)))) (fun Joker_ : nat => (((eq) Prop) (((lt) (((plus) (((times) (b)) (q))) (r))) (((plus) (((times) (b)) (q))) (b)))) (((lt) (a)) (Joker_)))) (((((((rewrite_l) (nat)) (((plus) (b)) (((times) (b)) (q)))) (fun Joker_ : nat => (((eq) Prop) (((lt) (((plus) (((times) (b)) (q))) (r))) (((plus) (((times) (b)) (q))) (b)))) (((lt) (a)) (Joker_)))) (((((((rewrite_r) (nat)) (((plus) (r)) (((times) (b)) (q)))) (fun Joker_ : nat => (((eq) Prop) (((lt) (Joker_)) (((plus) (((times) (b)) (q))) (b)))) (((lt) (a)) (((plus) (b)) (((times) (b)) (q)))))) (((((((rewrite_l) (nat)) (a)) (fun Joker_ : nat => (((eq) Prop) (((lt) (Joker_)) (((plus) (((times) (b)) (q))) (b)))) (((lt) (a)) (((plus) (b)) (((times) (b)) (q)))))) (((((((rewrite_r) (nat)) (((plus) (b)) (((times) (b)) (q)))) (fun Joker_ : nat => (((eq) Prop) (((lt) (a)) (Joker_))) (((lt) (a)) (((plus) (b)) (((times) (b)) (q)))))) (((refl) Prop) (((lt) (a)) (((plus) (b)) (((times) (b)) (q)))))) (((plus) (((times) (b)) (q))) (b))) (((commutative_plus) (((times) (b)) (q))) (b)))) (((plus) (r)) (((times) (b)) (q)))) (((((((((((((((let_clause_1078) (a)) (b)) (q)) (r)) (q1)) (r1)) (Jokerclearme)) (ltrb)) (spec)) (Jokerclearme0)) (ltr1b)) (spec1)) (leqq1)) (ltqq1)))) (((plus) (((times) (b)) (q))) (r))) (((commutative_plus) (((times) (b)) (q))) (r)))) (((times) (b)) ((S) (q)))) (((times_n_Sm) (b)) (q)))) (((times) ((S) (q))) (b))) (((commutative_times) ((S) (q))) (b)))) (((plus) (r)) (((times) (b)) (q)))) (((((((((((((((let_clause_1078) (a)) (b)) (q)) (r)) (q1)) (r1)) (Jokerclearme)) (ltrb)) (spec)) (Jokerclearme0)) (ltr1b)) (spec1)) (leqq1)) (ltqq1)))) (((plus) (((times) (b)) (q))) (r))) (((commutative_plus) (((times) (b)) (q))) (r)))) (((times) (q)) (b))) (((commutative_times) (q)) (b))))) (a)) (spec))) ((((((transitive_le) (((times) ((S) (q))) (b))) (((times) (q1)) (b))) (a)) (((((eq_coerc) (((le) (((times) (b)) ((S) (q)))) (((times) (b)) (q1)))) (((le) (((times) ((S) (q))) (b))) (((times) (q1)) (b)))) (((((monotonic_le_times_r) (b)) ((S) (q))) (q1)) (ltqq1))) (((((((rewrite_r) (nat)) (((times) (b)) ((S) (q)))) (fun Joker_ : nat => (((eq) Prop) (((le) (((times) (b)) ((S) (q)))) (((times) (b)) (q1)))) (((le) (Joker_)) (((times) (q1)) (b))))) (((((((rewrite_l) (nat)) (((plus) (b)) (((times) (b)) (q)))) (fun Joker_ : nat => (((eq) Prop) (((le) (((times) (b)) ((S) (q)))) (((times) (b)) (q1)))) (((le) (Joker_)) (((times) (q1)) (b))))) (((((((rewrite_r) (nat)) (((times) (b)) (q1))) (fun Joker_ : nat => (((eq) Prop) (((le) (((times) (b)) ((S) (q)))) (((times) (b)) (q1)))) (((le) (((plus) (b)) (((times) (b)) (q)))) (Joker_)))) (((((((rewrite_l) (nat)) (((plus) (b)) (((times) (b)) (q)))) (fun Joker_ : nat => (((eq) Prop) (((le) (Joker_)) (((times) (b)) (q1)))) (((le) (((plus) (b)) (((times) (b)) (q)))) (((times) (b)) (q1))))) (((refl) Prop) (((le) (((plus) (b)) (((times) (b)) (q)))) (((times) (b)) (q1))))) (((times) (b)) ((S) (q)))) (((times_n_Sm) (b)) (q)))) (((times) (q1)) (b))) (((commutative_times) (q1)) (b)))) (((times) (b)) ((S) (q)))) (((times_n_Sm) (b)) (q)))) (((times) ((S) (q))) (b))) (((commutative_times) ((S) (q))) (b))))) (((((eq_coerc) (((le) (((times) (q1)) (b))) (((plus) (((times) (q1)) (b))) (r1)))) (((le) (((times) (q1)) (b))) (a))) (((le_plus_n_r) (r1)) (((times) (q1)) (b)))) (((((((rewrite_r) (nat)) (((times) (b)) (q1))) (fun Joker_ : nat => (((eq) Prop) (((le) (Joker_)) (((plus) (Joker_)) (r1)))) (((le) (Joker_)) (a)))) (((((((rewrite_r) (nat)) (((plus) (r1)) (((times) (b)) (q1)))) (fun Joker_ : nat => (((eq) Prop) (((le) (((times) (b)) (q1))) (Joker_))) (((le) (((times) (b)) (q1))) (a)))) (((((((rewrite_l) (nat)) (a)) (fun Joker_ : nat => (((eq) Prop) (((le) (((times) (b)) (q1))) (Joker_))) (((le) (((times) (b)) (q1))) (a)))) (((refl) Prop) (((le) (((times) (b)) (q1))) (a)))) (((plus) (r1)) (((times) (b)) (q1)))) (((((((rewrite_l) (nat)) (((plus) (((times) (b)) (q1))) (r1))) (fun Joker_ : nat => (((eq) (nat)) (a)) (Joker_))) (((((((rewrite_l) (nat)) (((times) (q1)) (b))) (fun Joker_ : nat => (((eq) (nat)) (a)) (((plus) (Joker_)) (r1)))) (spec1)) (((times) (b)) (q1))) (((commutative_times) (q1)) (b)))) (((plus) (r1)) (((times) (b)) (q1)))) (((commutative_plus) (((times) (b)) (q1))) (r1))))) (((plus) (((times) (b)) (q1))) (r1))) (((commutative_plus) (((times) (b)) (q1))) (r1)))) (((times) (q1)) (b))) (((commutative_times) (q1)) (b))))))) ((not_le_Sn_n) (a))))) (fun Jokerx_172 : (((eq) (nat)) (q)) (q1) => ((((((rewrite_l) (nat)) (q)) (fun Joker_ : nat => (((eq) (nat)) (q)) (Joker_))) (((refl) (nat)) (q))) (q1)) (Jokerx_172))) ((((le_to_or_lt_eq) (q)) (q1)) (leqq1)))) (fun leqq1 : (Not) (((le) (q)) (q1)) => ((falsity) ((((eq) (nat)) (q)) (q1))) ((((absurd) (((le) ((S) (a))) (a))) ((((((lt_to_le_to_lt) (a)) (((times) ((S) (q1))) (b))) (a)) (((((((eq_ind_r) (nat)) (((plus) (((times) (q1)) (b))) (r1))) (fun x : nat => ((lt) (x)) (((times) ((S) (q1))) (b)))) (((((eq_coerc) (((lt) (((plus) (((times) (q1)) (b))) (r1))) (((plus) (((times) (q1)) (b))) (b)))) (((lt) (((plus) (((times) (q1)) (b))) (r1))) (((times) ((S) (q1))) (b)))) (((((monotonic_lt_plus_r) (((times) (q1)) (b))) (r1)) (b)) (ltr1b))) (((((((rewrite_r) (nat)) (((times) (b)) (q1))) (fun Joker_ : nat => (((eq) Prop) (((lt) (((plus) (Joker_)) (r1))) (((plus) (Joker_)) (b)))) (((lt) (((plus) (Joker_)) (r1))) (((times) ((S) (q1))) (b))))) (((((((rewrite_r) (nat)) (((plus) (r1)) (((times) (b)) (q1)))) (fun Joker_ : nat => (((eq) Prop) (((lt) (((plus) (((times) (b)) (q1))) (r1))) (((plus) (((times) (b)) (q1))) (b)))) (((lt) (Joker_)) (((times) ((S) (q1))) (b))))) (((((((rewrite_l) (nat)) (a)) (fun Joker_ : nat => (((eq) Prop) (((lt) (((plus) (((times) (b)) (q1))) (r1))) (((plus) (((times) (b)) (q1))) (b)))) (((lt) (Joker_)) (((times) ((S) (q1))) (b))))) (((((((rewrite_r) (nat)) (((times) (b)) ((S) (q1)))) (fun Joker_ : nat => (((eq) Prop) (((lt) (((plus) (((times) (b)) (q1))) (r1))) (((plus) (((times) (b)) (q1))) (b)))) (((lt) (a)) (Joker_)))) (((((((rewrite_l) (nat)) (((plus) (b)) (((times) (b)) (q1)))) (fun Joker_ : nat => (((eq) Prop) (((lt) (((plus) (((times) (b)) (q1))) (r1))) (((plus) (((times) (b)) (q1))) (b)))) (((lt) (a)) (Joker_)))) (((((((rewrite_r) (nat)) (((plus) (r1)) (((times) (b)) (q1)))) (fun Joker_ : nat => (((eq) Prop) (((lt) (Joker_)) (((plus) (((times) (b)) (q1))) (b)))) (((lt) (a)) (((plus) (b)) (((times) (b)) (q1)))))) (((((((rewrite_l) (nat)) (a)) (fun Joker_ : nat => (((eq) Prop) (((lt) (Joker_)) (((plus) (((times) (b)) (q1))) (b)))) (((lt) (a)) (((plus) (b)) (((times) (b)) (q1)))))) (((((((rewrite_r) (nat)) (((plus) (b)) (((times) (b)) (q1)))) (fun Joker_ : nat => (((eq) Prop) (((lt) (a)) (Joker_))) (((lt) (a)) (((plus) (b)) (((times) (b)) (q1)))))) (((refl) Prop) (((lt) (a)) (((plus) (b)) (((times) (b)) (q1)))))) (((plus) (((times) (b)) (q1))) (b))) (((commutative_plus) (((times) (b)) (q1))) (b)))) (((plus) (r1)) (((times) (b)) (q1)))) ((((((((((((((let_clause_1062) (a)) (b)) (q)) (r)) (q1)) (r1)) (Jokerclearme)) (ltrb)) (spec)) (Jokerclearme0)) (ltr1b)) (spec1)) (leqq1)))) (((plus) (((times) (b)) (q1))) (r1))) (((commutative_plus) (((times) (b)) (q1))) (r1)))) (((times) (b)) ((S) (q1)))) (((times_n_Sm) (b)) (q1)))) (((times) ((S) (q1))) (b))) (((commutative_times) ((S) (q1))) (b)))) (((plus) (r1)) (((times) (b)) (q1)))) ((((((((((((((let_clause_1062) (a)) (b)) (q)) (r)) (q1)) (r1)) (Jokerclearme)) (ltrb)) (spec)) (Jokerclearme0)) (ltr1b)) (spec1)) (leqq1)))) (((plus) (((times) (b)) (q1))) (r1))) (((commutative_plus) (((times) (b)) (q1))) (r1)))) (((times) (q1)) (b))) (((commutative_times) (q1)) (b))))) (a)) (spec1))) ((((((transitive_le) (((times) ((S) (q1))) (b))) (((times) (q)) (b))) (a)) (((((eq_coerc) (((le) (((times) (b)) ((S) (q1)))) (((times) (b)) (q)))) (((le) (((times) ((S) (q1))) (b))) (((times) (q)) (b)))) (((((monotonic_le_times_r) (b)) ((S) (q1))) (q)) ((((not_le_to_lt) (q)) (q1)) (leqq1)))) (((((((rewrite_r) (nat)) (((times) (b)) ((S) (q1)))) (fun Joker_ : nat => (((eq) Prop) (((le) (((times) (b)) ((S) (q1)))) (((times) (b)) (q)))) (((le) (Joker_)) (((times) (q)) (b))))) (((((((rewrite_l) (nat)) (((plus) (b)) (((times) (b)) (q1)))) (fun Joker_ : nat => (((eq) Prop) (((le) (((times) (b)) ((S) (q1)))) (((times) (b)) (q)))) (((le) (Joker_)) (((times) (q)) (b))))) (((((((rewrite_r) (nat)) (((times) (b)) (q))) (fun Joker_ : nat => (((eq) Prop) (((le) (((times) (b)) ((S) (q1)))) (((times) (b)) (q)))) (((le) (((plus) (b)) (((times) (b)) (q1)))) (Joker_)))) (((((((rewrite_l) (nat)) (((plus) (b)) (((times) (b)) (q1)))) (fun Joker_ : nat => (((eq) Prop) (((le) (Joker_)) (((times) (b)) (q)))) (((le) (((plus) (b)) (((times) (b)) (q1)))) (((times) (b)) (q))))) (((refl) Prop) (((le) (((plus) (b)) (((times) (b)) (q1)))) (((times) (b)) (q))))) (((times) (b)) ((S) (q1)))) (((times_n_Sm) (b)) (q1)))) (((times) (q)) (b))) (((commutative_times) (q)) (b)))) (((times) (b)) ((S) (q1)))) (((times_n_Sm) (b)) (q1)))) (((times) ((S) (q1))) (b))) (((commutative_times) ((S) (q1))) (b))))) (((((eq_coerc) (((le) (((times) (q)) (b))) (((plus) (((times) (q)) (b))) (r)))) (((le) (((times) (q)) (b))) (a))) (((le_plus_n_r) (r)) (((times) (q)) (b)))) (((((((rewrite_r) (nat)) (((times) (b)) (q))) (fun Joker_ : nat => (((eq) Prop) (((le) (Joker_)) (((plus) (Joker_)) (r)))) (((le) (Joker_)) (a)))) (((((((rewrite_r) (nat)) (((plus) (r)) (((times) (b)) (q)))) (fun Joker_ : nat => (((eq) Prop) (((le) (((times) (b)) (q))) (Joker_))) (((le) (((times) (b)) (q))) (a)))) (((((((rewrite_l) (nat)) (a)) (fun Joker_ : nat => (((eq) Prop) (((le) (((times) (b)) (q))) (Joker_))) (((le) (((times) (b)) (q))) (a)))) (((refl) Prop) (((le) (((times) (b)) (q))) (a)))) (((plus) (r)) (((times) (b)) (q)))) (((((((rewrite_l) (nat)) (((plus) (((times) (b)) (q))) (r))) (fun Joker_ : nat => (((eq) (nat)) (a)) (Joker_))) (((((((rewrite_l) (nat)) (((times) (q)) (b))) (fun Joker_ : nat => (((eq) (nat)) (a)) (((plus) (Joker_)) (r)))) (spec)) (((times) (b)) (q))) (((commutative_times) (q)) (b)))) (((plus) (r)) (((times) (b)) (q)))) (((commutative_plus) (((times) (b)) (q))) (r))))) (((plus) (((times) (b)) (q))) (r))) (((commutative_plus) (((times) (b)) (q))) (r)))) (((times) (q)) (b))) (((commutative_times) (q)) (b))))))) ((not_le_Sn_n) (a)))))) (Jokerclearme0))) (Jokerclearme).
Definition div_mod_spec_to_eq2 : forall a : nat, forall b : nat, forall q : nat, forall r : nat, forall q1 : nat, forall r1 : nat, (((((div_mod_spec) (a)) (b)) (q)) (r)) -> (((((div_mod_spec) (a)) (b)) (q1)) (r1)) -> (((eq) (nat)) (r)) (r1) := fun a : nat => fun b : nat => fun q : nat => fun r : nat => fun q1 : nat => fun r1 : nat => fun spec : ((((div_mod_spec) (a)) (b)) (q)) (r) => fun spec1 : ((((div_mod_spec) (a)) (b)) (q1)) (r1) => (((((((match_div_mod_spec_prop) (a)) (b)) (q)) (r)) ((((eq) (nat)) (r)) (r1))) (fun Joker_ : ((lt) (r)) (b) => fun eqa : (((eq) (nat)) (a)) (((plus) (((times) (q)) (b))) (r)) => (((((((match_div_mod_spec_prop) (a)) (b)) (q1)) (r1)) ((((eq) (nat)) (r)) (r1))) (fun Joker0 : ((lt) (r1)) (b) => fun eqa1 : (((eq) (nat)) (a)) (((plus) (((times) (q1)) (b))) (r1)) => ((((injective_plus_r) (((times) (q)) (b))) (r)) (r1)) (((((((rewrite_r) (nat)) (((times) (b)) (q))) (fun Joker_1 : nat => (((eq) (nat)) (((plus) (Joker_1)) (r))) (((plus) (((times) (q)) (b))) (r1)))) (((((((rewrite_r) (nat)) (((plus) (r)) (((times) (b)) (q)))) (fun Joker_1 : nat => (((eq) (nat)) (Joker_1)) (((plus) (((times) (q)) (b))) (r1)))) (((((((rewrite_l) (nat)) (a)) (fun Joker_1 : nat => (((eq) (nat)) (Joker_1)) (((plus) (((times) (q)) (b))) (r1)))) (((((((rewrite_r) (nat)) (((times) (b)) (q))) (fun Joker_1 : nat => (((eq) (nat)) (a)) (((plus) (Joker_1)) (r1)))) (((((((rewrite_r) (nat)) (((plus) (r1)) (((times) (b)) (q)))) (fun Joker_1 : nat => (((eq) (nat)) (a)) (Joker_1))) (((((((rewrite_l) (nat)) (a)) (fun Joker_1 : nat => (((eq) (nat)) (a)) (Joker_1))) (((refl) (nat)) (a))) (((plus) (r1)) (((times) (b)) (q)))) (((((((rewrite_r) (nat)) (q1)) (fun Joker_1 : nat => (((eq) (nat)) (a)) (((plus) (r1)) (((times) (b)) (Joker_1))))) (((((((rewrite_l) (nat)) (((plus) (((times) (b)) (q1))) (r1))) (fun Joker_1 : nat => (((eq) (nat)) (a)) (Joker_1))) (((((((rewrite_l) (nat)) (((times) (q1)) (b))) (fun Joker_1 : nat => (((eq) (nat)) (a)) (((plus) (Joker_1)) (r1)))) (eqa1)) (((times) (b)) (q1))) (((commutative_times) (q1)) (b)))) (((plus) (r1)) (((times) (b)) (q1)))) (((commutative_plus) (((times) (b)) (q1))) (r1)))) (q)) (((((((((div_mod_spec_to_eq) (a)) (b)) (q)) (r)) (q1)) (r1)) (spec)) (spec1))))) (((plus) (((times) (b)) (q))) (r1))) (((commutative_plus) (((times) (b)) (q))) (r1)))) (((times) (q)) (b))) (((commutative_times) (q)) (b)))) (((plus) (r)) (((times) (b)) (q)))) (((((((rewrite_l) (nat)) (((plus) (((times) (b)) (q))) (r))) (fun Joker_1 : nat => (((eq) (nat)) (a)) (Joker_1))) (((((((rewrite_l) (nat)) (((times) (q)) (b))) (fun Joker_1 : nat => (((eq) (nat)) (a)) (((plus) (Joker_1)) (r)))) (eqa)) (((times) (b)) (q))) (((commutative_times) (q)) (b)))) (((plus) (r)) (((times) (b)) (q)))) (((commutative_plus) (((times) (b)) (q))) (r))))) (((plus) (((times) (b)) (q))) (r))) (((commutative_plus) (((times) (b)) (q))) (r)))) (((times) (q)) (b))) (((commutative_times) (q)) (b))))) (spec1))) (spec).
Definition div_times : forall a : nat, forall b : nat, (((lt) (O)) (b)) -> (((eq) (nat)) (((div) (((times) (a)) (b))) (b))) (a) := fun a : nat => fun b : nat => fun posb : ((lt) (O)) (b) => ((((((((div_mod_spec_to_eq) (((times) (a)) (b))) (b)) (((div) (((times) (a)) (b))) (b))) (((mod) (((times) (a)) (b))) (b))) (a)) (O)) ((((div_mod_spec_div_mod) (((times) (a)) (b))) (b)) (posb))) (((((((div_mod_spec_intro) (((times) (a)) (b))) (b)) (a)) (O)) (posb)) (((((((rewrite_r) (nat)) (((plus) (O)) (((times) (a)) (b)))) (fun Joker_ : nat => (((eq) (nat)) (((times) (a)) (b))) (Joker_))) (((((((rewrite_l) (nat)) (((times) (a)) (b))) (fun Joker_ : nat => (((eq) (nat)) (((times) (a)) (b))) (Joker_))) (((refl) (nat)) (((times) (a)) (b)))) (((plus) (O)) (((times) (a)) (b)))) ((plus_O_n) (((times) (a)) (b))))) (((plus) (((times) (a)) (b))) (O))) (((commutative_plus) (((times) (a)) (b))) (O)))).
Definition eq_div_O : forall n : nat, forall m : nat, (((lt) (n)) (m)) -> (((eq) (nat)) (((div) (n)) (m))) (O) := fun n : nat => fun m : nat => fun ltnm : ((lt) (n)) (m) => ((((((((div_mod_spec_to_eq) (n)) (m)) (((div) (n)) (m))) (((mod) (n)) (m))) (O)) (n)) ((((div_mod_spec_div_mod) (n)) (m)) ((((ltn_to_ltO) (n)) (m)) (ltnm)))) (((((((div_mod_spec_intro) (n)) (m)) (O)) (n)) (ltnm)) (((((((rewrite_r) (nat)) (((times) (m)) (O))) (fun Joker_ : nat => (((eq) (nat)) (n)) (((plus) (Joker_)) (n)))) (((((((rewrite_l) (nat)) (O)) (fun Joker_ : nat => (((eq) (nat)) (n)) (((plus) (Joker_)) (n)))) (((((((rewrite_r) (nat)) (((plus) (n)) (O))) (fun Joker_ : nat => (((eq) (nat)) (n)) (Joker_))) (((((((rewrite_l) (nat)) (n)) (fun Joker_ : nat => (((eq) (nat)) (n)) (Joker_))) (((refl) (nat)) (n))) (((plus) (n)) (O))) ((plus_n_O) (n)))) (((plus) (O)) (n))) (((commutative_plus) (O)) (n)))) (((times) (m)) (O))) ((times_n_O) (m)))) (((times) (O)) (m))) (((commutative_times) (O)) (m)))).
Definition mod_O_n : forall n : nat, (((eq) (nat)) (((mod) (O)) (n))) (O) := fun n : nat => ((((sym_eq) (nat)) (O)) (((mod) (O)) (n))) (((((eq_coerc) ((((eq) (nat)) (O)) (((mod) (O)) (n)))) ((((eq) (nat)) (O)) (((mod) (O)) (n)))) (((le_n_O_to_eq) (((mod) (O)) (n))) (((((eq_coerc) (((le) (((minus) (((plus) (((mod) (O)) (n))) (((times) (n)) (((div) (O)) (n))))) (((plus) (O)) (((times) (n)) (((div) (O)) (n)))))) (((plus) (((mod) (O)) (n))) (((times) (n)) (((div) (O)) (n)))))) (((le) (((mod) (O)) (n))) (O))) (((minus_le) (((plus) (((mod) (O)) (n))) (((times) (n)) (((div) (O)) (n))))) (((plus) (O)) (((times) (n)) (((div) (O)) (n)))))) (((((((rewrite_r) (nat)) (((minus) (((mod) (O)) (n))) (O))) (fun Joker_ : nat => (((eq) Prop) (((le) (Joker_)) (((plus) (((mod) (O)) (n))) (((times) (n)) (((div) (O)) (n)))))) (((le) (((mod) (O)) (n))) (O)))) (((((((rewrite_l) (nat)) (((mod) (O)) (n))) (fun Joker_ : nat => (((eq) Prop) (((le) (Joker_)) (((plus) (((mod) (O)) (n))) (((times) (n)) (((div) (O)) (n)))))) (((le) (((mod) (O)) (n))) (O)))) (((((((rewrite_l) (nat)) (O)) (fun Joker_ : nat => (((eq) Prop) (((le) (((mod) (O)) (n))) (Joker_))) (((le) (((mod) (O)) (n))) (O)))) (((refl) Prop) (((le) (((mod) (O)) (n))) (O)))) (((plus) (((mod) (O)) (n))) (((times) (n)) (((div) (O)) (n))))) (((((((rewrite_l) (nat)) (((plus) (((times) (n)) (((div) (O)) (n)))) (((mod) (O)) (n)))) (fun Joker_ : nat => (((eq) (nat)) (O)) (Joker_))) (((((((rewrite_l) (nat)) (((times) (((div) (O)) (n))) (n))) (fun Joker_ : nat => (((eq) (nat)) (O)) (((plus) (Joker_)) (((mod) (O)) (n))))) (((div_mod) (O)) (n))) (((times) (n)) (((div) (O)) (n)))) (((commutative_times) (((div) (O)) (n))) (n)))) (((plus) (((mod) (O)) (n))) (((times) (n)) (((div) (O)) (n))))) (((commutative_plus) (((times) (n)) (((div) (O)) (n)))) (((mod) (O)) (n)))))) (((minus) (((mod) (O)) (n))) (O))) ((minus_n_O) (((mod) (O)) (n))))) (((minus) (((plus) (((mod) (O)) (n))) (((times) (n)) (((div) (O)) (n))))) (((plus) (O)) (((times) (n)) (((div) (O)) (n)))))) ((((minus_plus_plus_l) (((mod) (O)) (n))) (O)) (((times) (n)) (((div) (O)) (n)))))))) (((refl) Prop) ((((eq) (nat)) (O)) (((mod) (O)) (n))))).
Definition sameF_upto : forall A : Type, (nat) -> ((nat) -> A) -> ((nat) -> A) -> Prop := fun A : Type => fun k : nat => fun f : (nat) -> A => fun g : (nat) -> A => forall i : nat, (((lt) (i)) (k)) -> (((eq) (A)) ((f) (i))) ((g) (i)).
Definition sameF_p : forall A : Type, (nat) -> ((nat) -> bool) -> ((nat) -> A) -> ((nat) -> A) -> Prop := fun A : Type => fun k : nat => fun p : (nat) -> bool => fun f : (nat) -> A => fun g : (nat) -> A => forall i : nat, (((lt) (i)) (k)) -> ((((eq) (bool)) ((p) (i))) (true)) -> (((eq) (A)) ((f) (i))) ((g) (i)).
Definition sameF_upto_le : forall A : Type, forall f : (nat) -> A, forall g : (nat) -> A, forall n : nat, forall m : nat, (((le) (n)) (m)) -> (((((sameF_upto) (A)) (m)) (f)) (g)) -> ((((sameF_upto) (A)) (n)) (f)) (g) := fun A : Type => fun f : (nat) -> A => fun g : (nat) -> A => fun n : nat => fun m : nat => fun lenm : ((le) (n)) (m) => fun samef : ((((sameF_upto) (A)) (m)) (f)) (g) => fun i : nat => fun ltin : ((lt) (i)) (n) => ((samef) (i)) ((((((lt_to_le_to_lt) (i)) (n)) (m)) (ltin)) (lenm)).
Definition sameF_p_le : forall A : Type, forall p : (nat) -> bool, forall f : (nat) -> A, forall g : (nat) -> A, forall n : nat, forall m : nat, (((le) (n)) (m)) -> ((((((sameF_p) (A)) (m)) (p)) (f)) (g)) -> (((((sameF_p) (A)) (n)) (p)) (f)) (g) := fun A : Type => fun p : (nat) -> bool => fun f : (nat) -> A => fun g : (nat) -> A => fun n : nat => fun m : nat => fun lenm : ((le) (n)) (m) => fun samef : (((((sameF_p) (A)) (m)) (p)) (f)) (g) => fun i : nat => fun ltin : ((lt) (i)) (n) => fun pi : (((eq) (bool)) ((p) (i))) (true) => (((samef) (i)) ((((((lt_to_le_to_lt) (i)) (n)) (m)) (ltin)) (lenm))) (((((((rewrite_r) (bool)) (true)) (fun Joker_ : bool => (((eq) (bool)) (Joker_)) (true))) (((refl) (bool)) (true))) ((p) (i))) (pi)).
Parameter bigop : forall H : Type, (nat) -> ((nat) -> bool) -> (H) -> ((H) -> (H) -> H) -> ((nat) -> H) -> H.
Parameter bigop_body : forall H : Type, (nat) -> ((nat) -> bool) -> (H) -> ((H) -> (H) -> H) -> ((nat) -> H) -> H.
Axiom eq_bigop_O : forall H : Type, (((leibniz) (((nat) -> bool) -> (H) -> ((H) -> (H) -> H) -> ((nat) -> H) -> H)) (((bigop) (H)) (O))) (((bigop_body) (H)) (O)).
Definition sym_eq_bigop_O : forall H : Type, (((leibniz) (((nat) -> bool) -> (H) -> ((H) -> (H) -> H) -> ((nat) -> H) -> H)) (((bigop_body) (H)) (O))) (((bigop) (H)) (O)) := fun H : Type => ((((sym_leibniz) (((nat) -> bool) -> (H) -> ((H) -> (H) -> H) -> ((nat) -> H) -> H)) (((bigop) (H)) (O))) (((bigop_body) (H)) (O))) ((eq_bigop_O) (H)).
Axiom eq_bigop_S : forall H : Type, forall n : nat, (((leibniz) (((nat) -> bool) -> (H) -> ((H) -> (H) -> H) -> ((nat) -> H) -> H)) (((bigop) (H)) ((S) (n)))) (((bigop_body) (H)) ((S) (n))).
Definition sym_eq_bigop_S : forall H : Type, forall n : nat, (((leibniz) (((nat) -> bool) -> (H) -> ((H) -> (H) -> H) -> ((nat) -> H) -> H)) (((bigop_body) (H)) ((S) (n)))) (((bigop) (H)) ((S) (n))) := fun H : Type => fun n : nat => ((((sym_leibniz) (((nat) -> bool) -> (H) -> ((H) -> (H) -> H) -> ((nat) -> H) -> H)) (((bigop) (H)) ((S) (n)))) (((bigop_body) (H)) ((S) (n)))) (((eq_bigop_S) (H)) (n)).
Axiom eq_bigop_body_O : forall H : Type, (((leibniz) (((nat) -> bool) -> (H) -> ((H) -> (H) -> H) -> ((nat) -> H) -> H)) (((bigop_body) (H)) (O))) (fun p : (nat) -> bool => fun nil : H => fun op : (H) -> (H) -> H => fun f : (nat) -> H => nil).
Definition sym_eq_bigop_body_O : forall H : Type, (((leibniz) (((nat) -> bool) -> (H) -> ((H) -> (H) -> H) -> ((nat) -> H) -> H)) (fun p : (nat) -> bool => fun nil : H => fun op : (H) -> (H) -> H => fun f : (nat) -> H => nil)) (((bigop_body) (H)) (O)) := fun H : Type => ((((sym_leibniz) (((nat) -> bool) -> (H) -> ((H) -> (H) -> H) -> ((nat) -> H) -> H)) (((bigop_body) (H)) (O))) (fun p : (nat) -> bool => fun nil : H => fun op : (H) -> (H) -> H => fun f : (nat) -> H => nil)) ((eq_bigop_body_O) (H)).
Axiom eq_bigop_body_S : forall H : Type, forall n : nat, (((leibniz) (((nat) -> bool) -> (H) -> ((H) -> (H) -> H) -> ((nat) -> H) -> H)) (((bigop_body) (H)) ((S) (n)))) (fun p : (nat) -> bool => fun nil : H => fun op : (H) -> (H) -> H => fun f : (nat) -> H => ((((match_bool_type) (H)) (((op) ((f) (n))) (((((((bigop) (H)) (n)) (p)) (nil)) (op)) (f)))) (((((((bigop) (H)) (n)) (p)) (nil)) (op)) (f))) ((p) (n))).
Definition sym_eq_bigop_body_S : forall H : Type, forall n : nat, (((leibniz) (((nat) -> bool) -> (H) -> ((H) -> (H) -> H) -> ((nat) -> H) -> H)) (fun p : (nat) -> bool => fun nil : H => fun op : (H) -> (H) -> H => fun f : (nat) -> H => ((((match_bool_type) (H)) (((op) ((f) (n))) (((((((bigop) (H)) (n)) (p)) (nil)) (op)) (f)))) (((((((bigop) (H)) (n)) (p)) (nil)) (op)) (f))) ((p) (n)))) (((bigop_body) (H)) ((S) (n))) := fun H : Type => fun n : nat => ((((sym_leibniz) (((nat) -> bool) -> (H) -> ((H) -> (H) -> H) -> ((nat) -> H) -> H)) (((bigop_body) (H)) ((S) (n)))) (fun p : (nat) -> bool => fun nil : H => fun op : (H) -> (H) -> H => fun f : (nat) -> H => ((((match_bool_type) (H)) (((op) ((f) (n))) (((((((bigop) (H)) (n)) (p)) (nil)) (op)) (f)))) (((((((bigop) (H)) (n)) (p)) (nil)) (op)) (f))) ((p) (n)))) (((eq_bigop_body_S) (H)) (n)).
Definition bigop_Strue : forall B : Type, forall k : nat, forall p : (nat) -> bool, forall nil : B, forall op : (B) -> (B) -> B, forall f : (nat) -> B, ((((eq) (bool)) ((p) (k))) (true)) -> (((eq) (B)) (((((((bigop) (B)) ((S) (k))) (fun i : nat => (p) (i))) (nil)) (op)) (fun i : nat => (f) (i)))) (((op) ((f) (k))) (((((((bigop) (B)) (k)) (fun i : nat => (p) (i))) (nil)) (op)) (fun i : nat => (f) (i)))) := fun B : Type => fun k : nat => fun p : (nat) -> bool => fun nil : B => fun op : (B) -> (B) -> B => fun f : (nat) -> B => ((((sym_eq_bigop_S) (B)) (k)) (fun y : ((nat) -> bool) -> (B) -> ((B) -> (B) -> B) -> ((nat) -> B) -> B => ((((eq) (bool)) ((p) (k))) (true)) -> (((eq) (B)) (((((y) (fun i : nat => (p) (i))) (nil)) (op)) (fun i : nat => (f) (i)))) (((op) ((f) (k))) (((((((bigop) (B)) (k)) (fun i : nat => (p) (i))) (nil)) (op)) (fun i : nat => (f) (i)))))) (((((sym_eq_bigop_body_S) (B)) (k)) (fun y : ((nat) -> bool) -> (B) -> ((B) -> (B) -> B) -> ((nat) -> B) -> B => ((((eq) (bool)) ((p) (k))) (true)) -> (((eq) (B)) (((((y) (fun i : nat => (p) (i))) (nil)) (op)) (fun i : nat => (f) (i)))) (((op) ((f) (k))) (((((((bigop) (B)) (k)) (fun i : nat => (p) (i))) (nil)) (op)) (fun i : nat => (f) (i)))))) (fun H : (((eq) (bool)) ((p) (k))) (true) => ((((((eq_ind_r) (bool)) (true)) (fun x : bool => (((eq) (B)) (((((match_bool_type) (B)) (((op) ((f) (k))) (((((((bigop) (B)) (k)) (fun i : nat => (p) (i))) (nil)) (op)) (fun i : nat => (f) (i))))) (((((((bigop) (B)) (k)) (fun i : nat => (p) (i))) (nil)) (op)) (fun i : nat => (f) (i)))) (x))) (((op) ((f) (k))) (((((((bigop) (B)) (k)) (fun i : nat => (p) (i))) (nil)) (op)) (fun i : nat => (f) (i)))))) ((((((eq_match_bool_type_true) (B)) (((op) ((f) (k))) (((((((bigop) (B)) (k)) (fun i : nat => (p) (i))) (nil)) (op)) (fun i : nat => (f) (i))))) (((((((bigop) (B)) (k)) (fun i : nat => (p) (i))) (nil)) (op)) (fun i : nat => (f) (i)))) (fun y : B => (((eq) (B)) (((((match_bool_type) (B)) (((op) ((f) (k))) (((((((bigop) (B)) (k)) (fun i : nat => (p) (i))) (nil)) (op)) (fun i : nat => (f) (i))))) (((((((bigop) (B)) (k)) (fun i : nat => (p) (i))) (nil)) (op)) (fun i : nat => (f) (i)))) (true))) (y))) (((refl) (B)) (((((match_bool_type) (B)) (((op) ((f) (k))) (((((((bigop) (B)) (k)) (fun i : nat => (p) (i))) (nil)) (op)) (fun i : nat => (f) (i))))) (((((((bigop) (B)) (k)) (fun i : nat => (p) (i))) (nil)) (op)) (fun i : nat => (f) (i)))) (true))))) ((p) (k))) (H))).
Definition bigop_Sfalse : forall B : Type, forall k : nat, forall p : (nat) -> bool, forall nil : B, forall op : (B) -> (B) -> B, forall f : (nat) -> B, ((((eq) (bool)) ((p) (k))) (false)) -> (((eq) (B)) (((((((bigop) (B)) ((S) (k))) (fun i : nat => (p) (i))) (nil)) (op)) (fun i : nat => (f) (i)))) (((((((bigop) (B)) (k)) (fun i : nat => (p) (i))) (nil)) (op)) (fun i : nat => (f) (i))) := fun B : Type => fun k : nat => fun p : (nat) -> bool => fun nil : B => fun op : (B) -> (B) -> B => fun f : (nat) -> B => ((((sym_eq_bigop_S) (B)) (k)) (fun y : ((nat) -> bool) -> (B) -> ((B) -> (B) -> B) -> ((nat) -> B) -> B => ((((eq) (bool)) ((p) (k))) (false)) -> (((eq) (B)) (((((y) (fun i : nat => (p) (i))) (nil)) (op)) (fun i : nat => (f) (i)))) (((((((bigop) (B)) (k)) (fun i : nat => (p) (i))) (nil)) (op)) (fun i : nat => (f) (i))))) (((((sym_eq_bigop_body_S) (B)) (k)) (fun y : ((nat) -> bool) -> (B) -> ((B) -> (B) -> B) -> ((nat) -> B) -> B => ((((eq) (bool)) ((p) (k))) (false)) -> (((eq) (B)) (((((y) (fun i : nat => (p) (i))) (nil)) (op)) (fun i : nat => (f) (i)))) (((((((bigop) (B)) (k)) (fun i : nat => (p) (i))) (nil)) (op)) (fun i : nat => (f) (i))))) (fun H : (((eq) (bool)) ((p) (k))) (false) => ((((((eq_ind_r) (bool)) (false)) (fun x : bool => (((eq) (B)) (((((match_bool_type) (B)) (((op) ((f) (k))) (((((((bigop) (B)) (k)) (fun i : nat => (p) (i))) (nil)) (op)) (fun i : nat => (f) (i))))) (((((((bigop) (B)) (k)) (fun i : nat => (p) (i))) (nil)) (op)) (fun i : nat => (f) (i)))) (x))) (((((((bigop) (B)) (k)) (fun i : nat => (p) (i))) (nil)) (op)) (fun i : nat => (f) (i))))) ((((((eq_match_bool_type_false) (B)) (((op) ((f) (k))) (((((((bigop) (B)) (k)) (fun i : nat => (p) (i))) (nil)) (op)) (fun i : nat => (f) (i))))) (((((((bigop) (B)) (k)) (fun i : nat => (p) (i))) (nil)) (op)) (fun i : nat => (f) (i)))) (fun y : B => (((eq) (B)) (((((match_bool_type) (B)) (((op) ((f) (k))) (((((((bigop) (B)) (k)) (fun i : nat => (p) (i))) (nil)) (op)) (fun i : nat => (f) (i))))) (((((((bigop) (B)) (k)) (fun i : nat => (p) (i))) (nil)) (op)) (fun i : nat => (f) (i)))) (false))) (y))) (((refl) (B)) (((((match_bool_type) (B)) (((op) ((f) (k))) (((((((bigop) (B)) (k)) (fun i : nat => (p) (i))) (nil)) (op)) (fun i : nat => (f) (i))))) (((((((bigop) (B)) (k)) (fun i : nat => (p) (i))) (nil)) (op)) (fun i : nat => (f) (i)))) (false))))) ((p) (k))) (H))).
Definition same_bigop : forall B : Type, forall k : nat, forall p1 : (nat) -> bool, forall p2 : (nat) -> bool, forall nil : B, forall op : (B) -> (B) -> B, forall f : (nat) -> B, forall g : (nat) -> B, (((((sameF_upto) (bool)) (k)) (p1)) (p2)) -> ((((((sameF_p) (B)) (k)) (p1)) (f)) (g)) -> (((eq) (B)) (((((((bigop) (B)) (k)) (fun i : nat => (p1) (i))) (nil)) (op)) (fun i : nat => (f) (i)))) (((((((bigop) (B)) (k)) (fun i : nat => (p2) (i))) (nil)) (op)) (fun i : nat => (g) (i))) := fun B : Type => fun k : nat => fun p1 : (nat) -> bool => fun p2 : (nat) -> bool => fun nil : B => fun op : (B) -> (B) -> B => fun f : (nat) -> B => fun g : (nat) -> B => ((((nat_ind) (fun Jokerx_365 : nat => (((((sameF_upto) (bool)) (Jokerx_365)) (p1)) (p2)) -> ((((((sameF_p) (B)) (Jokerx_365)) (p1)) (f)) (g)) -> (((eq) (B)) (((((((bigop) (B)) (Jokerx_365)) (fun i : nat => (p1) (i))) (nil)) (op)) (fun i : nat => (f) (i)))) (((((((bigop) (B)) (Jokerx_365)) (fun i : nat => (p2) (i))) (nil)) (op)) (fun i : nat => (g) (i))))) ((((sym_eq_bigop_O) (B)) (fun y : ((nat) -> bool) -> (B) -> ((B) -> (B) -> B) -> ((nat) -> B) -> B => (((((sameF_upto) (bool)) (O)) (p1)) (p2)) -> ((((((sameF_p) (B)) (O)) (p1)) (f)) (g)) -> (((eq) (B)) (((((((bigop) (B)) (O)) (fun i : nat => (p1) (i))) (nil)) (op)) (fun i : nat => (f) (i)))) (((((y) (fun i : nat => (p2) (i))) (nil)) (op)) (fun i : nat => (g) (i))))) ((((sym_eq_bigop_body_O) (B)) (fun y : ((nat) -> bool) -> (B) -> ((B) -> (B) -> B) -> ((nat) -> B) -> B => (((((sameF_upto) (bool)) (O)) (p1)) (p2)) -> ((((((sameF_p) (B)) (O)) (p1)) (f)) (g)) -> (((eq) (B)) (((((((bigop) (B)) (O)) (fun i : nat => (p1) (i))) (nil)) (op)) (fun i : nat => (f) (i)))) (((((y) (fun i : nat => (p2) (i))) (nil)) (op)) (fun i : nat => (g) (i))))) ((((eq_bigop_body_O) (B)) (fun y : ((nat) -> bool) -> (B) -> ((B) -> (B) -> B) -> ((nat) -> B) -> B => (((((sameF_upto) (bool)) (O)) (p1)) (p2)) -> ((((((sameF_p) (B)) (O)) (p1)) (f)) (g)) -> (((eq) (B)) (((((((bigop) (B)) (O)) (fun i : nat => (p1) (i))) (nil)) (op)) (fun i : nat => (f) (i)))) (((((y) (fun i : nat => (p1) (i))) (nil)) (op)) (fun i : nat => (f) (i))))) ((((eq_bigop_O) (B)) (fun y : ((nat) -> bool) -> (B) -> ((B) -> (B) -> B) -> ((nat) -> B) -> B => (((((sameF_upto) (bool)) (O)) (p1)) (p2)) -> ((((((sameF_p) (B)) (O)) (p1)) (f)) (g)) -> (((eq) (B)) (((((((bigop) (B)) (O)) (fun i : nat => (p1) (i))) (nil)) (op)) (fun i : nat => (f) (i)))) (((((y) (fun i : nat => (p1) (i))) (nil)) (op)) (fun i : nat => (f) (i))))) (fun auto : ((((sameF_upto) (bool)) (O)) (p1)) (p2) => fun auto' : (((((sameF_p) (B)) (O)) (p1)) (f)) (g) => ((refl) (B)) (((((((bigop) (B)) (O)) (fun i : nat => (p1) (i))) (nil)) (op)) (fun i : nat => (f) (i))))))))) (fun n : nat => ((((sym_eq_bigop_S) (B)) (n)) (fun y : ((nat) -> bool) -> (B) -> ((B) -> (B) -> B) -> ((nat) -> B) -> B => ((((((sameF_upto) (bool)) (n)) (p1)) (p2)) -> ((((((sameF_p) (B)) (n)) (p1)) (f)) (g)) -> (((eq) (B)) (((((((bigop) (B)) (n)) (fun i : nat => (p1) (i))) (nil)) (op)) (fun i : nat => (f) (i)))) (((((((bigop) (B)) (n)) (fun i : nat => (p2) (i))) (nil)) (op)) (fun i : nat => (g) (i)))) -> (((((sameF_upto) (bool)) ((S) (n))) (p1)) (p2)) -> ((((((sameF_p) (B)) ((S) (n))) (p1)) (f)) (g)) -> (((eq) (B)) (((((((bigop) (B)) ((S) (n))) (fun i : nat => (p1) (i))) (nil)) (op)) (fun i : nat => (f) (i)))) (((((y) (fun i : nat => (p2) (i))) (nil)) (op)) (fun i : nat => (g) (i))))) (((((sym_eq_bigop_S) (B)) (n)) (fun y : ((nat) -> bool) -> (B) -> ((B) -> (B) -> B) -> ((nat) -> B) -> B => ((((((sameF_upto) (bool)) (n)) (p1)) (p2)) -> ((((((sameF_p) (B)) (n)) (p1)) (f)) (g)) -> (((eq) (B)) (((((((bigop) (B)) (n)) (fun i : nat => (p1) (i))) (nil)) (op)) (fun i : nat => (f) (i)))) (((((((bigop) (B)) (n)) (fun i : nat => (p2) (i))) (nil)) (op)) (fun i : nat => (g) (i)))) -> (((((sameF_upto) (bool)) ((S) (n))) (p1)) (p2)) -> ((((((sameF_p) (B)) ((S) (n))) (p1)) (f)) (g)) -> (((eq) (B)) (((((y) (fun i : nat => (p1) (i))) (nil)) (op)) (fun i : nat => (f) (i)))) (((((((bigop_body) (B)) ((S) (n))) (fun i : nat => (p2) (i))) (nil)) (op)) (fun i : nat => (g) (i))))) (((((sym_eq_bigop_body_S) (B)) (n)) (fun y : ((nat) -> bool) -> (B) -> ((B) -> (B) -> B) -> ((nat) -> B) -> B => ((((((sameF_upto) (bool)) (n)) (p1)) (p2)) -> ((((((sameF_p) (B)) (n)) (p1)) (f)) (g)) -> (((eq) (B)) (((((((bigop) (B)) (n)) (fun i : nat => (p1) (i))) (nil)) (op)) (fun i : nat => (f) (i)))) (((((((bigop) (B)) (n)) (fun i : nat => (p2) (i))) (nil)) (op)) (fun i : nat => (g) (i)))) -> (((((sameF_upto) (bool)) ((S) (n))) (p1)) (p2)) -> ((((((sameF_p) (B)) ((S) (n))) (p1)) (f)) (g)) -> (((eq) (B)) (((((y) (fun i : nat => (p1) (i))) (nil)) (op)) (fun i : nat => (f) (i)))) (((((((bigop_body) (B)) ((S) (n))) (fun i : nat => (p2) (i))) (nil)) (op)) (fun i : nat => (g) (i))))) (((((sym_eq_bigop_body_S) (B)) (n)) (fun y : ((nat) -> bool) -> (B) -> ((B) -> (B) -> B) -> ((nat) -> B) -> B => ((((((sameF_upto) (bool)) (n)) (p1)) (p2)) -> ((((((sameF_p) (B)) (n)) (p1)) (f)) (g)) -> (((eq) (B)) (((((((bigop) (B)) (n)) (fun i : nat => (p1) (i))) (nil)) (op)) (fun i : nat => (f) (i)))) (((((((bigop) (B)) (n)) (fun i : nat => (p2) (i))) (nil)) (op)) (fun i : nat => (g) (i)))) -> (((((sameF_upto) (bool)) ((S) (n))) (p1)) (p2)) -> ((((((sameF_p) (B)) ((S) (n))) (p1)) (f)) (g)) -> (((eq) (B)) (((((fun p : (nat) -> bool => fun nil0 : B => fun op0 : (B) -> (B) -> B => fun f0 : (nat) -> B => ((((match_bool_type) (B)) (((op0) ((f0) (n))) (((((((bigop) (B)) (n)) (p)) (nil0)) (op0)) (f0)))) (((((((bigop) (B)) (n)) (p)) (nil0)) (op0)) (f0))) ((p) (n))) (fun i : nat => (p1) (i))) (nil)) (op)) (fun i : nat => (f) (i)))) (((((y) (fun i : nat => (p2) (i))) (nil)) (op)) (fun i : nat => (g) (i))))) (fun Hind : (((((sameF_upto) (bool)) (n)) (p1)) (p2)) -> ((((((sameF_p) (B)) (n)) (p1)) (f)) (g)) -> (((eq) (B)) (((((((bigop) (B)) (n)) (fun i : nat => (p1) (i))) (nil)) (op)) (fun i : nat => (f) (i)))) (((((((bigop) (B)) (n)) (fun i : nat => (p2) (i))) (nil)) (op)) (fun i : nat => (g) (i))) => fun samep : ((((sameF_upto) (bool)) ((S) (n))) (p1)) (p2) => fun samef : (((((sameF_p) (B)) ((S) (n))) (p1)) (f)) (g) => ((((((eq_ind_r) (B)) (((((((bigop) (B)) (n)) (fun i : nat => (p2) (i))) (nil)) (op)) (fun i : nat => (g) (i)))) (fun x : B => (((eq) (B)) (((((match_bool_type) (B)) (((op) ((f) (n))) (x))) (x)) ((p1) (n)))) (((((match_bool_type) (B)) (((op) ((g) (n))) (((((((bigop) (B)) (n)) (fun i : nat => (p2) (i))) (nil)) (op)) (fun i : nat => (g) (i))))) (((((((bigop) (B)) (n)) (fun i : nat => (p2) (i))) (nil)) (op)) (fun i : nat => (g) (i)))) ((p2) (n))))) (((((((eq_ind) (bool)) ((p1) (n))) (fun x_1 : bool => (((eq) (B)) (((((match_bool_type) (B)) (((op) ((f) (n))) (((((((bigop) (B)) (n)) (fun i : nat => (p2) (i))) (nil)) (op)) (fun i : nat => (g) (i))))) (((((((bigop) (B)) (n)) (fun i : nat => (p2) (i))) (nil)) (op)) (fun i : nat => (g) (i)))) ((p1) (n)))) (((((match_bool_type) (B)) (((op) ((g) (n))) (((((((bigop) (B)) (n)) (fun i : nat => (p2) (i))) (nil)) (op)) (fun i : nat => (g) (i))))) (((((((bigop) (B)) (n)) (fun i : nat => (p2) (i))) (nil)) (op)) (fun i : nat => (g) (i)))) (x_1)))) (((((((match_Or_prop) ((((eq) (bool)) ((p1) (n))) (true))) ((((eq) (bool)) ((p1) (n))) (false))) ((((eq) (B)) (((((match_bool_type) (B)) (((op) ((f) (n))) (((((((bigop) (B)) (n)) (fun i : nat => (p2) (i))) (nil)) (op)) (fun i : nat => (g) (i))))) (((((((bigop) (B)) (n)) (fun i : nat => (p2) (i))) (nil)) (op)) (fun i : nat => (g) (i)))) ((p1) (n)))) (((((match_bool_type) (B)) (((op) ((g) (n))) (((((((bigop) (B)) (n)) (fun i : nat => (p2) (i))) (nil)) (op)) (fun i : nat => (g) (i))))) (((((((bigop) (B)) (n)) (fun i : nat => (p2) (i))) (nil)) (op)) (fun i : nat => (g) (i)))) ((p1) (n))))) (fun H1 : (((eq) (bool)) ((p1) (n))) (true) => ((((((eq_ind_r) (bool)) (true)) (fun x : bool => (((eq) (B)) (((((match_bool_type) (B)) (((op) ((f) (n))) (((((((bigop) (B)) (n)) (fun i : nat => (p2) (i))) (nil)) (op)) (fun i : nat => (g) (i))))) (((((((bigop) (B)) (n)) (fun i : nat => (p2) (i))) (nil)) (op)) (fun i : nat => (g) (i)))) (x))) (((((match_bool_type) (B)) (((op) ((g) (n))) (((((((bigop) (B)) (n)) (fun i : nat => (p2) (i))) (nil)) (op)) (fun i : nat => (g) (i))))) (((((((bigop) (B)) (n)) (fun i : nat => (p2) (i))) (nil)) (op)) (fun i : nat => (g) (i)))) (x)))) ((((((sym_eq_match_bool_type_true) (B)) (((op) ((f) (n))) (((((((bigop) (B)) (n)) (fun i : nat => (p2) (i))) (nil)) (op)) (fun i : nat => (g) (i))))) (((((((bigop) (B)) (n)) (fun i : nat => (p2) (i))) (nil)) (op)) (fun i : nat => (g) (i)))) (fun y : B => (((eq) (B)) (y)) (((((match_bool_type) (B)) (((op) ((g) (n))) (((((((bigop) (B)) (n)) (fun i : nat => (p2) (i))) (nil)) (op)) (fun i : nat => (g) (i))))) (((((((bigop) (B)) (n)) (fun i : nat => (p2) (i))) (nil)) (op)) (fun i : nat => (g) (i)))) (true)))) ((((((sym_eq_match_bool_type_true) (B)) (((op) ((g) (n))) (((((((bigop) (B)) (n)) (fun i : nat => (p2) (i))) (nil)) (op)) (fun i : nat => (g) (i))))) (((((((bigop) (B)) (n)) (fun i : nat => (p2) (i))) (nil)) (op)) (fun i : nat => (g) (i)))) (fun y : B => (((eq) (B)) (((op) ((f) (n))) (((((((bigop) (B)) (n)) (fun i : nat => (p2) (i))) (nil)) (op)) (fun i : nat => (g) (i))))) (y))) (((((((eq_ind) (B)) ((f) (n))) (fun x_1 : B => (((eq) (B)) (((op) ((f) (n))) (((((((bigop) (B)) (n)) (fun i : nat => (p2) (i))) (nil)) (op)) (fun i : nat => (g) (i))))) (((op) (x_1)) (((((((bigop) (B)) (n)) (fun i : nat => (p2) (i))) (nil)) (op)) (fun i : nat => (g) (i)))))) (((refl) (B)) (((op) ((f) (n))) (((((((bigop) (B)) (n)) (fun i : nat => (p2) (i))) (nil)) (op)) (fun i : nat => (g) (i)))))) ((g) (n))) ((((samef) (n)) ((le_n) ((S) (n)))) (H1)))))) ((p1) (n))) (H1))) (fun H1 : (((eq) (bool)) ((p1) (n))) (false) => ((((((eq_ind_r) (bool)) (false)) (fun x : bool => (((eq) (B)) (((((match_bool_type) (B)) (((op) ((f) (n))) (((((((bigop) (B)) (n)) (fun i : nat => (p2) (i))) (nil)) (op)) (fun i : nat => (g) (i))))) (((((((bigop) (B)) (n)) (fun i : nat => (p2) (i))) (nil)) (op)) (fun i : nat => (g) (i)))) (x))) (((((match_bool_type) (B)) (((op) ((g) (n))) (((((((bigop) (B)) (n)) (fun i : nat => (p2) (i))) (nil)) (op)) (fun i : nat => (g) (i))))) (((((((bigop) (B)) (n)) (fun i : nat => (p2) (i))) (nil)) (op)) (fun i : nat => (g) (i)))) (x)))) ((((((sym_eq_match_bool_type_false) (B)) (((op) ((f) (n))) (((((((bigop) (B)) (n)) (fun i : nat => (p2) (i))) (nil)) (op)) (fun i : nat => (g) (i))))) (((((((bigop) (B)) (n)) (fun i : nat => (p2) (i))) (nil)) (op)) (fun i : nat => (g) (i)))) (fun y : B => (((eq) (B)) (y)) (((((match_bool_type) (B)) (((op) ((g) (n))) (((((((bigop) (B)) (n)) (fun i : nat => (p2) (i))) (nil)) (op)) (fun i : nat => (g) (i))))) (((((((bigop) (B)) (n)) (fun i : nat => (p2) (i))) (nil)) (op)) (fun i : nat => (g) (i)))) (false)))) ((((((sym_eq_match_bool_type_false) (B)) (((op) ((g) (n))) (((((((bigop) (B)) (n)) (fun i : nat => (p2) (i))) (nil)) (op)) (fun i : nat => (g) (i))))) (((((((bigop) (B)) (n)) (fun i : nat => (p2) (i))) (nil)) (op)) (fun i : nat => (g) (i)))) (fun y : B => (((eq) (B)) (((((((bigop) (B)) (n)) (fun i : nat => (p2) (i))) (nil)) (op)) (fun i : nat => (g) (i)))) (y))) (((refl) (B)) (((((((bigop) (B)) (n)) (fun i : nat => (p2) (i))) (nil)) (op)) (fun i : nat => (g) (i))))))) ((p1) (n))) (H1))) ((true_or_false) ((p1) (n))))) ((p2) (n))) (((samep) (n)) ((le_n) ((S) (n)))))) (((((((bigop) (B)) (n)) (fun i : nat => (p1) (i))) (nil)) (op)) (fun i : nat => (f) (i)))) (((Hind) ((((((((sameF_upto_le) (bool)) (p1)) (p2)) (n)) ((S) (n))) (((((eq_coerc) (((le) ((pred) ((S) (n)))) ((S) (n)))) (((le) (n)) ((S) (n)))) ((le_pred_n) ((S) (n)))) (((((((rewrite_l) (nat)) (n)) (fun Joker_ : nat => (((eq) Prop) (((le) (Joker_)) ((S) (n)))) (((le) (n)) ((S) (n))))) (((refl) Prop) (((le) (n)) ((S) (n))))) ((pred) ((S) (n)))) ((pred_Sn) (n))))) (samep))) (((((((((sameF_p_le) (B)) (p1)) (f)) (g)) (n)) ((S) (n))) (((((eq_coerc) (((le) ((pred) ((S) (n)))) ((S) (n)))) (((le) (n)) ((S) (n)))) ((le_pred_n) ((S) (n)))) (((((((rewrite_l) (nat)) (n)) (fun Joker_ : nat => (((eq) Prop) (((le) (Joker_)) ((S) (n)))) (((le) (n)) ((S) (n))))) (((refl) Prop) (((le) (n)) ((S) (n))))) ((pred) ((S) (n)))) ((pred_Sn) (n))))) (samef))))))))) (k).
Definition bigop_false : forall B : Type, forall n : nat, forall nil : B, forall op : (B) -> (B) -> B, forall f : (nat) -> B, (((eq) (B)) (((((((bigop) (B)) (n)) (fun i : nat => false)) (nil)) (op)) (fun i : nat => (f) (i)))) (nil) := fun B : Type => fun n : nat => fun nil : B => fun op : (B) -> (B) -> B => fun f : (nat) -> B => ((((nat_ind) (fun Jokerx_365 : nat => (((eq) (B)) (((((((bigop) (B)) (Jokerx_365)) (fun i : nat => false)) (nil)) (op)) (fun i : nat => (f) (i)))) (nil))) ((((eq_bigop_body_O) (B)) (fun y : ((nat) -> bool) -> (B) -> ((B) -> (B) -> B) -> ((nat) -> B) -> B => (((eq) (B)) (((((((bigop) (B)) (O)) (fun i : nat => false)) (nil)) (op)) (fun i : nat => (f) (i)))) (((((y) (fun i : nat => false)) (nil)) (op)) (fun i : nat => (f) (i))))) ((((eq_bigop_O) (B)) (fun y : ((nat) -> bool) -> (B) -> ((B) -> (B) -> B) -> ((nat) -> B) -> B => (((eq) (B)) (((((((bigop) (B)) (O)) (fun i : nat => false)) (nil)) (op)) (fun i : nat => (f) (i)))) (((((y) (fun i : nat => false)) (nil)) (op)) (fun i : nat => (f) (i))))) (((refl) (B)) (((((((bigop) (B)) (O)) (fun i : nat => false)) (nil)) (op)) (fun i : nat => (f) (i))))))) (fun n1 : nat => fun Hind : (((eq) (B)) (((((((bigop) (B)) (n1)) (fun i : nat => false)) (nil)) (op)) (fun i : nat => (f) (i)))) (nil) => ((((((eq_ind_r) (B)) (((((((bigop) (B)) (n1)) (fun i : nat => false)) (nil)) (op)) (fun i : nat => (f) (i)))) (fun x : B => (((eq) (B)) (x)) (nil))) (((((((rewrite_r) (B)) (nil)) (fun Joker_ : B => (((eq) (B)) (Joker_)) (nil))) (((refl) (B)) (nil))) (((((((bigop) (B)) (n1)) (fun i : nat => false)) (nil)) (op)) (fun i : nat => (f) (i)))) (Hind))) (((((((bigop) (B)) ((S) (n1))) (fun i : nat => false)) (nil)) (op)) (fun i : nat => (f) (i)))) ((((((((bigop_Sfalse) (B)) (n1)) (fun Joker_ : nat => false)) (nil)) (op)) (f)) (((refl) (bool)) (false))))) (n).
Parameter Aop : forall A : Type, (A) -> Prop.
Axiom mk_Aop : forall A : Type, forall nil : A, forall op : (A) -> (A) -> A, (forall a : A, (((eq) (A)) (((op) (nil)) (a))) (a)) -> (forall a : A, (((eq) (A)) (((op) (a)) (nil))) (a)) -> (forall a : A, forall b : A, forall c : A, (((eq) (A)) (((op) (a)) (((op) (b)) (c)))) (((op) (((op) (a)) (b))) (c))) -> ((Aop) (A)) (nil).
Definition assoc : forall a : nat, forall b : nat, forall c : nat, (((eq) (nat)) (((times) (a)) (((times) (b)) (c)))) (((times) (((times) (a)) (b))) (c)) := fun a : nat => fun b : nat => fun c : nat => ((((sym_eq) (nat)) (((times) (((times) (a)) (b))) (c))) (((times) (a)) (((times) (b)) (c)))) ((((associative_times) (a)) (b)) (c)).
Definition timesA : ((Aop) (nat)) ((S) (O)) := ((((((mk_Aop) (nat)) ((S) (O))) (times)) (fun a : nat => (((sym_eq_times) ((S) (O))) (fun y : (nat) -> nat => (((eq) (nat)) ((y) (a))) (a))) ((((((sym_eq_filter_nat_type_S) ((nat) -> nat)) (times_body)) (O)) (fun y : (nat) -> nat => (((eq) (nat)) ((y) (a))) (a))) ((((sym_eq_times_body_S) (O)) (fun y : (nat) -> nat => (((eq) (nat)) ((y) (a))) (a))) ((((sym_eq_times) (O)) (fun y : (nat) -> nat => (((eq) (nat)) (((plus) (a)) ((y) (a)))) (a))) (((((sym_eq_filter_nat_type_O) ((nat) -> nat)) (times_body)) (fun y : (nat) -> nat => (((eq) (nat)) (((plus) (a)) ((y) (a)))) (a))) (((sym_eq_times_body_O) (fun y : (nat) -> nat => (((eq) (nat)) (((plus) (a)) ((y) (a)))) (a))) (((((sym_eq) (nat)) (a)) (((plus) (a)) (O))) ((plus_n_O) (a)))))))))) (fun n : nat => ((((sym_eq) (nat)) (n)) (((times) (n)) ((S) (O)))) ((times_n_1) (n)))) (fun a : nat => fun b : nat => fun c : nat => ((((sym_eq) (nat)) (((times) (((times) (a)) (b))) (c))) (((times) (a)) (((times) (b)) (c)))) ((((associative_times) (a)) (b)) (c))).
Definition bigop_I_gen : forall a : nat, forall b : nat, forall p : (nat) -> bool, forall f : (nat) -> nat, (((le) (a)) (b)) -> (((eq) (nat)) (((((((bigop) (nat)) (((minus) (b)) (a))) (fun i : nat => (p) (((plus) (i)) (a)))) ((S) (O))) (times)) (fun i : nat => (f) (((plus) (i)) (a))))) (((((((bigop) (nat)) (b)) (fun i : nat => ((andb) (((leb) (a)) (i))) ((p) (i)))) ((S) (O))) (times)) (fun i : nat => (f) (i))) := fun a : nat => fun b : nat => ((((nat_ind) (fun Jokerx_365 : nat => forall p : (nat) -> bool, forall f : (nat) -> nat, (((le) (a)) (Jokerx_365)) -> (((eq) (nat)) (((((((bigop) (nat)) (((minus) (Jokerx_365)) (a))) (fun i : nat => (p) (((plus) (i)) (a)))) ((S) (O))) (times)) (fun i : nat => (f) (((plus) (i)) (a))))) (((((((bigop) (nat)) (Jokerx_365)) (fun i : nat => ((andb) (((leb) (a)) (i))) ((p) (i)))) ((S) (O))) (times)) (fun i : nat => (f) (i))))) (fun p : (nat) -> bool => fun f : (nat) -> nat => (((sym_eq_bigop_O) (nat)) (fun y : ((nat) -> bool) -> (nat) -> ((nat) -> (nat) -> nat) -> ((nat) -> nat) -> nat => (((le) (a)) (O)) -> (((eq) (nat)) (((((((bigop) (nat)) (((minus) (O)) (a))) (fun i : nat => (p) (((plus) (i)) (a)))) ((S) (O))) (times)) (fun i : nat => (f) (((plus) (i)) (a))))) (((((y) (fun i : nat => ((andb) (((leb) (a)) (i))) ((p) (i)))) ((S) (O))) (times)) (fun i : nat => (f) (i))))) ((((sym_eq_bigop_body_O) (nat)) (fun y : ((nat) -> bool) -> (nat) -> ((nat) -> (nat) -> nat) -> ((nat) -> nat) -> nat => (((le) (a)) (O)) -> (((eq) (nat)) (((((((bigop) (nat)) (((minus) (O)) (a))) (fun i : nat => (p) (((plus) (i)) (a)))) ((S) (O))) (times)) (fun i : nat => (f) (((plus) (i)) (a))))) (((((y) (fun i : nat => ((andb) (((leb) (a)) (i))) ((p) (i)))) ((S) (O))) (times)) (fun i : nat => (f) (i))))) ((((eq_bigop_body_O) (nat)) (fun y : ((nat) -> bool) -> (nat) -> ((nat) -> (nat) -> nat) -> ((nat) -> nat) -> nat => (((le) (a)) (O)) -> (((eq) (nat)) (((((((bigop) (nat)) (((minus) (O)) (a))) (fun i : nat => (p) (((plus) (i)) (a)))) ((S) (O))) (times)) (fun i : nat => (f) (((plus) (i)) (a))))) (((((y) (fun i : nat => (p) (((plus) (i)) (a)))) ((S) (O))) (times)) (fun i : nat => (f) (((plus) (i)) (a)))))) ((((eq_bigop_O) (nat)) (fun y : ((nat) -> bool) -> (nat) -> ((nat) -> (nat) -> nat) -> ((nat) -> nat) -> nat => (((le) (a)) (O)) -> (((eq) (nat)) (((((((bigop) (nat)) (((minus) (O)) (a))) (fun i : nat => (p) (((plus) (i)) (a)))) ((S) (O))) (times)) (fun i : nat => (f) (((plus) (i)) (a))))) (((((y) (fun i : nat => (p) (((plus) (i)) (a)))) ((S) (O))) (times)) (fun i : nat => (f) (((plus) (i)) (a)))))) (((eq_minus_body_O) (fun y : (nat) -> nat => (((le) (a)) (O)) -> (((eq) (nat)) (((((((bigop) (nat)) (((minus) (O)) (a))) (fun i : nat => (p) (((plus) (i)) (a)))) ((S) (O))) (times)) (fun i : nat => (f) (((plus) (i)) (a))))) (((((((bigop) (nat)) ((y) (a))) (fun i : nat => (p) (((plus) (i)) (a)))) ((S) (O))) (times)) (fun i : nat => (f) (((plus) (i)) (a)))))) (((((eq_filter_nat_type_O) ((nat) -> nat)) (minus_body)) (fun y : (nat) -> nat => (((le) (a)) (O)) -> (((eq) (nat)) (((((((bigop) (nat)) (((minus) (O)) (a))) (fun i : nat => (p) (((plus) (i)) (a)))) ((S) (O))) (times)) (fun i : nat => (f) (((plus) (i)) (a))))) (((((((bigop) (nat)) ((y) (a))) (fun i : nat => (p) (((plus) (i)) (a)))) ((S) (O))) (times)) (fun i : nat => (f) (((plus) (i)) (a)))))) ((((eq_minus) (O)) (fun y : (nat) -> nat => (((le) (a)) (O)) -> (((eq) (nat)) (((((((bigop) (nat)) (((minus) (O)) (a))) (fun i : nat => (p) (((plus) (i)) (a)))) ((S) (O))) (times)) (fun i : nat => (f) (((plus) (i)) (a))))) (((((((bigop) (nat)) ((y) (a))) (fun i : nat => (p) (((plus) (i)) (a)))) ((S) (O))) (times)) (fun i : nat => (f) (((plus) (i)) (a)))))) (fun auto : ((le) (a)) (O) => ((refl) (nat)) (((((((bigop) (nat)) (((minus) (O)) (a))) (fun i : nat => (p) (((plus) (i)) (a)))) ((S) (O))) (times)) (fun i : nat => (f) (((plus) (i)) (a))))))))))))) (fun b0 : nat => fun Hind : forall p : (nat) -> bool, forall f : (nat) -> nat, (((le) (a)) (b0)) -> (((eq) (nat)) (((((((bigop) (nat)) (((minus) (b0)) (a))) (fun i : nat => (p) (((plus) (i)) (a)))) ((S) (O))) (times)) (fun i : nat => (f) (((plus) (i)) (a))))) (((((((bigop) (nat)) (b0)) (fun i : nat => ((andb) (((leb) (a)) (i))) ((p) (i)))) ((S) (O))) (times)) (fun i : nat => (f) (i))) => fun p : (nat) -> bool => fun f : (nat) -> nat => fun lea : ((le) (a)) ((S) (b0)) => ((((((match_Or_prop) (((lt) (a)) ((S) (b0)))) ((((eq) (nat)) (a)) ((S) (b0)))) ((((eq) (nat)) (((((((bigop) (nat)) (((minus) ((S) (b0))) (a))) (fun i : nat => (p) (((plus) (i)) (a)))) ((S) (O))) (times)) (fun i : nat => (f) (((plus) (i)) (a))))) (((((((bigop) (nat)) ((S) (b0))) (fun i : nat => ((andb) (((leb) (a)) (i))) ((p) (i)))) ((S) (O))) (times)) (fun i : nat => (f) (i))))) (fun Ha : ((lt) (a)) ((S) (b0)) => ((((((match_Or_prop) ((((eq) (bool)) ((p) (b0))) (true))) ((((eq) (bool)) ((p) (b0))) (false))) ((((eq) (nat)) (((((((bigop) (nat)) (((minus) ((S) (b0))) (a))) (fun i : nat => (p) (((plus) (i)) (a)))) ((S) (O))) (times)) (fun i : nat => (f) (((plus) (i)) (a))))) (((((((bigop) (nat)) ((S) (b0))) (fun i : nat => ((andb) (((leb) (a)) (i))) ((p) (i)))) ((S) (O))) (times)) (fun i : nat => (f) (i))))) (fun Hcase : (((eq) (bool)) ((p) (b0))) (true) => ((((((eq_ind_r) (nat)) (((times) ((f) (b0))) (((((((bigop) (nat)) (b0)) (fun i : nat => ((andb) (((leb) (a)) (i))) ((p) (i)))) ((S) (O))) (times)) (fun i : nat => (f) (i))))) (fun x : nat => (((eq) (nat)) (((((((bigop) (nat)) (((minus) ((S) (b0))) (a))) (fun i : nat => (p) (((plus) (i)) (a)))) ((S) (O))) (times)) (fun i : nat => (f) (((plus) (i)) (a))))) (x))) (((((((eq_ind_r) (nat)) ((S) (((minus) (b0)) (a)))) (fun x : nat => (((eq) (nat)) (((((((bigop) (nat)) (x)) (fun i : nat => (p) (((plus) (i)) (a)))) ((S) (O))) (times)) (fun i : nat => (f) (((plus) (i)) (a))))) (((times) ((f) (b0))) (((((((bigop) (nat)) (b0)) (fun i : nat => ((andb) (((leb) (a)) (i))) ((p) (i)))) ((S) (O))) (times)) (fun i : nat => (f) (i)))))) (((((((eq_ind_r) (nat)) (((times) ((f) (((plus) (((minus) (b0)) (a))) (a)))) (((((((bigop) (nat)) (((minus) (b0)) (a))) (fun i : nat => (p) (((plus) (i)) (a)))) ((S) (O))) (times)) (fun i : nat => (f) (((plus) (i)) (a)))))) (fun x : nat => (((eq) (nat)) (x)) (((times) ((f) (b0))) (((((((bigop) (nat)) (b0)) (fun i : nat => ((andb) (((leb) (a)) (i))) ((p) (i)))) ((S) (O))) (times)) (fun i : nat => (f) (i)))))) (((((((((((eq_f2) (nat)) (nat)) (nat)) (times)) ((f) (((plus) (((minus) (b0)) (a))) (a)))) ((f) (b0))) (((((((bigop) (nat)) (((minus) (b0)) (a))) (fun i : nat => (p) (((plus) (i)) (a)))) ((S) (O))) (times)) (fun i : nat => (f) (((plus) (i)) (a))))) (((((((bigop) (nat)) (b0)) (fun i : nat => ((andb) (((leb) (a)) (i))) ((p) (i)))) ((S) (O))) (times)) (fun i : nat => (f) (i)))) (((((((eq_f) (nat)) (nat)) (f)) (((plus) (((minus) (b0)) (a))) (a))) (b0)) (((((((eq_ind) (nat)) (b0)) (fun x_1 : nat => (((eq) (nat)) (x_1)) (b0))) (((refl) (nat)) (b0))) (((plus) (((minus) (b0)) (a))) (a))) ((((plus_minus_m_m) (b0)) (a)) ((((le_S_S_to_le) (a)) (b0)) (Ha)))))) ((((Hind) (p)) (f)) ((((le_S_S_to_le) (a)) (b0)) (Ha))))) (((((((bigop) (nat)) ((S) (((minus) (b0)) (a)))) (fun i : nat => (p) (((plus) (i)) (a)))) ((S) (O))) (times)) (fun i : nat => (f) (((plus) (i)) (a))))) ((((((((bigop_Strue) (nat)) (((minus) (b0)) (a))) (fun Joker_ : nat => (p) (((plus) (Joker_)) (a)))) ((S) (O))) (times)) (fun Joker_ : nat => (f) (((plus) (Joker_)) (a)))) (((((((eq_ind) (nat)) (b0)) (fun x_1 : nat => (((eq) (bool)) ((p) (x_1))) (true))) (((((((rewrite_r) (bool)) (true)) (fun Joker_ : bool => (((eq) (bool)) (Joker_)) (true))) (((refl) (bool)) (true))) ((p) (b0))) (Hcase))) (((plus) (((minus) (b0)) (a))) (a))) ((((plus_minus_m_m) (b0)) (a)) ((((le_S_S_to_le) (a)) (b0)) (Ha))))))) (((minus) ((S) (b0))) (a))) ((((((match_nat_prop) (fun Joker_ : nat => (((le) (Joker_)) (b0)) -> (((eq) (nat)) (((minus) ((S) (b0))) (Joker_))) ((S) (((minus) (b0)) (Joker_))))) (fun auto : ((le) (O)) (b0) => ((((((rewrite_l) (nat)) ((S) (b0))) (fun Joker_ : nat => (((eq) (nat)) (Joker_)) ((S) (((minus) (b0)) (O))))) (((((((rewrite_l) (nat)) (b0)) (fun Joker_ : nat => (((eq) (nat)) ((S) (b0))) ((S) (Joker_)))) (((refl) (nat)) ((S) (b0)))) (((minus) (b0)) (O))) ((minus_n_O) (b0)))) (((minus) ((S) (b0))) (O))) ((minus_n_O) ((S) (b0))))) ((((sym_eq_minus) ((S) (b0))) (fun y : (nat) -> nat => forall n : nat, (((le) ((S) (n))) (b0)) -> (((eq) (nat)) ((y) ((S) (n)))) ((S) (((minus) (b0)) ((S) (n)))))) ((((((sym_eq_filter_nat_type_S) ((nat) -> nat)) (minus_body)) (b0)) (fun y : (nat) -> nat => forall n : nat, (((le) ((S) (n))) (b0)) -> (((eq) (nat)) ((y) ((S) (n)))) ((S) (((minus) (b0)) ((S) (n)))))) (fun a1 : nat => (((sym_eq_minus_body_S) (b0)) (fun y : (nat) -> nat => (((le) ((S) (a1))) (b0)) -> (((eq) (nat)) ((y) ((S) (a1)))) ((S) (((minus) (b0)) ((S) (a1)))))) (((((((sym_eq_match_nat_type_S) (nat)) ((S) (b0))) (fun q : nat => ((minus) (b0)) (q))) (a1)) (fun y : nat => (((le) ((S) (a1))) (b0)) -> (((eq) (nat)) (y)) ((S) (((minus) (b0)) ((S) (a1)))))) (fun lta1 : ((le) ((S) (a1))) (b0) => ((((((eq_ind_r) (nat)) ((pred) (((minus) (b0)) (a1)))) (fun x : nat => (((eq) (nat)) (((minus) (b0)) (a1))) ((S) (x)))) (((((((eq_ind_r) (nat)) (((minus) (b0)) (a1))) (fun x : nat => (((eq) (nat)) (((minus) (b0)) (a1))) (x))) (((refl) (nat)) (((minus) (b0)) (a1)))) ((S) ((pred) (((minus) (b0)) (a1))))) (((S_pred) (((minus) (b0)) (a1))) (((((lt_plus_to_minus_r) (O)) (a1)) (b0)) ((((sym_eq_plus) (O)) (fun y : (nat) -> nat => ((le) ((S) ((y) (a1)))) (b0))) (((((sym_eq_filter_nat_type_O) ((nat) -> nat)) (plus_body)) (fun y : (nat) -> nat => ((le) ((S) ((y) (a1)))) (b0))) (((sym_eq_plus_body_O) (fun y : (nat) -> nat => ((le) ((S) ((y) (a1)))) (b0))) (lta1)))))))) (((minus) (b0)) ((S) (a1)))) (((eq_minus_S_pred) (b0)) (a1)))))))) (a)) ((((le_S_S_to_le) (a)) (b0)) (Ha))))) (((((((bigop) (nat)) ((S) (b0))) (fun i : nat => ((andb) (((leb) (a)) (i))) ((p) (i)))) ((S) (O))) (times)) (fun i : nat => (f) (i)))) ((((((((bigop_Strue) (nat)) (b0)) (fun Joker_ : nat => ((andb) (((leb) (a)) (Joker_))) ((p) (Joker_)))) ((S) (O))) (times)) (f)) (((((((eq_ind_r) (bool)) (true)) (fun x : bool => (((eq) (bool)) (((andb) (((leb) (a)) (b0))) (x))) (true))) (((((((eq_ind_r) (bool)) (true)) (fun x : bool => (((eq) (bool)) (((andb) (x)) (true))) (true))) ((((((eq_match_bool_type_true) (bool)) (true)) (false)) (fun y : bool => (((eq) (bool)) (((((match_bool_type) (bool)) (true)) (false)) (true))) (y))) (((refl) (bool)) (((andb) (true)) (true))))) (((leb) (a)) (b0))) ((((le_to_leb_true) (a)) (b0)) ((((le_S_S_to_le) (a)) (b0)) (Ha))))) ((p) (b0))) (Hcase))))) (fun Hcase : (((eq) (bool)) ((p) (b0))) (false) => ((((((eq_ind_r) (nat)) (((((((bigop) (nat)) (b0)) (fun i : nat => ((andb) (((leb) (a)) (i))) ((p) (i)))) ((S) (O))) (times)) (fun i : nat => (f) (i)))) (fun x : nat => (((eq) (nat)) (((((((bigop) (nat)) (((minus) ((S) (b0))) (a))) (fun i : nat => (p) (((plus) (i)) (a)))) ((S) (O))) (times)) (fun i : nat => (f) (((plus) (i)) (a))))) (x))) (((((((eq_ind_r) (nat)) ((S) (((minus) (b0)) (a)))) (fun x : nat => (((eq) (nat)) (((((((bigop) (nat)) (x)) (fun i : nat => (p) (((plus) (i)) (a)))) ((S) (O))) (times)) (fun i : nat => (f) (((plus) (i)) (a))))) (((((((bigop) (nat)) (b0)) (fun i : nat => ((andb) (((leb) (a)) (i))) ((p) (i)))) ((S) (O))) (times)) (fun i : nat => (f) (i))))) (((((((eq_ind_r) (nat)) (((((((bigop) (nat)) (((minus) (b0)) (a))) (fun i : nat => (p) (((plus) (i)) (a)))) ((S) (O))) (times)) (fun i : nat => (f) (((plus) (i)) (a))))) (fun x : nat => (((eq) (nat)) (x)) (((((((bigop) (nat)) (b0)) (fun i : nat => ((andb) (((leb) (a)) (i))) ((p) (i)))) ((S) (O))) (times)) (fun i : nat => (f) (i))))) ((((Hind) (p)) (f)) ((((le_S_S_to_le) (a)) (b0)) (Ha)))) (((((((bigop) (nat)) ((S) (((minus) (b0)) (a)))) (fun i : nat => (p) (((plus) (i)) (a)))) ((S) (O))) (times)) (fun i : nat => (f) (((plus) (i)) (a))))) ((((((((bigop_Sfalse) (nat)) (((minus) (b0)) (a))) (fun Joker_ : nat => (p) (((plus) (Joker_)) (a)))) ((S) (O))) (times)) (fun Joker_ : nat => (f) (((plus) (Joker_)) (a)))) (((((((eq_ind) (nat)) (b0)) (fun x_1 : nat => (((eq) (bool)) ((p) (x_1))) (false))) (((((((rewrite_r) (bool)) (false)) (fun Joker_ : bool => (((eq) (bool)) (Joker_)) (false))) (((refl) (bool)) (false))) ((p) (b0))) (Hcase))) (((plus) (((minus) (b0)) (a))) (a))) ((((plus_minus_m_m) (b0)) (a)) ((((le_S_S_to_le) (a)) (b0)) (Ha))))))) (((minus) ((S) (b0))) (a))) ((((((match_nat_prop) (fun Joker_ : nat => (((le) (Joker_)) (b0)) -> (((eq) (nat)) (((minus) ((S) (b0))) (Joker_))) ((S) (((minus) (b0)) (Joker_))))) (fun auto : ((le) (O)) (b0) => ((((((rewrite_l) (nat)) ((S) (b0))) (fun Joker_ : nat => (((eq) (nat)) (Joker_)) ((S) (((minus) (b0)) (O))))) (((((((rewrite_l) (nat)) (b0)) (fun Joker_ : nat => (((eq) (nat)) ((S) (b0))) ((S) (Joker_)))) (((refl) (nat)) ((S) (b0)))) (((minus) (b0)) (O))) ((minus_n_O) (b0)))) (((minus) ((S) (b0))) (O))) ((minus_n_O) ((S) (b0))))) ((((sym_eq_minus) ((S) (b0))) (fun y : (nat) -> nat => forall n : nat, (((le) ((S) (n))) (b0)) -> (((eq) (nat)) ((y) ((S) (n)))) ((S) (((minus) (b0)) ((S) (n)))))) ((((((sym_eq_filter_nat_type_S) ((nat) -> nat)) (minus_body)) (b0)) (fun y : (nat) -> nat => forall n : nat, (((le) ((S) (n))) (b0)) -> (((eq) (nat)) ((y) ((S) (n)))) ((S) (((minus) (b0)) ((S) (n)))))) (fun a1 : nat => (((sym_eq_minus_body_S) (b0)) (fun y : (nat) -> nat => (((le) ((S) (a1))) (b0)) -> (((eq) (nat)) ((y) ((S) (a1)))) ((S) (((minus) (b0)) ((S) (a1)))))) (((((((sym_eq_match_nat_type_S) (nat)) ((S) (b0))) (fun q : nat => ((minus) (b0)) (q))) (a1)) (fun y : nat => (((le) ((S) (a1))) (b0)) -> (((eq) (nat)) (y)) ((S) (((minus) (b0)) ((S) (a1)))))) (fun lta1 : ((le) ((S) (a1))) (b0) => ((((((eq_ind_r) (nat)) ((pred) (((minus) (b0)) (a1)))) (fun x : nat => (((eq) (nat)) (((minus) (b0)) (a1))) ((S) (x)))) (((((((eq_ind_r) (nat)) (((minus) (b0)) (a1))) (fun x : nat => (((eq) (nat)) (((minus) (b0)) (a1))) (x))) (((refl) (nat)) (((minus) (b0)) (a1)))) ((S) ((pred) (((minus) (b0)) (a1))))) (((S_pred) (((minus) (b0)) (a1))) (((((lt_plus_to_minus_r) (O)) (a1)) (b0)) ((((sym_eq_plus) (O)) (fun y : (nat) -> nat => ((le) ((S) ((y) (a1)))) (b0))) (((((sym_eq_filter_nat_type_O) ((nat) -> nat)) (plus_body)) (fun y : (nat) -> nat => ((le) ((S) ((y) (a1)))) (b0))) (((sym_eq_plus_body_O) (fun y : (nat) -> nat => ((le) ((S) ((y) (a1)))) (b0))) (lta1)))))))) (((minus) (b0)) ((S) (a1)))) (((eq_minus_S_pred) (b0)) (a1)))))))) (a)) ((((le_S_S_to_le) (a)) (b0)) (Ha))))) (((((((bigop) (nat)) ((S) (b0))) (fun i : nat => ((andb) (((leb) (a)) (i))) ((p) (i)))) ((S) (O))) (times)) (fun i : nat => (f) (i)))) ((((((((bigop_Sfalse) (nat)) (b0)) (fun Joker_ : nat => ((andb) (((leb) (a)) (Joker_))) ((p) (Joker_)))) ((S) (O))) (times)) (f)) (((((((eq_ind_r) (bool)) (false)) (fun x : bool => (((eq) (bool)) (((andb) (((leb) (a)) (b0))) (x))) (false))) (((((match_bool_prop) (fun Joker_ : bool => (((eq) (bool)) (((andb) (Joker_)) (false))) (false))) ((((((eq_match_bool_type_true) (bool)) (false)) (false)) (fun y : bool => (((eq) (bool)) (((((match_bool_type) (bool)) (false)) (false)) (true))) (y))) (((refl) (bool)) (((andb) (true)) (false))))) ((((((eq_match_bool_type_false) (bool)) (false)) (false)) (fun y : bool => (((eq) (bool)) (((((match_bool_type) (bool)) (false)) (false)) (false))) (y))) (((refl) (bool)) (((andb) (false)) (false))))) (((leb) (a)) (b0)))) ((p) (b0))) (Hcase))))) ((true_or_false) ((p) (b0))))) (fun Ha : (((eq) (nat)) (a)) ((S) (b0)) => ((((((eq_ind) (nat)) (a)) (fun x_1 : nat => (((eq) (nat)) (((((((bigop) (nat)) (((minus) (x_1)) (a))) (fun i : nat => (p) (((plus) (i)) (a)))) ((S) (O))) (times)) (fun i : nat => (f) (((plus) (i)) (a))))) (((((((bigop) (nat)) (x_1)) (fun i : nat => ((andb) (((leb) (a)) (i))) ((p) (i)))) ((S) (O))) (times)) (fun i : nat => (f) (i))))) (((((((eq_ind) (nat)) (O)) (fun x_1 : nat => (((eq) (nat)) (((((((bigop) (nat)) (x_1)) (fun i : nat => (p) (((plus) (i)) (a)))) ((S) (O))) (times)) (fun i : nat => (f) (((plus) (i)) (a))))) (((((((bigop) (nat)) (a)) (fun i : nat => ((andb) (((leb) (a)) (i))) ((p) (i)))) ((S) (O))) (times)) (fun i : nat => (f) (i))))) ((((sym_eq_bigop_O) (nat)) (fun y : ((nat) -> bool) -> (nat) -> ((nat) -> (nat) -> nat) -> ((nat) -> nat) -> nat => (((eq) (nat)) (((((y) (fun i : nat => (p) (((plus) (i)) (a)))) ((S) (O))) (times)) (fun i : nat => (f) (((plus) (i)) (a))))) (((((((bigop) (nat)) (a)) (fun i : nat => ((andb) (((leb) (a)) (i))) ((p) (i)))) ((S) (O))) (times)) (fun i : nat => (f) (i))))) ((((sym_eq_bigop_body_O) (nat)) (fun y : ((nat) -> bool) -> (nat) -> ((nat) -> (nat) -> nat) -> ((nat) -> nat) -> nat => (((eq) (nat)) (((((y) (fun i : nat => (p) (((plus) (i)) (a)))) ((S) (O))) (times)) (fun i : nat => (f) (((plus) (i)) (a))))) (((((((bigop) (nat)) (a)) (fun i : nat => ((andb) (((leb) (a)) (i))) ((p) (i)))) ((S) (O))) (times)) (fun i : nat => (f) (i))))) (((((((eq_ind) (nat)) (((((((bigop) (nat)) (a)) (fun i : nat => false)) ((S) (O))) (times)) (fun i : nat => (f) (i)))) (fun x_1 : nat => (((eq) (nat)) (x_1)) (((((((bigop) (nat)) (a)) (fun i : nat => ((andb) (((leb) (a)) (i))) ((p) (i)))) ((S) (O))) (times)) (fun i : nat => (f) (i))))) (((((((((((same_bigop) (nat)) (a)) (fun Joker_ : nat => false)) (fun Joker_ : nat => ((andb) (((leb) (a)) (Joker_))) ((p) (Joker_)))) ((S) (O))) (times)) (f)) (f)) (fun i : nat => fun ltia : ((lt) (i)) (a) => ((((((eq_ind_r) (bool)) (false)) (fun x : bool => (((eq) (bool)) (false)) (((andb) (x)) ((p) (i))))) ((((((sym_eq_match_bool_type_false) (bool)) ((p) (i))) (false)) (fun y : bool => (((eq) (bool)) (false)) (y))) (((refl) (bool)) (false)))) (((leb) (a)) (i))) ((((not_le_to_leb_false) (a)) (i)) ((((lt_to_not_le) (i)) (a)) (ltia))))) (fun i : nat => fun auto : ((lt) (i)) (a) => fun auto' : (((eq) (bool)) (false)) (true) => ((refl) (nat)) ((f) (i))))) ((S) (O))) ((((((bigop_false) (nat)) (a)) ((S) (O))) (times)) (f)))))) (((minus) (a)) (a))) ((minus_n_n) (a)))) ((S) (b0))) (Ha))) ((((le_to_or_lt_eq) (a)) ((S) (b0))) (lea)))) (b).
Parameter ACop : forall A : Type, (A) -> Prop.
Axiom mk_ACop : forall A : Type, forall nil : A, forall op : (A) -> (A) -> A, (forall a : A, (((eq) (A)) (((op) (nil)) (a))) (a)) -> (forall a : A, (((eq) (A)) (((op) (a)) (nil))) (a)) -> (forall a : A, forall b : A, forall c : A, (((eq) (A)) (((op) (a)) (((op) (b)) (c)))) (((op) (((op) (a)) (b))) (c))) -> (forall a : A, forall b : A, (((eq) (A)) (((op) (a)) (b))) (((op) (b)) (a))) -> ((ACop) (A)) (nil).
Definition timesAC : ((ACop) (nat)) ((S) (O)) := (((((((mk_ACop) (nat)) ((S) (O))) (times)) (fun a : nat => (((sym_eq_times) ((S) (O))) (fun y : (nat) -> nat => (((eq) (nat)) ((y) (a))) (a))) ((((((sym_eq_filter_nat_type_S) ((nat) -> nat)) (times_body)) (O)) (fun y : (nat) -> nat => (((eq) (nat)) ((y) (a))) (a))) ((((sym_eq_times_body_S) (O)) (fun y : (nat) -> nat => (((eq) (nat)) ((y) (a))) (a))) ((((sym_eq_times) (O)) (fun y : (nat) -> nat => (((eq) (nat)) (((plus) (a)) ((y) (a)))) (a))) (((((sym_eq_filter_nat_type_O) ((nat) -> nat)) (times_body)) (fun y : (nat) -> nat => (((eq) (nat)) (((plus) (a)) ((y) (a)))) (a))) (((sym_eq_times_body_O) (fun y : (nat) -> nat => (((eq) (nat)) (((plus) (a)) ((y) (a)))) (a))) (((((sym_eq) (nat)) (a)) (((plus) (a)) (O))) ((plus_n_O) (a)))))))))) (fun n : nat => ((((sym_eq) (nat)) (n)) (((times) (n)) ((S) (O)))) ((times_n_1) (n)))) (fun a : nat => fun b : nat => fun c : nat => ((((sym_eq) (nat)) (((times) (((times) (a)) (b))) (c))) (((times) (a)) (((times) (b)) (c)))) ((((associative_times) (a)) (b)) (c)))) (commutative_times).
Definition bigop_diff : forall p : (nat) -> bool, forall f : (nat) -> nat, forall i : nat, forall n : nat, (((lt) (i)) (n)) -> ((((eq) (bool)) ((p) (i))) (true)) -> (((eq) (nat)) (((((((bigop) (nat)) (n)) (fun x : nat => (p) (x))) ((S) (O))) (times)) (fun x : nat => (f) (x)))) (((times) ((f) (i))) (((((((bigop) (nat)) (n)) (fun x : nat => ((andb) ((notb) (((eqb) (i)) (x)))) ((p) (x)))) ((S) (O))) (times)) (fun x : nat => (f) (x)))) := fun p : (nat) -> bool => fun f : (nat) -> nat => fun i : nat => fun n : nat => ((((nat_ind) (fun Jokerx_365 : nat => (((lt) (i)) (Jokerx_365)) -> ((((eq) (bool)) ((p) (i))) (true)) -> (((eq) (nat)) (((((((bigop) (nat)) (Jokerx_365)) (fun x : nat => (p) (x))) ((S) (O))) (times)) (fun x : nat => (f) (x)))) (((times) ((f) (i))) (((((((bigop) (nat)) (Jokerx_365)) (fun x : nat => ((andb) ((notb) (((eqb) (i)) (x)))) ((p) (x)))) ((S) (O))) (times)) (fun x : nat => (f) (x)))))) (fun ltO : ((lt) (i)) (O) => ((falsity) (((((eq) (bool)) ((p) (i))) (true)) -> (((eq) (nat)) (((((((bigop) (nat)) (O)) (fun x : nat => (p) (x))) ((S) (O))) (times)) (fun x : nat => (f) (x)))) (((times) ((f) (i))) (((((((bigop) (nat)) (O)) (fun x : nat => ((andb) ((notb) (((eqb) (i)) (x)))) ((p) (x)))) ((S) (O))) (times)) (fun x : nat => (f) (x)))))) ((((absurd) (((le) ((S) (i))) (O))) (ltO)) ((not_le_Sn_O) (i))))) (fun n0 : nat => fun Hind : (((lt) (i)) (n0)) -> ((((eq) (bool)) ((p) (i))) (true)) -> (((eq) (nat)) (((((((bigop) (nat)) (n0)) (fun x : nat => (p) (x))) ((S) (O))) (times)) (fun x : nat => (f) (x)))) (((times) ((f) (i))) (((((((bigop) (nat)) (n0)) (fun x : nat => ((andb) ((notb) (((eqb) (i)) (x)))) ((p) (x)))) ((S) (O))) (times)) (fun x : nat => (f) (x)))) => fun lein : ((lt) (i)) ((S) (n0)) => fun pi : (((eq) (bool)) ((p) (i))) (true) => ((((((match_Or_prop) (((lt) (i)) (n0))) ((((eq) (nat)) (i)) (n0))) ((((eq) (nat)) (((((((bigop) (nat)) ((S) (n0))) (fun x : nat => (p) (x))) ((S) (O))) (times)) (fun x : nat => (f) (x)))) (((times) ((f) (i))) (((((((bigop) (nat)) ((S) (n0))) (fun x : nat => ((andb) ((notb) (((eqb) (i)) (x)))) ((p) (x)))) ((S) (O))) (times)) (fun x : nat => (f) (x)))))) (fun Hi : ((lt) (i)) (n0) => ((((((match_Or_prop) ((((eq) (bool)) ((p) (n0))) (true))) ((((eq) (bool)) ((p) (n0))) (false))) ((((eq) (nat)) (((((((bigop) (nat)) ((S) (n0))) (fun x : nat => (p) (x))) ((S) (O))) (times)) (fun x : nat => (f) (x)))) (((times) ((f) (i))) (((((((bigop) (nat)) ((S) (n0))) (fun x : nat => ((andb) ((notb) (((eqb) (i)) (x)))) ((p) (x)))) ((S) (O))) (times)) (fun x : nat => (f) (x)))))) (fun pn : (((eq) (bool)) ((p) (n0))) (true) => ((((((eq_ind_r) (nat)) (((times) ((f) (n0))) (((((((bigop) (nat)) (n0)) (fun i0 : nat => (p) (i0))) ((S) (O))) (times)) (fun i0 : nat => (f) (i0))))) (fun x : nat => (((eq) (nat)) (x)) (((times) ((f) (i))) (((((((bigop) (nat)) ((S) (n0))) (fun x0 : nat => ((andb) ((notb) (((eqb) (i)) (x0)))) ((p) (x0)))) ((S) (O))) (times)) (fun x0 : nat => (f) (x0)))))) (((((((eq_ind_r) (nat)) (((times) ((f) (n0))) (((((((bigop) (nat)) (n0)) (fun i0 : nat => ((andb) ((notb) (((eqb) (i)) (i0)))) ((p) (i0)))) ((S) (O))) (times)) (fun i0 : nat => (f) (i0))))) (fun x : nat => (((eq) (nat)) (((times) ((f) (n0))) (((((((bigop) (nat)) (n0)) (fun i0 : nat => (p) (i0))) ((S) (O))) (times)) (fun i0 : nat => (f) (i0))))) (((times) ((f) (i))) (x)))) (((((((eq_ind_r) (nat)) (((times) (((times) ((f) (i))) ((f) (n0)))) (((((((bigop) (nat)) (n0)) (fun i0 : nat => ((((match_bool_type) (bool)) ((p) (i0))) (false)) (((((match_bool_type) (bool)) (false)) (true)) (((eqb) (i)) (i0))))) ((S) (O))) (times)) (fun i0 : nat => (f) (i0))))) (fun x : nat => (((eq) (nat)) (((times) ((f) (n0))) (((((((bigop) (nat)) (n0)) (fun i0 : nat => (p) (i0))) ((S) (O))) (times)) (fun i0 : nat => (f) (i0))))) (x))) (((((((eq_ind_r) (nat)) (((times) ((f) (n0))) ((f) (i)))) (fun x : nat => (((eq) (nat)) (((times) ((f) (n0))) (((((((bigop) (nat)) (n0)) (fun i0 : nat => (p) (i0))) ((S) (O))) (times)) (fun i0 : nat => (f) (i0))))) (((times) (x)) (((((((bigop) (nat)) (n0)) (fun i0 : nat => ((((match_bool_type) (bool)) ((p) (i0))) (false)) (((((match_bool_type) (bool)) (false)) (true)) (((eqb) (i)) (i0))))) ((S) (O))) (times)) (fun i0 : nat => (f) (i0)))))) (((((((eq_ind) (nat)) (((times) ((f) (n0))) (((times) ((f) (i))) (((((((bigop) (nat)) (n0)) (fun i0 : nat => ((((match_bool_type) (bool)) ((p) (i0))) (false)) (((((match_bool_type) (bool)) (false)) (true)) (((eqb) (i)) (i0))))) ((S) (O))) (times)) (fun i0 : nat => (f) (i0)))))) (fun x_1 : nat => (((eq) (nat)) (((times) ((f) (n0))) (((((((bigop) (nat)) (n0)) (fun i0 : nat => (p) (i0))) ((S) (O))) (times)) (fun i0 : nat => (f) (i0))))) (x_1))) (((((((eq_ind_r) (nat)) (((times) ((f) (i))) (((((((bigop) (nat)) (n0)) (fun x : nat => ((andb) ((notb) (((eqb) (i)) (x)))) ((p) (x)))) ((S) (O))) (times)) (fun x : nat => (f) (x))))) (fun x : nat => (((eq) (nat)) (((times) ((f) (n0))) (x))) (((times) ((f) (n0))) (((times) ((f) (i))) (((((((bigop) (nat)) (n0)) (fun i0 : nat => ((((match_bool_type) (bool)) ((p) (i0))) (false)) (((((match_bool_type) (bool)) (false)) (true)) (((eqb) (i)) (i0))))) ((S) (O))) (times)) (fun i0 : nat => (f) (i0))))))) (((refl) (nat)) (((times) ((f) (n0))) (((times) ((f) (i))) (((((((bigop) (nat)) (n0)) (fun x : nat => ((andb) ((notb) (((eqb) (i)) (x)))) ((p) (x)))) ((S) (O))) (times)) (fun x : nat => (f) (x))))))) (((((((bigop) (nat)) (n0)) (fun x : nat => (p) (x))) ((S) (O))) (times)) (fun x : nat => (f) (x)))) (((Hind) (Hi)) (((((((rewrite_r) (bool)) (true)) (fun Joker_ : bool => (((eq) (bool)) (Joker_)) (true))) (((refl) (bool)) (true))) ((p) (i))) (pi))))) (((times) (((times) ((f) (n0))) ((f) (i)))) (((((((bigop) (nat)) (n0)) (fun i0 : nat => ((((match_bool_type) (bool)) ((p) (i0))) (false)) (((((match_bool_type) (bool)) (false)) (true)) (((eqb) (i)) (i0))))) ((S) (O))) (times)) (fun i0 : nat => (f) (i0))))) ((((assoc) ((f) (n0))) ((f) (i))) (((((((bigop) (nat)) (n0)) (fun i0 : nat => ((((match_bool_type) (bool)) ((p) (i0))) (false)) (((((match_bool_type) (bool)) (false)) (true)) (((eqb) (i)) (i0))))) ((S) (O))) (times)) (fun i0 : nat => (f) (i0)))))) (((times) ((f) (i))) ((f) (n0)))) (((commutative_times) ((f) (i))) ((f) (n0))))) (((times) ((f) (i))) (((times) ((f) (n0))) (((((((bigop) (nat)) (n0)) (fun i0 : nat => ((((match_bool_type) (bool)) ((p) (i0))) (false)) (((((match_bool_type) (bool)) (false)) (true)) (((eqb) (i)) (i0))))) ((S) (O))) (times)) (fun i0 : nat => (f) (i0)))))) ((((assoc) ((f) (i))) ((f) (n0))) (((((((bigop) (nat)) (n0)) (fun i0 : nat => ((((match_bool_type) (bool)) ((p) (i0))) (false)) (((((match_bool_type) (bool)) (false)) (true)) (((eqb) (i)) (i0))))) ((S) (O))) (times)) (fun i0 : nat => (f) (i0)))))) (((((((bigop) (nat)) ((S) (n0))) (fun i0 : nat => ((andb) ((notb) (((eqb) (i)) (i0)))) ((p) (i0)))) ((S) (O))) (times)) (fun i0 : nat => (f) (i0)))) ((((((((bigop_Strue) (nat)) (n0)) (fun Joker_ : nat => ((andb) ((notb) (((eqb) (i)) (Joker_)))) ((p) (Joker_)))) ((S) (O))) (times)) (f)) (((((((rewrite_r) (bool)) (true)) (fun Joker_ : bool => (((eq) (bool)) (((andb) ((notb) (((eqb) (i)) (n0)))) (Joker_))) (true))) (((((((rewrite_r) (bool)) (true)) (fun Joker_ : bool => (((eq) (bool)) (Joker_)) (true))) (((refl) (bool)) (true))) (((andb) ((notb) (((eqb) (i)) (n0)))) (true))) (((((((rewrite_l) (bool)) ((p) (n0))) (fun Joker_ : bool => (((eq) (bool)) (((andb) ((notb) (((eqb) (i)) (n0)))) (true))) (Joker_))) (((((((rewrite_l) (bool)) ((p) (n0))) (fun Joker_ : bool => (((eq) (bool)) (((andb) ((notb) (((eqb) (i)) (n0)))) (Joker_))) ((p) (n0)))) (((((((eq_ind_r) (bool)) (false)) (fun x : bool => (((eq) (bool)) (((andb) ((notb) (x))) ((p) (n0)))) ((p) (n0)))) ((((((sym_eq_match_bool_type_false) (bool)) (false)) (true)) (fun y : bool => (((eq) (bool)) (((((match_bool_type) (bool)) ((p) (n0))) (false)) (y))) ((p) (n0)))) ((((((eq_match_bool_type_true) (bool)) ((p) (n0))) (false)) (fun y : bool => (((eq) (bool)) (((((match_bool_type) (bool)) ((p) (n0))) (false)) (true))) (y))) ((((((eq_match_bool_type_false) (bool)) (false)) (true)) (fun y : bool => (((eq) (bool)) (((((match_bool_type) (bool)) ((p) (n0))) (false)) (true))) (((((match_bool_type) (bool)) ((p) (n0))) (false)) (y)))) ((((((eq_match_bool_type_false) (bool)) (false)) (true)) (fun y : bool => (((eq) (bool)) (((((match_bool_type) (bool)) ((p) (n0))) (false)) (y))) (((((match_bool_type) (bool)) ((p) (n0))) (false)) (((((match_bool_type) (bool)) (false)) (true)) (false))))) (((refl) (bool)) (((andb) ((notb) (false))) ((p) (n0))))))))) (((eqb) (i)) (n0))) ((((not_eq_to_eqb_false) (i)) (n0)) ((((lt_to_not_eq) (i)) (n0)) (Hi))))) (true)) (pn))) (true)) (pn)))) ((p) (n0))) (pn))))) (((((((bigop) (nat)) ((S) (n0))) (fun i0 : nat => (p) (i0))) ((S) (O))) (times)) (fun i0 : nat => (f) (i0)))) ((((((((bigop_Strue) (nat)) (n0)) (p)) ((S) (O))) (times)) (f)) (((((((rewrite_r) (bool)) (true)) (fun Joker_ : bool => (((eq) (bool)) (Joker_)) (true))) (((refl) (bool)) (true))) ((p) (n0))) (pn))))) (fun pn : (((eq) (bool)) ((p) (n0))) (false) => ((((((eq_ind_r) (nat)) (((((((bigop) (nat)) (n0)) (fun i0 : nat => (p) (i0))) ((S) (O))) (times)) (fun i0 : nat => (f) (i0)))) (fun x : nat => (((eq) (nat)) (x)) (((times) ((f) (i))) (((((((bigop) (nat)) ((S) (n0))) (fun x0 : nat => ((andb) ((notb) (((eqb) (i)) (x0)))) ((p) (x0)))) ((S) (O))) (times)) (fun x0 : nat => (f) (x0)))))) (((((((eq_ind_r) (nat)) (((((((bigop) (nat)) (n0)) (fun i0 : nat => ((andb) ((notb) (((eqb) (i)) (i0)))) ((p) (i0)))) ((S) (O))) (times)) (fun i0 : nat => (f) (i0)))) (fun x : nat => (((eq) (nat)) (((((((bigop) (nat)) (n0)) (fun i0 : nat => (p) (i0))) ((S) (O))) (times)) (fun i0 : nat => (f) (i0)))) (((times) ((f) (i))) (x)))) (((((((eq_ind_r) (nat)) (((times) ((f) (i))) (((((((bigop) (nat)) (n0)) (fun x : nat => ((andb) ((notb) (((eqb) (i)) (x)))) ((p) (x)))) ((S) (O))) (times)) (fun x : nat => (f) (x))))) (fun x : nat => (((eq) (nat)) (x)) (((times) ((f) (i))) (((((((bigop) (nat)) (n0)) (fun i0 : nat => ((andb) ((notb) (((eqb) (i)) (i0)))) ((p) (i0)))) ((S) (O))) (times)) (fun i0 : nat => (f) (i0)))))) (((refl) (nat)) (((times) ((f) (i))) (((((((bigop) (nat)) (n0)) (fun x : nat => ((andb) ((notb) (((eqb) (i)) (x)))) ((p) (x)))) ((S) (O))) (times)) (fun x : nat => (f) (x)))))) (((((((bigop) (nat)) (n0)) (fun x : nat => (p) (x))) ((S) (O))) (times)) (fun x : nat => (f) (x)))) (((Hind) (Hi)) (((((((rewrite_r) (bool)) (true)) (fun Joker_ : bool => (((eq) (bool)) (Joker_)) (true))) (((refl) (bool)) (true))) ((p) (i))) (pi))))) (((((((bigop) (nat)) ((S) (n0))) (fun i0 : nat => ((andb) ((notb) (((eqb) (i)) (i0)))) ((p) (i0)))) ((S) (O))) (times)) (fun i0 : nat => (f) (i0)))) ((((((((bigop_Sfalse) (nat)) (n0)) (fun Joker_ : nat => ((andb) ((notb) (((eqb) (i)) (Joker_)))) ((p) (Joker_)))) ((S) (O))) (times)) (f)) (((((((rewrite_r) (bool)) (false)) (fun Joker_ : bool => (((eq) (bool)) (((andb) ((notb) (((eqb) (i)) (n0)))) (Joker_))) (false))) (((((((rewrite_r) (bool)) (false)) (fun Joker_ : bool => (((eq) (bool)) (Joker_)) (false))) (((refl) (bool)) (false))) (((andb) ((notb) (((eqb) (i)) (n0)))) (false))) (((((((rewrite_l) (bool)) ((p) (n0))) (fun Joker_ : bool => (((eq) (bool)) (((andb) ((notb) (((eqb) (i)) (n0)))) (false))) (Joker_))) (((((((rewrite_l) (bool)) ((p) (n0))) (fun Joker_ : bool => (((eq) (bool)) (((andb) ((notb) (((eqb) (i)) (n0)))) (Joker_))) ((p) (n0)))) (((((((eq_ind_r) (bool)) (false)) (fun x : bool => (((eq) (bool)) (((andb) ((notb) (x))) ((p) (n0)))) ((p) (n0)))) ((((((sym_eq_match_bool_type_false) (bool)) (false)) (true)) (fun y : bool => (((eq) (bool)) (((((match_bool_type) (bool)) ((p) (n0))) (false)) (y))) ((p) (n0)))) ((((((eq_match_bool_type_true) (bool)) ((p) (n0))) (false)) (fun y : bool => (((eq) (bool)) (((((match_bool_type) (bool)) ((p) (n0))) (false)) (true))) (y))) ((((((eq_match_bool_type_false) (bool)) (false)) (true)) (fun y : bool => (((eq) (bool)) (((((match_bool_type) (bool)) ((p) (n0))) (false)) (true))) (((((match_bool_type) (bool)) ((p) (n0))) (false)) (y)))) ((((((eq_match_bool_type_false) (bool)) (false)) (true)) (fun y : bool => (((eq) (bool)) (((((match_bool_type) (bool)) ((p) (n0))) (false)) (y))) (((((match_bool_type) (bool)) ((p) (n0))) (false)) (((((match_bool_type) (bool)) (false)) (true)) (false))))) (((refl) (bool)) (((andb) ((notb) (false))) ((p) (n0))))))))) (((eqb) (i)) (n0))) ((((not_eq_to_eqb_false) (i)) (n0)) ((((lt_to_not_eq) (i)) (n0)) (Hi))))) (false)) (pn))) (false)) (pn)))) ((p) (n0))) (pn))))) (((((((bigop) (nat)) ((S) (n0))) (fun i0 : nat => (p) (i0))) ((S) (O))) (times)) (fun i0 : nat => (f) (i0)))) ((((((((bigop_Sfalse) (nat)) (n0)) (p)) ((S) (O))) (times)) (f)) (((((((rewrite_r) (bool)) (false)) (fun Joker_ : bool => (((eq) (bool)) (Joker_)) (false))) (((refl) (bool)) (false))) ((p) (n0))) (pn))))) ((true_or_false) ((p) (n0))))) (fun Hi : (((eq) (nat)) (i)) (n0) => ((((((eq_ind) (nat)) (i)) (fun x_1 : nat => (((eq) (nat)) (((((((bigop) (nat)) ((S) (x_1))) (fun x : nat => (p) (x))) ((S) (O))) (times)) (fun x : nat => (f) (x)))) (((times) ((f) (i))) (((((((bigop) (nat)) ((S) (x_1))) (fun x : nat => ((andb) ((notb) (((eqb) (i)) (x)))) ((p) (x)))) ((S) (O))) (times)) (fun x : nat => (f) (x)))))) (((((((eq_ind_r) (nat)) (((times) ((f) (i))) (((((((bigop) (nat)) (i)) (fun i0 : nat => (p) (i0))) ((S) (O))) (times)) (fun i0 : nat => (f) (i0))))) (fun x : nat => (((eq) (nat)) (x)) (((times) ((f) (i))) (((((((bigop) (nat)) ((S) (i))) (fun x0 : nat => ((andb) ((notb) (((eqb) (i)) (x0)))) ((p) (x0)))) ((S) (O))) (times)) (fun x0 : nat => (f) (x0)))))) (((((((eq_f) (nat)) (nat)) ((times) ((f) (i)))) (((((((bigop) (nat)) (i)) (fun i0 : nat => (p) (i0))) ((S) (O))) (times)) (fun i0 : nat => (f) (i0)))) (((((((bigop) (nat)) ((S) (i))) (fun x : nat => ((andb) ((notb) (((eqb) (i)) (x)))) ((p) (x)))) ((S) (O))) (times)) (fun x : nat => (f) (x)))) (((((((eq_ind_r) (nat)) (((((((bigop) (nat)) (i)) (fun i0 : nat => ((andb) ((notb) (((eqb) (i)) (i0)))) ((p) (i0)))) ((S) (O))) (times)) (fun i0 : nat => (f) (i0)))) (fun x : nat => (((eq) (nat)) (((((((bigop) (nat)) (i)) (fun i0 : nat => (p) (i0))) ((S) (O))) (times)) (fun i0 : nat => (f) (i0)))) (x))) (((((((((((same_bigop) (nat)) (i)) (p)) (fun Joker_ : nat => ((andb) ((notb) (((eqb) (i)) (Joker_)))) ((p) (Joker_)))) ((S) (O))) (times)) (f)) (f)) (fun k : nat => fun ltki : ((lt) (k)) (i) => ((((((eq_ind_r) (bool)) (false)) (fun x : bool => (((eq) (bool)) ((p) (k))) (((andb) ((notb) (x))) ((p) (k))))) ((((((sym_eq_match_bool_type_false) (bool)) (false)) (true)) (fun y : bool => (((eq) (bool)) ((p) (k))) (((((match_bool_type) (bool)) ((p) (k))) (false)) (y)))) ((((((sym_eq_match_bool_type_true) (bool)) ((p) (k))) (false)) (fun y : bool => (((eq) (bool)) ((p) (k))) (y))) (((refl) (bool)) ((p) (k)))))) (((eqb) (i)) (k))) ((((not_eq_to_eqb_false) (i)) (k)) (((((not_to_not) ((((eq) (nat)) (i)) (k))) (((le) ((S) (i))) (i))) (fun auto : (((eq) (nat)) (i)) (k) => ((((eq_coerc) (((le) ((S) (k))) (i))) (((le) ((S) (i))) (i))) (ltki)) (((((((rewrite_l) (nat)) (i)) (fun Joker_ : nat => (((eq) Prop) (((le) ((S) (Joker_))) (i))) (((le) ((S) (i))) (i)))) (((refl) Prop) (((le) ((S) (i))) (i)))) (k)) (auto)))) ((not_le_Sn_n) (i)))))) (fun i0 : nat => fun auto : ((lt) (i0)) (i) => fun auto' : (((eq) (bool)) ((p) (i0))) (true) => ((refl) (nat)) ((f) (i0))))) (((((((bigop) (nat)) ((S) (i))) (fun i0 : nat => ((andb) ((notb) (((eqb) (i)) (i0)))) ((p) (i0)))) ((S) (O))) (times)) (fun i0 : nat => (f) (i0)))) ((((((((bigop_Sfalse) (nat)) (i)) (fun Joker_ : nat => ((andb) ((notb) (((eqb) (i)) (Joker_)))) ((p) (Joker_)))) ((S) (O))) (times)) (f)) (((((((eq_ind_r) (bool)) (true)) (fun x : bool => (((eq) (bool)) (((andb) ((notb) (x))) ((p) (i)))) (false))) ((((((eq_match_bool_type_false) (bool)) ((p) (i))) (false)) (fun y : bool => (((eq) (bool)) (((((match_bool_type) (bool)) ((p) (i))) (false)) (((((match_bool_type) (bool)) (false)) (true)) (true)))) (y))) ((((((eq_match_bool_type_true) (bool)) (false)) (true)) (fun y : bool => (((eq) (bool)) (((((match_bool_type) (bool)) ((p) (i))) (false)) (((((match_bool_type) (bool)) (false)) (true)) (true)))) (((((match_bool_type) (bool)) ((p) (i))) (false)) (y)))) (((refl) (bool)) (((andb) ((notb) (true))) ((p) (i))))))) (((eqb) (i)) (i))) ((((eq_to_eqb_true) (i)) (i)) (((refl) (nat)) (i)))))))) (((((((bigop) (nat)) ((S) (i))) (fun i0 : nat => (p) (i0))) ((S) (O))) (times)) (fun i0 : nat => (f) (i0)))) ((((((((bigop_Strue) (nat)) (i)) (p)) ((S) (O))) (times)) (f)) (((((((rewrite_r) (bool)) (true)) (fun Joker_ : bool => (((eq) (bool)) (Joker_)) (true))) (((refl) (bool)) (true))) ((p) (i))) (pi))))) (n0)) (Hi))) ((((le_to_or_lt_eq) (i)) (n0)) ((((le_S_S_to_le) (i)) (n0)) (lein))))) (n).
Definition sub_hk : ((nat) -> nat) -> ((nat) -> nat) -> (nat) -> (nat) -> ((nat) -> bool) -> ((nat) -> bool) -> ((nat) -> nat) -> ((nat) -> nat) -> Prop := fun h : (nat) -> nat => fun k : (nat) -> nat => fun n1 : nat => fun n2 : nat => fun p1 : (nat) -> bool => fun p2 : (nat) -> bool => fun f1 : (nat) -> nat => fun f2 : (nat) -> nat => forall i : nat, (((lt) (i)) (n1)) -> ((((eq) (bool)) ((p1) (i))) (true)) -> ((And) (((And) (((lt) ((h) (i))) (n2))) ((((eq) (bool)) ((p2) ((h) (i)))) (true)))) ((((eq) (nat)) ((k) ((h) (i)))) (i)).
Definition iso : (nat) -> (nat) -> ((nat) -> bool) -> ((nat) -> bool) -> ((nat) -> nat) -> ((nat) -> nat) -> Prop := fun n1 : nat => fun n2 : nat => fun p1 : (nat) -> bool => fun p2 : (nat) -> bool => fun f1 : (nat) -> nat => fun f2 : (nat) -> nat => ((Ex) ((nat) -> nat)) (fun h : (nat) -> nat => ((Ex) ((nat) -> nat)) (fun k : (nat) -> nat => ((And) (((And) (forall i : nat, (((lt) (i)) (n1)) -> ((((eq) (bool)) ((p1) (i))) (true)) -> (((eq) (nat)) ((f1) (i))) ((f2) ((h) (i))))) (((((((((sub_hk) (h)) (k)) (n1)) (n2)) (p1)) (p2)) (f1)) (f2)))) (((((((((sub_hk) (k)) (h)) (n2)) (n1)) (p2)) (p1)) (f2)) (f1)))).
Definition sub_hkO : forall h : (nat) -> nat, forall k : (nat) -> nat, forall n1 : nat, forall n2 : nat, forall p1 : (nat) -> bool, forall p2 : (nat) -> bool, forall f1 : (nat) -> nat, forall f2 : (nat) -> nat, ((((eq) (nat)) (n1)) (O)) -> ((((((((sub_hk) (h)) (k)) (n1)) (n2)) (p1)) (p2)) (f1)) (f2) := fun h : (nat) -> nat => fun k : (nat) -> nat => fun n1 : nat => fun n2 : nat => fun p1 : (nat) -> bool => fun p2 : (nat) -> bool => fun f1 : (nat) -> nat => fun f2 : (nat) -> nat => fun up0 : (((eq) (nat)) (n1)) (O) => fun i : nat => fun lti : ((lt) (i)) (n1) => ((((((eq_ind_r) (nat)) (O)) (fun x : nat => ((((eq) (bool)) ((p1) (i))) (true)) -> ((And) (((And) (((lt) ((h) (i))) (n2))) ((((eq) (bool)) ((p2) ((h) (i)))) (true)))) ((((eq) (nat)) ((k) ((h) (i)))) (i)))) (((falsity) (((((eq) (bool)) ((p1) (i))) (true)) -> ((And) (((And) (((lt) ((h) (i))) (n2))) ((((eq) (bool)) ((p2) ((h) (i)))) (true)))) ((((eq) (nat)) ((k) ((h) (i)))) (i)))) ((((absurd) (((le) ((S) (i))) (O))) (((((eq_coerc) (((le) ((S) (i))) (n1))) (((le) ((S) (i))) (O))) (lti)) (((((((rewrite_r) (nat)) (O)) (fun Joker_ : nat => (((eq) Prop) (((le) ((S) (i))) (Joker_))) (((le) ((S) (i))) (O)))) (((refl) Prop) (((le) ((S) (i))) (O)))) (n1)) (up0)))) ((not_le_Sn_O) (i))))) (n1)) (up0).
Definition sub0_to_false : forall h : (nat) -> nat, forall k : (nat) -> nat, forall n1 : nat, forall n2 : nat, forall p1 : (nat) -> bool, forall p2 : (nat) -> bool, forall f1 : (nat) -> nat, forall f2 : (nat) -> nat, ((((eq) (nat)) (n1)) (O)) -> (((((((((sub_hk) (h)) (k)) (n2)) (n1)) (p2)) (p1)) (f2)) (f1)) -> forall i : nat, (((lt) (i)) (n2)) -> (((eq) (bool)) ((p2) (i))) (false) := fun h : (nat) -> nat => fun k : (nat) -> nat => fun n1 : nat => fun n2 : nat => fun p1 : (nat) -> bool => fun p2 : (nat) -> bool => fun f1 : (nat) -> nat => fun f2 : (nat) -> nat => fun up0 : (((eq) (nat)) (n1)) (O) => fun sub : ((((((((sub_hk) (h)) (k)) (n2)) (n1)) (p2)) (p1)) (f2)) (f1) => fun i : nat => fun lti : ((lt) (i)) (n2) => ((((((match_Or_prop) ((((eq) (bool)) ((p2) (i))) (true))) ((((eq) (bool)) ((p2) (i))) (false))) ((((eq) (bool)) ((p2) (i))) (false))) (fun ptrue : (((eq) (bool)) ((p2) (i))) (true) => (((((match_And_prop) (((And) (((lt) ((h) (i))) (n1))) ((((eq) (bool)) ((p1) ((h) (i)))) (true)))) ((((eq) (nat)) ((k) ((h) (i)))) (i))) ((((eq) (bool)) ((p2) (i))) (false))) (fun Jokerclearme : ((And) (((lt) ((h) (i))) (n1))) ((((eq) (bool)) ((p1) ((h) (i)))) (true)) => (((((match_And_prop) (((lt) ((h) (i))) (n1))) ((((eq) (bool)) ((p1) ((h) (i)))) (true))) (((((eq) (nat)) ((k) ((h) (i)))) (i)) -> (((eq) (bool)) ((p2) (i))) (false))) (fun hi : ((lt) ((h) (i))) (n1) => ((falsity) (((((eq) (bool)) ((p1) ((h) (i)))) (true)) -> ((((eq) (nat)) ((k) ((h) (i)))) (i)) -> (((eq) (bool)) ((p2) (i))) (false))) ((((absurd) (((le) ((S) ((h) (i)))) (O))) (((((eq_coerc) (((le) ((S) ((h) (i)))) (n1))) (((le) ((S) ((h) (i)))) (O))) (hi)) (((((((rewrite_r) (nat)) (O)) (fun Joker_ : nat => (((eq) Prop) (((le) ((S) ((h) (i)))) (Joker_))) (((le) ((S) ((h) (i)))) (O)))) (((refl) Prop) (((le) ((S) ((h) (i)))) (O)))) (n1)) (up0)))) ((not_le_Sn_O) ((h) (i)))))) (Jokerclearme))) ((((sub) (i)) (lti)) (ptrue)))) (fun auto : (((eq) (bool)) ((p2) (i))) (false) => ((((((rewrite_r) (bool)) (false)) (fun Joker_ : bool => (((eq) (bool)) (Joker_)) (false))) (((refl) (bool)) (false))) ((p2) (i))) (auto))) ((true_or_false) ((p2) (i))).
Definition sub_lt : forall e : (nat) -> nat, forall p : (nat) -> bool, forall n : nat, forall m : nat, (((le) (n)) (m)) -> ((((((((sub_hk) (fun x : nat => x)) (fun x : nat => x)) (n)) (m)) (p)) (p)) (e)) (e) := fun e : (nat) -> nat => fun f : (nat) -> bool => fun n : nat => fun m : nat => fun lenm : ((le) (n)) (m) => fun i : nat => fun lti : ((lt) (i)) (n) => fun fi : (((eq) (bool)) ((f) (i))) (true) => fun z : Prop => fun f1 : (((And) (((lt) (i)) (m))) ((((eq) (bool)) ((f) (i))) (true))) -> ((((eq) (nat)) (i)) (i)) -> z => ((f1) (fun z0 : Prop => fun f2 : (((lt) (i)) (m)) -> ((((eq) (bool)) ((f) (i))) (true)) -> z0 => ((f2) ((((((lt_to_le_to_lt) (i)) (n)) (m)) (lti)) (lenm))) (((((((rewrite_r) (bool)) (true)) (fun Joker_ : bool => (((eq) (bool)) (Joker_)) (true))) (((refl) (bool)) (true))) ((f) (i))) (fi)))) (((refl) (nat)) (i)).
Definition transitive_sub : forall h1 : (nat) -> nat, forall k1 : (nat) -> nat, forall h2 : (nat) -> nat, forall k2 : (nat) -> nat, forall n1 : nat, forall n2 : nat, forall n3 : nat, forall p1 : (nat) -> bool, forall p2 : (nat) -> bool, forall p3 : (nat) -> bool, forall f1 : (nat) -> nat, forall f2 : (nat) -> nat, forall f3 : (nat) -> nat, (((((((((sub_hk) (h1)) (k1)) (n1)) (n2)) (p1)) (p2)) (f1)) (f2)) -> (((((((((sub_hk) (h2)) (k2)) (n2)) (n3)) (p2)) (p3)) (f2)) (f3)) -> ((((((((sub_hk) (fun x : nat => (h2) ((h1) (x)))) (fun x : nat => (k1) ((k2) (x)))) (n1)) (n3)) (p1)) (p3)) (f1)) (f3) := fun h1 : (nat) -> nat => fun k1 : (nat) -> nat => fun h2 : (nat) -> nat => fun k2 : (nat) -> nat => fun n1 : nat => fun n2 : nat => fun n3 : nat => fun p1 : (nat) -> bool => fun p2 : (nat) -> bool => fun p3 : (nat) -> bool => fun f1 : (nat) -> nat => fun f2 : (nat) -> nat => fun f3 : (nat) -> nat => fun sub1 : ((((((((sub_hk) (h1)) (k1)) (n1)) (n2)) (p1)) (p2)) (f1)) (f2) => fun sub2 : ((((((((sub_hk) (h2)) (k2)) (n2)) (n3)) (p2)) (p3)) (f2)) (f3) => fun i : nat => fun lti : ((lt) (i)) (n1) => fun fi : (((eq) (bool)) ((p1) (i))) (true) => (((((match_And_prop) (((And) (((lt) ((h1) (i))) (n2))) ((((eq) (bool)) ((p2) ((h1) (i)))) (true)))) ((((eq) (nat)) ((k1) ((h1) (i)))) (i))) (((And) (((And) (((lt) ((h2) ((h1) (i)))) (n3))) ((((eq) (bool)) ((p3) ((h2) ((h1) (i))))) (true)))) ((((eq) (nat)) ((k1) ((k2) ((h2) ((h1) (i)))))) (i)))) (fun Jokerclearme : ((And) (((lt) ((h1) (i))) (n2))) ((((eq) (bool)) ((p2) ((h1) (i)))) (true)) => (((((match_And_prop) (((lt) ((h1) (i))) (n2))) ((((eq) (bool)) ((p2) ((h1) (i)))) (true))) (((((eq) (nat)) ((k1) ((h1) (i)))) (i)) -> ((And) (((And) (((lt) ((h2) ((h1) (i)))) (n3))) ((((eq) (bool)) ((p3) ((h2) ((h1) (i))))) (true)))) ((((eq) (nat)) ((k1) ((k2) ((h2) ((h1) (i)))))) (i)))) (fun lth1i : ((lt) ((h1) (i))) (n2) => fun fh1i : (((eq) (bool)) ((p2) ((h1) (i)))) (true) => fun ei : (((eq) (nat)) ((k1) ((h1) (i)))) (i) => (((((match_And_prop) (((And) (((lt) ((h2) ((h1) (i)))) (n3))) ((((eq) (bool)) ((p3) ((h2) ((h1) (i))))) (true)))) ((((eq) (nat)) ((k2) ((h2) ((h1) (i))))) ((h1) (i)))) (((And) (((And) (((lt) ((h2) ((h1) (i)))) (n3))) ((((eq) (bool)) ((p3) ((h2) ((h1) (i))))) (true)))) ((((eq) (nat)) ((k1) ((k2) ((h2) ((h1) (i)))))) (i)))) (fun Jokerclearme0 : ((And) (((lt) ((h2) ((h1) (i)))) (n3))) ((((eq) (bool)) ((p3) ((h2) ((h1) (i))))) (true)) => (((((match_And_prop) (((lt) ((h2) ((h1) (i)))) (n3))) ((((eq) (bool)) ((p3) ((h2) ((h1) (i))))) (true))) (((((eq) (nat)) ((k2) ((h2) ((h1) (i))))) ((h1) (i))) -> ((And) (((And) (((lt) ((h2) ((h1) (i)))) (n3))) ((((eq) (bool)) ((p3) ((h2) ((h1) (i))))) (true)))) ((((eq) (nat)) ((k1) ((k2) ((h2) ((h1) (i)))))) (i)))) (fun H1 : ((lt) ((h2) ((h1) (i)))) (n3) => fun H2 : (((eq) (bool)) ((p3) ((h2) ((h1) (i))))) (true) => fun H3 : (((eq) (nat)) ((k2) ((h2) ((h1) (i))))) ((h1) (i)) => fun z : Prop => fun f : (((And) (((lt) ((h2) ((h1) (i)))) (n3))) ((((eq) (bool)) ((p3) ((h2) ((h1) (i))))) (true))) -> ((((eq) (nat)) ((k1) ((k2) ((h2) ((h1) (i)))))) (i)) -> z => ((f) (fun z0 : Prop => fun f20 : (((lt) ((h2) ((h1) (i)))) (n3)) -> ((((eq) (bool)) ((p3) ((h2) ((h1) (i))))) (true)) -> z0 => ((f20) (H1)) (((((((rewrite_r) (bool)) (true)) (fun Joker_ : bool => (((eq) (bool)) (Joker_)) (true))) (((refl) (bool)) (true))) ((p3) ((h2) ((h1) (i))))) (H2)))) (((((((rewrite_r) (nat)) ((h1) (i))) (fun Joker_ : nat => (((eq) (nat)) ((k1) (Joker_))) (i))) (((((((rewrite_r) (nat)) (i)) (fun Joker_ : nat => (((eq) (nat)) (Joker_)) (i))) (((refl) (nat)) (i))) ((k1) ((h1) (i)))) (ei))) ((k2) ((h2) ((h1) (i))))) (H3)))) (Jokerclearme0))) ((((sub2) ((h1) (i))) (lth1i)) (fh1i)))) (Jokerclearme))) ((((sub1) (i)) (lti)) (fi)).
Definition let_clause_10471 : forall n1 : nat, forall n2 : nat, forall p1 : (nat) -> bool, forall p2 : (nat) -> bool, forall f1 : (nat) -> nat, forall f2 : (nat) -> nat, (((((((iso) (n1)) (n2)) (p1)) (p2)) (f1)) (f2)) -> forall h : (nat) -> nat, (((Ex) ((nat) -> nat)) (fun k : (nat) -> nat => ((And) (((And) (forall i : nat, (((lt) (i)) (n1)) -> ((((eq) (bool)) ((p1) (i))) (true)) -> (((eq) (nat)) ((f1) (i))) ((f2) ((h) (i))))) (((((((((sub_hk) (h)) (k)) (n1)) (n2)) (p1)) (p2)) (f1)) (f2)))) (((((((((sub_hk) (k)) (h)) (n2)) (n1)) (p2)) (p1)) (f2)) (f1)))) -> forall k : (nat) -> nat, (((And) (((And) (forall i : nat, (((lt) (i)) (n1)) -> ((((eq) (bool)) ((p1) (i))) (true)) -> (((eq) (nat)) ((f1) (i))) ((f2) ((h) (i))))) (((((((((sub_hk) (h)) (k)) (n1)) (n2)) (p1)) (p2)) (f1)) (f2)))) (((((((((sub_hk) (k)) (h)) (n2)) (n1)) (p2)) (p1)) (f2)) (f1))) -> (((And) (forall i : nat, (((lt) (i)) (n1)) -> ((((eq) (bool)) ((p1) (i))) (true)) -> (((eq) (nat)) ((f1) (i))) ((f2) ((h) (i))))) (((((((((sub_hk) (h)) (k)) (n1)) (n2)) (p1)) (p2)) (f1)) (f2))) -> (forall i : nat, (((lt) (i)) (n1)) -> ((((eq) (bool)) ((p1) (i))) (true)) -> (((eq) (nat)) ((f1) (i))) ((f2) ((h) (i)))) -> forall i : nat, forall m : nat, (forall f : (nat) -> bool, (((le) (O)) (n1)) -> (((((((((sub_hk) (h)) (k)) (O)) (m)) (p1)) (f)) (f1)) (f2)) -> (((((((((sub_hk) (k)) (h)) (m)) (O)) (f)) (p1)) (f2)) (f1)) -> (((eq) (nat)) (((((((bigop) (nat)) (O)) (fun i0 : nat => (p1) (i0))) ((S) (O))) (times)) (fun i0 : nat => (f1) (i0)))) (((((((bigop) (nat)) (m)) (fun i0 : nat => (f) (i0))) ((S) (O))) (times)) (fun i0 : nat => (f2) (i0)))) -> forall p20 : (nat) -> bool, (((le) (O)) (n1)) -> (((((((((sub_hk) (h)) (k)) (O)) ((S) (m))) (p1)) (p20)) (f1)) (f2)) -> (((((((((sub_hk) (k)) (h)) ((S) (m))) (O)) (p20)) (p1)) (f2)) (f1)) -> forall x2571 : nat, forall x2572 : nat, (((eq) (nat)) (x2571)) (((plus) (((times) (x2572)) (((div) (x2571)) (x2572)))) (((mod) (x2571)) (x2572))) := fun n1 : nat => fun n2 : nat => fun p1 : (nat) -> bool => fun p2 : (nat) -> bool => fun f1 : (nat) -> nat => fun f2 : (nat) -> nat => fun Jokerclearme : ((((((iso) (n1)) (n2)) (p1)) (p2)) (f1)) (f2) => fun h : (nat) -> nat => fun Jokerclearme0 : ((Ex) ((nat) -> nat)) (fun k : (nat) -> nat => ((And) (((And) (forall i : nat, (((lt) (i)) (n1)) -> ((((eq) (bool)) ((p1) (i))) (true)) -> (((eq) (nat)) ((f1) (i))) ((f2) ((h) (i))))) (((((((((sub_hk) (h)) (k)) (n1)) (n2)) (p1)) (p2)) (f1)) (f2)))) (((((((((sub_hk) (k)) (h)) (n2)) (n1)) (p2)) (p1)) (f2)) (f1))) => fun k : (nat) -> nat => fun Jokerclearme1 : ((And) (((And) (forall i : nat, (((lt) (i)) (n1)) -> ((((eq) (bool)) ((p1) (i))) (true)) -> (((eq) (nat)) ((f1) (i))) ((f2) ((h) (i))))) (((((((((sub_hk) (h)) (k)) (n1)) (n2)) (p1)) (p2)) (f1)) (f2)))) (((((((((sub_hk) (k)) (h)) (n2)) (n1)) (p2)) (p1)) (f2)) (f1)) => fun Jokerclearme2 : ((And) (forall i : nat, (((lt) (i)) (n1)) -> ((((eq) (bool)) ((p1) (i))) (true)) -> (((eq) (nat)) ((f1) (i))) ((f2) ((h) (i))))) (((((((((sub_hk) (h)) (k)) (n1)) (n2)) (p1)) (p2)) (f1)) (f2)) => fun same : forall i : nat, (((lt) (i)) (n1)) -> ((((eq) (bool)) ((p1) (i))) (true)) -> (((eq) (nat)) ((f1) (i))) ((f2) ((h) (i))) => fun i : nat => fun m : nat => fun Hind : forall f : (nat) -> bool, (((le) (O)) (n1)) -> (((((((((sub_hk) (h)) (k)) (O)) (m)) (p1)) (f)) (f1)) (f2)) -> (((((((((sub_hk) (k)) (h)) (m)) (O)) (f)) (p1)) (f2)) (f1)) -> (((eq) (nat)) (((((((bigop) (nat)) (O)) (fun i0 : nat => (p1) (i0))) ((S) (O))) (times)) (fun i0 : nat => (f1) (i0)))) (((((((bigop) (nat)) (m)) (fun i0 : nat => (f) (i0))) ((S) (O))) (times)) (fun i0 : nat => (f2) (i0))) => fun p20 : (nat) -> bool => fun Joker_ : ((le) (O)) (n1) => fun sub1 : ((((((((sub_hk) (h)) (k)) (O)) ((S) (m))) (p1)) (p20)) (f1)) (f2) => fun sub2 : ((((((((sub_hk) (k)) (h)) ((S) (m))) (O)) (p20)) (p1)) (f2)) (f1) => fun x2571 : nat => fun x2572 : nat => ((((((rewrite_l) (nat)) (((times) (((div) (x2571)) (x2572))) (x2572))) (fun Joker_1 : nat => (((eq) (nat)) (x2571)) (((plus) (Joker_1)) (((mod) (x2571)) (x2572))))) (((div_mod) (x2571)) (x2572))) (((times) (x2572)) (((div) (x2571)) (x2572)))) (((commutative_times) (((div) (x2571)) (x2572))) (x2572)).
Definition bigop_iso : forall n1 : nat, forall n2 : nat, forall p1 : (nat) -> bool, forall p2 : (nat) -> bool, forall f1 : (nat) -> nat, forall f2 : (nat) -> nat, (((((((iso) (n1)) (n2)) (p1)) (p2)) (f1)) (f2)) -> (((eq) (nat)) (((((((bigop) (nat)) (n1)) (fun i : nat => (p1) (i))) ((S) (O))) (times)) (fun i : nat => (f1) (i)))) (((((((bigop) (nat)) (n2)) (fun i : nat => (p2) (i))) ((S) (O))) (times)) (fun i : nat => (f2) (i))) := fun n1 : nat => fun n2 : nat => fun p1 : (nat) -> bool => fun p2 : (nat) -> bool => fun f1 : (nat) -> nat => fun f2 : (nat) -> nat => fun Jokerclearme : ((((((iso) (n1)) (n2)) (p1)) (p2)) (f1)) (f2) => (((((match_ex_prop) ((nat) -> nat)) (fun h : (nat) -> nat => ((Ex) ((nat) -> nat)) (fun k : (nat) -> nat => ((And) (((And) (forall i : nat, (((lt) (i)) (n1)) -> ((((eq) (bool)) ((p1) (i))) (true)) -> (((eq) (nat)) ((f1) (i))) ((f2) ((h) (i))))) (((((((((sub_hk) (h)) (k)) (n1)) (n2)) (p1)) (p2)) (f1)) (f2)))) (((((((((sub_hk) (k)) (h)) (n2)) (n1)) (p2)) (p1)) (f2)) (f1))))) ((((eq) (nat)) (((((((bigop) (nat)) (n1)) (fun i : nat => (p1) (i))) ((S) (O))) (times)) (fun i : nat => (f1) (i)))) (((((((bigop) (nat)) (n2)) (fun i : nat => (p2) (i))) ((S) (O))) (times)) (fun i : nat => (f2) (i))))) (fun h : (nat) -> nat => fun Jokerclearme0 : ((Ex) ((nat) -> nat)) (fun k : (nat) -> nat => ((And) (((And) (forall i : nat, (((lt) (i)) (n1)) -> ((((eq) (bool)) ((p1) (i))) (true)) -> (((eq) (nat)) ((f1) (i))) ((f2) ((h) (i))))) (((((((((sub_hk) (h)) (k)) (n1)) (n2)) (p1)) (p2)) (f1)) (f2)))) (((((((((sub_hk) (k)) (h)) (n2)) (n1)) (p2)) (p1)) (f2)) (f1))) => (((((match_ex_prop) ((nat) -> nat)) (fun k : (nat) -> nat => ((And) (((And) (forall i : nat, (((lt) (i)) (n1)) -> ((((eq) (bool)) ((p1) (i))) (true)) -> (((eq) (nat)) ((f1) (i))) ((f2) ((h) (i))))) (((((((((sub_hk) (h)) (k)) (n1)) (n2)) (p1)) (p2)) (f1)) (f2)))) (((((((((sub_hk) (k)) (h)) (n2)) (n1)) (p2)) (p1)) (f2)) (f1)))) ((((eq) (nat)) (((((((bigop) (nat)) (n1)) (fun i : nat => (p1) (i))) ((S) (O))) (times)) (fun i : nat => (f1) (i)))) (((((((bigop) (nat)) (n2)) (fun i : nat => (p2) (i))) ((S) (O))) (times)) (fun i : nat => (f2) (i))))) (fun k : (nat) -> nat => fun Jokerclearme1 : ((And) (((And) (forall i : nat, (((lt) (i)) (n1)) -> ((((eq) (bool)) ((p1) (i))) (true)) -> (((eq) (nat)) ((f1) (i))) ((f2) ((h) (i))))) (((((((((sub_hk) (h)) (k)) (n1)) (n2)) (p1)) (p2)) (f1)) (f2)))) (((((((((sub_hk) (k)) (h)) (n2)) (n1)) (p2)) (p1)) (f2)) (f1)) => (((((match_And_prop) (((And) (forall i : nat, (((lt) (i)) (n1)) -> ((((eq) (bool)) ((p1) (i))) (true)) -> (((eq) (nat)) ((f1) (i))) ((f2) ((h) (i))))) (((((((((sub_hk) (h)) (k)) (n1)) (n2)) (p1)) (p2)) (f1)) (f2)))) (((((((((sub_hk) (k)) (h)) (n2)) (n1)) (p2)) (p1)) (f2)) (f1))) ((((eq) (nat)) (((((((bigop) (nat)) (n1)) (fun i : nat => (p1) (i))) ((S) (O))) (times)) (fun i : nat => (f1) (i)))) (((((((bigop) (nat)) (n2)) (fun i : nat => (p2) (i))) ((S) (O))) (times)) (fun i : nat => (f2) (i))))) (fun Jokerclearme2 : ((And) (forall i : nat, (((lt) (i)) (n1)) -> ((((eq) (bool)) ((p1) (i))) (true)) -> (((eq) (nat)) ((f1) (i))) ((f2) ((h) (i))))) (((((((((sub_hk) (h)) (k)) (n1)) (n2)) (p1)) (p2)) (f1)) (f2)) => (((((match_And_prop) (forall i : nat, (((lt) (i)) (n1)) -> ((((eq) (bool)) ((p1) (i))) (true)) -> (((eq) (nat)) ((f1) (i))) ((f2) ((h) (i))))) (((((((((sub_hk) (h)) (k)) (n1)) (n2)) (p1)) (p2)) (f1)) (f2))) ((((((((((sub_hk) (k)) (h)) (n2)) (n1)) (p2)) (p1)) (f2)) (f1)) -> (((eq) (nat)) (((((((bigop) (nat)) (n1)) (fun i : nat => (p1) (i))) ((S) (O))) (times)) (fun i : nat => (f1) (i)))) (((((((bigop) (nat)) (n2)) (fun i : nat => (p2) (i))) ((S) (O))) (times)) (fun i : nat => (f2) (i))))) (fun same : forall i : nat, (((lt) (i)) (n1)) -> ((((eq) (bool)) ((p1) (i))) (true)) -> (((eq) (nat)) ((f1) (i))) ((f2) ((h) (i))) => (((le_gen) (fun Joker_ : nat => (((((((((sub_hk) (h)) (k)) (Joker_)) (n2)) (p1)) (p2)) (f1)) (f2)) -> (((((((((sub_hk) (k)) (h)) (n2)) (Joker_)) (p2)) (p1)) (f2)) (f1)) -> (((eq) (nat)) (((((((bigop) (nat)) (Joker_)) (fun i : nat => (p1) (i))) ((S) (O))) (times)) (fun i : nat => (f1) (i)))) (((((((bigop) (nat)) (n2)) (fun i : nat => (p2) (i))) ((S) (O))) (times)) (fun i : nat => (f2) (i))))) (n1)) (fun i : nat => (((((nat_ind) (fun Jokerx_365 : nat => forall f : (nat) -> bool, (((le) (Jokerx_365)) (n1)) -> (((((((((sub_hk) (h)) (k)) (Jokerx_365)) (n2)) (p1)) (f)) (f1)) (f2)) -> (((((((((sub_hk) (k)) (h)) (n2)) (Jokerx_365)) (f)) (p1)) (f2)) (f1)) -> (((eq) (nat)) (((((((bigop) (nat)) (Jokerx_365)) (fun i0 : nat => (p1) (i0))) ((S) (O))) (times)) (fun i0 : nat => (f1) (i0)))) (((((((bigop) (nat)) (n2)) (fun i0 : nat => (f) (i0))) ((S) (O))) (times)) (fun i0 : nat => (f2) (i0))))) (((((nat_ind) (fun Jokerx_365 : nat => forall f : (nat) -> bool, (((le) (O)) (n1)) -> (((((((((sub_hk) (h)) (k)) (O)) (Jokerx_365)) (p1)) (f)) (f1)) (f2)) -> (((((((((sub_hk) (k)) (h)) (Jokerx_365)) (O)) (f)) (p1)) (f2)) (f1)) -> (((eq) (nat)) (((((((bigop) (nat)) (O)) (fun i0 : nat => (p1) (i0))) ((S) (O))) (times)) (fun i0 : nat => (f1) (i0)))) (((((((bigop) (nat)) (Jokerx_365)) (fun i0 : nat => (f) (i0))) ((S) (O))) (times)) (fun i0 : nat => (f2) (i0))))) (fun f : (nat) -> bool => (((sym_eq_bigop_O) (nat)) (fun y : ((nat) -> bool) -> (nat) -> ((nat) -> (nat) -> nat) -> ((nat) -> nat) -> nat => (((le) (O)) (n1)) -> (((((((((sub_hk) (h)) (k)) (O)) (O)) (p1)) (f)) (f1)) (f2)) -> (((((((((sub_hk) (k)) (h)) (O)) (O)) (f)) (p1)) (f2)) (f1)) -> (((eq) (nat)) (((((((bigop) (nat)) (O)) (fun iO : nat => (p1) (iO))) ((S) (O))) (times)) (fun iO : nat => (f1) (iO)))) (((((y) (fun iO : nat => (f) (iO))) ((S) (O))) (times)) (fun iO : nat => (f2) (iO))))) ((((sym_eq_bigop_body_O) (nat)) (fun y : ((nat) -> bool) -> (nat) -> ((nat) -> (nat) -> nat) -> ((nat) -> nat) -> nat => (((le) (O)) (n1)) -> (((((((((sub_hk) (h)) (k)) (O)) (O)) (p1)) (f)) (f1)) (f2)) -> (((((((((sub_hk) (k)) (h)) (O)) (O)) (f)) (p1)) (f2)) (f1)) -> (((eq) (nat)) (((((((bigop) (nat)) (O)) (fun iO : nat => (p1) (iO))) ((S) (O))) (times)) (fun iO : nat => (f1) (iO)))) (((((y) (fun iO : nat => (f) (iO))) ((S) (O))) (times)) (fun iO : nat => (f2) (iO))))) ((((eq_bigop_body_O) (nat)) (fun y : ((nat) -> bool) -> (nat) -> ((nat) -> (nat) -> nat) -> ((nat) -> nat) -> nat => (((le) (O)) (n1)) -> (((((((((sub_hk) (h)) (k)) (O)) (O)) (p1)) (f)) (f1)) (f2)) -> (((((((((sub_hk) (k)) (h)) (O)) (O)) (f)) (p1)) (f2)) (f1)) -> (((eq) (nat)) (((((((bigop) (nat)) (O)) (fun iO : nat => (p1) (iO))) ((S) (O))) (times)) (fun iO : nat => (f1) (iO)))) (((((y) (fun iO : nat => (p1) (iO))) ((S) (O))) (times)) (fun iO : nat => (f1) (iO))))) ((((eq_bigop_O) (nat)) (fun y : ((nat) -> bool) -> (nat) -> ((nat) -> (nat) -> nat) -> ((nat) -> nat) -> nat => (((le) (O)) (n1)) -> (((((((((sub_hk) (h)) (k)) (O)) (O)) (p1)) (f)) (f1)) (f2)) -> (((((((((sub_hk) (k)) (h)) (O)) (O)) (f)) (p1)) (f2)) (f1)) -> (((eq) (nat)) (((((((bigop) (nat)) (O)) (fun iO : nat => (p1) (iO))) ((S) (O))) (times)) (fun iO : nat => (f1) (iO)))) (((((y) (fun iO : nat => (p1) (iO))) ((S) (O))) (times)) (fun iO : nat => (f1) (iO))))) (fun auto : ((le) (O)) (n1) => fun auto' : ((((((((sub_hk) (h)) (k)) (O)) (O)) (p1)) (f)) (f1)) (f2) => fun auto'' : ((((((((sub_hk) (k)) (h)) (O)) (O)) (f)) (p1)) (f2)) (f1) => ((refl) (nat)) (((((((bigop) (nat)) (O)) (fun i0 : nat => (p1) (i0))) ((S) (O))) (times)) (fun i0 : nat => (f1) (i0))))))))) (fun m : nat => fun Hind : forall f : (nat) -> bool, (((le) (O)) (n1)) -> (((((((((sub_hk) (h)) (k)) (O)) (m)) (p1)) (f)) (f1)) (f2)) -> (((((((((sub_hk) (k)) (h)) (m)) (O)) (f)) (p1)) (f2)) (f1)) -> (((eq) (nat)) (((((((bigop) (nat)) (O)) (fun i0 : nat => (p1) (i0))) ((S) (O))) (times)) (fun i0 : nat => (f1) (i0)))) (((((((bigop) (nat)) (m)) (fun i0 : nat => (f) (i0))) ((S) (O))) (times)) (fun i0 : nat => (f2) (i0))) => fun p20 : (nat) -> bool => fun Joker_ : ((le) (O)) (n1) => fun sub1 : ((((((((sub_hk) (h)) (k)) (O)) ((S) (m))) (p1)) (p20)) (f1)) (f2) => fun sub2 : ((((((((sub_hk) (k)) (h)) ((S) (m))) (O)) (p20)) (p1)) (f2)) (f1) => ((((((eq_ind_r) (nat)) (((((((bigop) (nat)) (m)) (fun i0 : nat => (p20) (i0))) ((S) (O))) (times)) (fun i0 : nat => (f2) (i0)))) (fun x : nat => (((eq) (nat)) (((((((bigop) (nat)) (O)) (fun i0 : nat => (p1) (i0))) ((S) (O))) (times)) (fun i0 : nat => (f1) (i0)))) (x))) (((((Hind) (p20)) ((le_O_n) (n1))) ((((((((((sub_hkO) (h)) (k)) (O)) (m)) (p1)) (p20)) (f1)) (f2)) (((refl) (nat)) (O)))) ((((((((((((((((transitive_sub) (fun x : nat => x)) (fun x : nat => x)) (k)) (h)) (m)) ((S) (m))) (O)) (p20)) (p20)) (p1)) (f2)) (f2)) (f1)) ((((((sub_lt) (f2)) (p20)) (m)) ((S) (m))) ((le_n_Sn) (m)))) (sub2)))) (((((((bigop) (nat)) ((S) (m))) (fun i0 : nat => (p20) (i0))) ((S) (O))) (times)) (fun i0 : nat => (f2) (i0)))) ((((((((bigop_Sfalse) (nat)) (m)) (p20)) ((S) (O))) (times)) (f2)) (((((((((((((sub0_to_false) (k)) (h)) (O)) ((S) (m))) (p1)) (p20)) (f1)) (f2)) (((refl) (nat)) (O))) (sub2)) (m)) (((((eq_coerc) (((lt) (((mod) (m)) (O))) (((plus) (((plus) (((mod) (m)) (O))) (((times) (O)) (((div) (m)) (O))))) ((S) (O))))) (((lt) (m)) ((S) (m)))) ((((lt_plus_Sn_r) (((mod) (m)) (O))) (((times) (O)) (((div) (m)) (O)))) (O))) (((((((rewrite_l) (nat)) (m)) (fun Joker_1 : nat => (((eq) Prop) (((lt) (((mod) (m)) (O))) (((plus) (Joker_1)) ((S) (O))))) (((lt) (m)) ((S) (m))))) (((((((rewrite_l) (nat)) (m)) (fun Joker_1 : nat => (((eq) Prop) (((lt) (Joker_1)) (((plus) (m)) ((S) (O))))) (((lt) (m)) ((S) (m))))) (((((((rewrite_l) (nat)) ((S) (m))) (fun Joker_1 : nat => (((eq) Prop) (((lt) (m)) (Joker_1))) (((lt) (m)) ((S) (m))))) (((refl) Prop) (((lt) (m)) ((S) (m))))) (((plus) (m)) ((S) (O)))) (((((((rewrite_r) (nat)) (((plus) (m)) (O))) (fun Joker_1 : nat => (((eq) (nat)) ((S) (Joker_1))) (((plus) (m)) ((S) (O))))) (((plus_n_Sm) (m)) (O))) (m)) ((plus_n_O) (m))))) (((mod) (m)) (O))) (((((((rewrite_r) (nat)) (((plus) (O)) (((mod) (m)) (O)))) (fun Joker_1 : nat => (((eq) (nat)) (m)) (Joker_1))) (((((((rewrite_l) (nat)) (((plus) (((mod) (m)) (O))) (O))) (fun Joker_1 : nat => (((eq) (nat)) (m)) (Joker_1))) (((((((rewrite_r) (nat)) (((times) (O)) (((div) (m)) (O)))) (fun Joker_1 : nat => (((eq) (nat)) (m)) (((plus) (((mod) (m)) (O))) (Joker_1)))) (((((((rewrite_l) (nat)) (((plus) (((times) (O)) (((div) (m)) (O)))) (((mod) (m)) (O)))) (fun Joker_1 : nat => (((eq) (nat)) (m)) (Joker_1))) (((((((((((((((((((((((let_clause_10471) (n1)) (n2)) (p1)) (p2)) (f1)) (f2)) (Jokerclearme)) (h)) (Jokerclearme0)) (k)) (Jokerclearme1)) (Jokerclearme2)) (same)) (i)) (m)) (Hind)) (p20)) (Joker_)) (sub1)) (sub2)) (m)) (O))) (((plus) (((mod) (m)) (O))) (((times) (O)) (((div) (m)) (O))))) (((commutative_plus) (((times) (O)) (((div) (m)) (O)))) (((mod) (m)) (O))))) (O)) ((times_O_n) (((div) (m)) (O))))) (((plus) (O)) (((mod) (m)) (O)))) (((commutative_plus) (((mod) (m)) (O))) (O)))) (((mod) (m)) (O))) ((plus_O_n) (((mod) (m)) (O)))))) (((plus) (((mod) (m)) (O))) (((times) (O)) (((div) (m)) (O))))) (((((((rewrite_l) (nat)) (((plus) (((times) (O)) (((div) (m)) (O)))) (((mod) (m)) (O)))) (fun Joker_1 : nat => (((eq) (nat)) (m)) (Joker_1))) (((((((((((((((((((((((let_clause_10471) (n1)) (n2)) (p1)) (p2)) (f1)) (f2)) (Jokerclearme)) (h)) (Jokerclearme0)) (k)) (Jokerclearme1)) (Jokerclearme2)) (same)) (i)) (m)) (Hind)) (p20)) (Joker_)) (sub1)) (sub2)) (m)) (O))) (((plus) (((mod) (m)) (O))) (((times) (O)) (((div) (m)) (O))))) (((commutative_plus) (((times) (O)) (((div) (m)) (O)))) (((mod) (m)) (O)))))))))) (n2))) (fun n : nat => fun Hind : forall f : (nat) -> bool, (((le) (n)) (n1)) -> (((((((((sub_hk) (h)) (k)) (n)) (n2)) (p1)) (f)) (f1)) (f2)) -> (((((((((sub_hk) (k)) (h)) (n2)) (n)) (f)) (p1)) (f2)) (f1)) -> (((eq) (nat)) (((((((bigop) (nat)) (n)) (fun i0 : nat => (p1) (i0))) ((S) (O))) (times)) (fun i0 : nat => (f1) (i0)))) (((((((bigop) (nat)) (n2)) (fun i0 : nat => (f) (i0))) ((S) (O))) (times)) (fun i0 : nat => (f2) (i0))) => fun p20 : (nat) -> bool => fun ltn : ((le) ((S) (n))) (n1) => fun sub1 : ((((((((sub_hk) (h)) (k)) ((S) (n))) (n2)) (p1)) (p20)) (f1)) (f2) => fun sub2 : ((((((((sub_hk) (k)) (h)) (n2)) ((S) (n))) (p20)) (p1)) (f2)) (f1) => ((((((match_Or_prop) ((((eq) (bool)) ((p1) (n))) (true))) ((((eq) (bool)) ((p1) (n))) (false))) ((((eq) (nat)) (((((((bigop) (nat)) ((S) (n))) (fun i0 : nat => (p1) (i0))) ((S) (O))) (times)) (fun i0 : nat => (f1) (i0)))) (((((((bigop) (nat)) (n2)) (fun i0 : nat => (p20) (i0))) ((S) (O))) (times)) (fun i0 : nat => (f2) (i0))))) (fun p1n : (((eq) (bool)) ((p1) (n))) (true) => ((((((eq_ind_r) (nat)) (((times) ((f1) (n))) (((((((bigop) (nat)) (n)) (fun i0 : nat => (p1) (i0))) ((S) (O))) (times)) (fun i0 : nat => (f1) (i0))))) (fun x : nat => (((eq) (nat)) (x)) (((((((bigop) (nat)) (n2)) (fun i0 : nat => (p20) (i0))) ((S) (O))) (times)) (fun i0 : nat => (f2) (i0))))) ((((((match_And_prop) (((And) (((lt) ((h) (n))) (n2))) ((((eq) (bool)) ((p20) ((h) (n)))) (true)))) ((((eq) (nat)) ((k) ((h) (n)))) (n))) ((((eq) (nat)) (((times) ((f1) (n))) (((((((bigop) (nat)) (n)) (fun i0 : nat => (p1) (i0))) ((S) (O))) (times)) (fun i0 : nat => (f1) (i0))))) (((((((bigop) (nat)) (n2)) (fun i0 : nat => (p20) (i0))) ((S) (O))) (times)) (fun i0 : nat => (f2) (i0))))) (fun Jokerclearme3 : ((And) (((lt) ((h) (n))) (n2))) ((((eq) (bool)) ((p20) ((h) (n)))) (true)) => (((((match_And_prop) (((lt) ((h) (n))) (n2))) ((((eq) (bool)) ((p20) ((h) (n)))) (true))) (((((eq) (nat)) ((k) ((h) (n)))) (n)) -> (((eq) (nat)) (((times) ((f1) (n))) (((((((bigop) (nat)) (n)) (fun i0 : nat => (p1) (i0))) ((S) (O))) (times)) (fun i0 : nat => (f1) (i0))))) (((((((bigop) (nat)) (n2)) (fun i0 : nat => (p20) (i0))) ((S) (O))) (times)) (fun i0 : nat => (f2) (i0))))) (fun hn : ((lt) ((h) (n))) (n2) => fun p2hn : (((eq) (bool)) ((p20) ((h) (n)))) (true) => fun eqn : (((eq) (nat)) ((k) ((h) (n)))) (n) => ((((((eq_ind_r) (nat)) (((times) ((f2) ((h) (n)))) (((((((bigop) (nat)) (n2)) (fun x : nat => ((andb) ((notb) (((eqb) ((h) (n))) (x)))) ((p20) (x)))) ((S) (O))) (times)) (fun x : nat => (f2) (x))))) (fun x : nat => (((eq) (nat)) (((times) ((f1) (n))) (((((((bigop) (nat)) (n)) (fun i0 : nat => (p1) (i0))) ((S) (O))) (times)) (fun i0 : nat => (f1) (i0))))) (x))) (((((((eq_ind_r) (nat)) ((f2) ((h) (n)))) (fun x : nat => (((eq) (nat)) (((times) (x)) (((((((bigop) (nat)) (n)) (fun i0 : nat => (p1) (i0))) ((S) (O))) (times)) (fun i0 : nat => (f1) (i0))))) (((times) ((f2) ((h) (n)))) (((((((bigop) (nat)) (n2)) (fun x0 : nat => ((andb) ((notb) (((eqb) ((h) (n))) (x0)))) ((p20) (x0)))) ((S) (O))) (times)) (fun x0 : nat => (f2) (x0)))))) (((((((eq_f) (nat)) (nat)) ((times) ((f2) ((h) (n))))) (((((((bigop) (nat)) (n)) (fun i0 : nat => (p1) (i0))) ((S) (O))) (times)) (fun i0 : nat => (f1) (i0)))) (((((((bigop) (nat)) (n2)) (fun x : nat => ((andb) ((notb) (((eqb) ((h) (n))) (x)))) ((p20) (x)))) ((S) (O))) (times)) (fun x : nat => (f2) (x)))) (((((Hind) (fun Joker_ : nat => ((andb) ((notb) (((eqb) ((h) (n))) (Joker_)))) ((p20) (Joker_)))) ((((lt_to_le) (n)) (n1)) (ltn))) (fun i0 : nat => fun ltin : ((lt) (i0)) (n) => fun p1i : (((eq) (bool)) ((p1) (i0))) (true) => (((((match_And_prop) (((And) (((lt) ((h) (i0))) (n2))) ((((eq) (bool)) ((p20) ((h) (i0)))) (true)))) ((((eq) (nat)) ((k) ((h) (i0)))) (i0))) (((And) (((And) (((lt) ((h) (i0))) (n2))) ((((eq) (bool)) (((andb) ((notb) (((eqb) ((h) (n))) ((h) (i0))))) ((p20) ((h) (i0))))) (true)))) ((((eq) (nat)) ((k) ((h) (i0)))) (i0)))) (fun Jokerclearme4 : ((And) (((lt) ((h) (i0))) (n2))) ((((eq) (bool)) ((p20) ((h) (i0)))) (true)) => (((((match_And_prop) (((lt) ((h) (i0))) (n2))) ((((eq) (bool)) ((p20) ((h) (i0)))) (true))) (((((eq) (nat)) ((k) ((h) (i0)))) (i0)) -> ((And) (((And) (((lt) ((h) (i0))) (n2))) ((((eq) (bool)) (((andb) ((notb) (((eqb) ((h) (n))) ((h) (i0))))) ((p20) ((h) (i0))))) (true)))) ((((eq) (nat)) ((k) ((h) (i0)))) (i0)))) (fun h1i : ((lt) ((h) (i0))) (n2) => fun p2h1i : (((eq) (bool)) ((p20) ((h) (i0)))) (true) => fun eqi : (((eq) (nat)) ((k) ((h) (i0)))) (i0) => fun z : Prop => fun f : (((And) (((lt) ((h) (i0))) (n2))) ((((eq) (bool)) (((andb) ((notb) (((eqb) ((h) (n))) ((h) (i0))))) ((p20) ((h) (i0))))) (true))) -> ((((eq) (nat)) ((k) ((h) (i0)))) (i0)) -> z => ((f) (fun z0 : Prop => fun f20 : (((lt) ((h) (i0))) (n2)) -> ((((eq) (bool)) (((andb) ((notb) (((eqb) ((h) (n))) ((h) (i0))))) ((p20) ((h) (i0))))) (true)) -> z0 => ((f20) (h1i)) (((((((eq_ind_r) (bool)) (false)) (fun x : bool => (((eq) (bool)) (((andb) ((notb) (x))) ((p20) ((h) (i0))))) (true))) ((((((sym_eq_match_bool_type_false) (bool)) (false)) (true)) (fun y : bool => (((eq) (bool)) (((((match_bool_type) (bool)) ((p20) ((h) (i0)))) (false)) (y))) (true))) ((((((sym_eq_match_bool_type_true) (bool)) ((p20) ((h) (i0)))) (false)) (fun y : bool => (((eq) (bool)) (y)) (true))) (((((((rewrite_r) (bool)) (true)) (fun Joker_ : bool => (((eq) (bool)) (Joker_)) (true))) (((refl) (bool)) (true))) ((p20) ((h) (i0)))) (p2h1i))))) (((eqb) ((h) (n))) ((h) (i0)))) ((((not_eq_to_eqb_false) ((h) (n))) ((h) (i0))) (((((not_to_not) ((((eq) (nat)) ((h) (n))) ((h) (i0)))) ((((eq) (nat)) (i0)) (n))) (fun auto : (((eq) (nat)) ((h) (n))) ((h) (i0)) => ((((((rewrite_r) (nat)) (n)) (fun Joker_ : nat => (((eq) (nat)) (Joker_)) (n))) (((refl) (nat)) (n))) (i0)) (((((((rewrite_l) (nat)) ((k) ((h) (n)))) (fun Joker_ : nat => (((eq) (nat)) (Joker_)) (n))) (eqn)) (i0)) (((((((rewrite_r) (nat)) ((h) (i0))) (fun Joker_ : nat => (((eq) (nat)) ((k) (Joker_))) (i0))) (eqi)) ((h) (n))) (auto))))) ((((lt_to_not_eq) (i0)) (n)) (ltin))))))) (((((((rewrite_r) (nat)) (i0)) (fun Joker_ : nat => (((eq) (nat)) (Joker_)) (i0))) (((refl) (nat)) (i0))) ((k) ((h) (i0)))) (eqi)))) (Jokerclearme4))) ((((sub1) (i0)) ((((le_S) ((S) (i0))) (n)) (ltin))) (p1i)))) (fun j : nat => fun ltj : ((lt) (j)) (n2) => fun p2j : (((eq) (bool)) (((andb) ((notb) (((eqb) ((h) (n))) (j)))) ((p20) (j)))) (true) => (((((match_And_prop) (((And) (((lt) ((k) (j))) ((S) (n)))) ((((eq) (bool)) ((p1) ((k) (j)))) (true)))) ((((eq) (nat)) ((h) ((k) (j)))) (j))) (((And) (((And) (((lt) ((k) (j))) (n))) ((((eq) (bool)) ((p1) ((k) (j)))) (true)))) ((((eq) (nat)) ((h) ((k) (j)))) (j)))) (fun Jokerclearme4 : ((And) (((lt) ((k) (j))) ((S) (n)))) ((((eq) (bool)) ((p1) ((k) (j)))) (true)) => (((((match_And_prop) (((lt) ((k) (j))) ((S) (n)))) ((((eq) (bool)) ((p1) ((k) (j)))) (true))) (((((eq) (nat)) ((h) ((k) (j)))) (j)) -> ((And) (((And) (((lt) ((k) (j))) (n))) ((((eq) (bool)) ((p1) ((k) (j)))) (true)))) ((((eq) (nat)) ((h) ((k) (j)))) (j)))) (fun ltkj : ((lt) ((k) (j))) ((S) (n)) => fun p1kj : (((eq) (bool)) ((p1) ((k) (j)))) (true) => fun eqj : (((eq) (nat)) ((h) ((k) (j)))) (j) => fun z : Prop => fun f : (((And) (((lt) ((k) (j))) (n))) ((((eq) (bool)) ((p1) ((k) (j)))) (true))) -> ((((eq) (nat)) ((h) ((k) (j)))) (j)) -> z => ((f) (fun z0 : Prop => fun f20 : (((lt) ((k) (j))) (n)) -> ((((eq) (bool)) ((p1) ((k) (j)))) (true)) -> z0 => ((f20) (((((((match_Or_prop) (((lt) ((k) (j))) (n))) ((((eq) (nat)) ((k) (j))) (n))) (((lt) ((k) (j))) (n))) (fun auto : ((lt) ((k) (j))) (n) => auto)) (fun eqkj : (((eq) (nat)) ((k) (j))) (n) => ((falsity) (((lt) ((k) (j))) (n))) (((((((eqb_elim) ((h) (n))) (j)) (fun Joker_ : bool => ((((eq) (bool)) (((andb) ((notb) (Joker_))) ((p20) (j)))) (true)) -> False)) ((((((sym_eq_match_bool_type_true) (bool)) (false)) (true)) (fun y : bool => ((((eq) (nat)) ((h) (n))) (j)) -> ((((eq) (bool)) (((((match_bool_type) (bool)) ((p20) (j))) (false)) (y))) (true)) -> False)) ((((((sym_eq_match_bool_type_false) (bool)) ((p20) (j))) (false)) (fun y : bool => ((((eq) (nat)) ((h) (n))) (j)) -> ((((eq) (bool)) (y)) (true)) -> False)) (fun auto : (((eq) (nat)) ((h) (n))) (j) => fun auto' : (((eq) (bool)) (false)) (true) => (((absurd) ((((eq) (bool)) (true)) (false))) (((((((rewrite_r) (bool)) (true)) (fun Joker_ : bool => (((eq) (bool)) (true)) (Joker_))) (((refl) (bool)) (true))) (false)) (auto'))) (not_eq_true_false))))) ((((((sym_eq_match_bool_type_false) (bool)) (false)) (true)) (fun y : bool => ((Not) ((((eq) (nat)) ((h) (n))) (j))) -> ((((eq) (bool)) (((((match_bool_type) (bool)) ((p20) (j))) (false)) (y))) (true)) -> False)) ((((((sym_eq_match_bool_type_true) (bool)) ((p20) (j))) (false)) (fun y : bool => ((Not) ((((eq) (nat)) ((h) (n))) (j))) -> ((((eq) (bool)) (y)) (true)) -> False)) (fun auto : (Not) ((((eq) (nat)) ((h) (n))) (j)) => fun auto' : (((eq) (bool)) ((p20) (j))) (true) => (((absurd) ((((eq) (nat)) ((h) (n))) (j))) (((((((rewrite_r) (nat)) (j)) (fun Joker_ : nat => (((eq) (nat)) (Joker_)) (j))) (((refl) (nat)) (j))) ((h) (n))) (((((((rewrite_l) (nat)) ((k) (j))) (fun Joker_ : nat => (((eq) (nat)) ((h) (Joker_))) (j))) (eqj)) (n)) (eqkj)))) (auto))))) (p2j)))) ((((le_to_or_lt_eq) ((k) (j))) (n)) ((((le_S_S_to_le) ((k) (j))) (n)) (ltkj))))) (((((((rewrite_r) (bool)) (true)) (fun Joker_ : bool => (((eq) (bool)) (Joker_)) (true))) (((refl) (bool)) (true))) ((p1) ((k) (j)))) (p1kj)))) (((((((rewrite_r) (nat)) (j)) (fun Joker_ : nat => (((eq) (nat)) (Joker_)) (j))) (((refl) (nat)) (j))) ((h) ((k) (j)))) (eqj)))) (Jokerclearme4))) ((((sub2) (j)) (ltj)) ((((andb_true_r) ((notb) (((eqb) ((h) (n))) (j)))) ((p20) (j))) (p2j))))))) ((f1) (n))) ((((same) (n)) (ltn)) (((((((rewrite_r) (bool)) (true)) (fun Joker_ : bool => (((eq) (bool)) (Joker_)) (true))) (((refl) (bool)) (true))) ((p1) (n))) (p1n))))) (((((((bigop) (nat)) (n2)) (fun x : nat => (p20) (x))) ((S) (O))) (times)) (fun x : nat => (f2) (x)))) (((((((bigop_diff) (p20)) (f2)) ((h) (n))) (n2)) (hn)) (((((((rewrite_r) (bool)) (true)) (fun Joker_ : bool => (((eq) (bool)) (Joker_)) (true))) (((refl) (bool)) (true))) ((p20) ((h) (n)))) (p2hn))))) (Jokerclearme3))) ((((sub1) (n)) ((le_n) ((S) (n)))) (p1n)))) (((((((bigop) (nat)) ((S) (n))) (fun i0 : nat => (p1) (i0))) ((S) (O))) (times)) (fun i0 : nat => (f1) (i0)))) ((((((((bigop_Strue) (nat)) (n)) (p1)) ((S) (O))) (times)) (f1)) (((((((rewrite_r) (bool)) (true)) (fun Joker_ : bool => (((eq) (bool)) (Joker_)) (true))) (((refl) (bool)) (true))) ((p1) (n))) (p1n))))) (fun p1n : (((eq) (bool)) ((p1) (n))) (false) => ((((((eq_ind_r) (nat)) (((((((bigop) (nat)) (n)) (fun i0 : nat => (p1) (i0))) ((S) (O))) (times)) (fun i0 : nat => (f1) (i0)))) (fun x : nat => (((eq) (nat)) (x)) (((((((bigop) (nat)) (n2)) (fun i0 : nat => (p20) (i0))) ((S) (O))) (times)) (fun i0 : nat => (f2) (i0))))) (((((Hind) (p20)) ((((lt_to_le) (n)) (n1)) (ltn))) ((((((((((((((((transitive_sub) (fun x : nat => x)) (fun x : nat => x)) (h)) (k)) (n)) ((S) (n))) (n2)) (p1)) (p1)) (p20)) (f1)) (f1)) (f2)) ((((((sub_lt) (f1)) (p1)) (n)) ((S) (n))) ((le_n_Sn) (n)))) (sub1))) (fun i0 : nat => fun lti : ((lt) (i0)) (n2) => fun p2i : (((eq) (bool)) ((p20) (i0))) (true) => (((((match_And_prop) (((And) (((lt) ((k) (i0))) ((S) (n)))) ((((eq) (bool)) ((p1) ((k) (i0)))) (true)))) ((((eq) (nat)) ((h) ((k) (i0)))) (i0))) (((And) (((And) (((lt) ((k) (i0))) (n))) ((((eq) (bool)) ((p1) ((k) (i0)))) (true)))) ((((eq) (nat)) ((h) ((k) (i0)))) (i0)))) (fun Jokerclearme3 : ((And) (((lt) ((k) (i0))) ((S) (n)))) ((((eq) (bool)) ((p1) ((k) (i0)))) (true)) => (((((match_And_prop) (((lt) ((k) (i0))) ((S) (n)))) ((((eq) (bool)) ((p1) ((k) (i0)))) (true))) (((((eq) (nat)) ((h) ((k) (i0)))) (i0)) -> ((And) (((And) (((lt) ((k) (i0))) (n))) ((((eq) (bool)) ((p1) ((k) (i0)))) (true)))) ((((eq) (nat)) ((h) ((k) (i0)))) (i0)))) (fun ltki : ((lt) ((k) (i0))) ((S) (n)) => fun p1ki : (((eq) (bool)) ((p1) ((k) (i0)))) (true) => fun eqi : (((eq) (nat)) ((h) ((k) (i0)))) (i0) => fun z : Prop => fun f : (((And) (((lt) ((k) (i0))) (n))) ((((eq) (bool)) ((p1) ((k) (i0)))) (true))) -> ((((eq) (nat)) ((h) ((k) (i0)))) (i0)) -> z => ((f) (fun z0 : Prop => fun f20 : (((lt) ((k) (i0))) (n)) -> ((((eq) (bool)) ((p1) ((k) (i0)))) (true)) -> z0 => ((f20) (((((((match_Or_prop) (((lt) ((k) (i0))) (n))) ((((eq) (nat)) ((k) (i0))) (n))) (((lt) ((k) (i0))) (n))) (fun auto : ((lt) ((k) (i0))) (n) => auto)) (fun eqki : (((eq) (nat)) ((k) (i0))) (n) => ((falsity) (((lt) ((k) (i0))) (n))) ((((absurd) ((((eq) (bool)) (true)) (false))) (((((((rewrite_l) (bool)) (true)) (fun Joker_ : bool => (((eq) (bool)) (true)) (Joker_))) (((refl) (bool)) (true))) (false)) (((((((rewrite_l) (bool)) ((p1) (n))) (fun Joker_ : bool => (((eq) (bool)) (Joker_)) (false))) (p1n)) (true)) (((((((rewrite_l) (nat)) ((k) (i0))) (fun Joker_ : nat => (((eq) (bool)) ((p1) (Joker_))) (true))) (p1ki)) (n)) (eqki))))) (not_eq_true_false)))) ((((le_to_or_lt_eq) ((k) (i0))) (n)) ((((le_S_S_to_le) ((k) (i0))) (n)) (ltki))))) (((((((rewrite_r) (bool)) (true)) (fun Joker_ : bool => (((eq) (bool)) (Joker_)) (true))) (((refl) (bool)) (true))) ((p1) ((k) (i0)))) (p1ki)))) (((((((rewrite_r) (nat)) (i0)) (fun Joker_ : nat => (((eq) (nat)) (Joker_)) (i0))) (((refl) (nat)) (i0))) ((h) ((k) (i0)))) (eqi)))) (Jokerclearme3))) ((((sub2) (i0)) (lti)) (p2i))))) (((((((bigop) (nat)) ((S) (n))) (fun i0 : nat => (p1) (i0))) ((S) (O))) (times)) (fun i0 : nat => (f1) (i0)))) ((((((((bigop_Sfalse) (nat)) (n)) (p1)) ((S) (O))) (times)) (f1)) (((((((rewrite_r) (bool)) (false)) (fun Joker_ : bool => (((eq) (bool)) (Joker_)) (false))) (((refl) (bool)) (false))) ((p1) (n))) (p1n))))) ((true_or_false) ((p1) (n))))) (i)) (p2)))) (Jokerclearme2))) (Jokerclearme1))) (Jokerclearme0))) (Jokerclearme).
Parameter exp : (nat) -> (nat) -> nat.
Parameter exp_body : (nat) -> (nat) -> nat.
Axiom eq_exp : forall n : nat, forall m : nat, (((leibniz) (nat)) (((exp) (n)) (m))) ((((filter_nat_type) (nat)) ((exp_body) (n))) (m)).
Definition sym_eq_exp : forall n : nat, forall m : nat, (((leibniz) (nat)) ((((filter_nat_type) (nat)) ((exp_body) (n))) (m))) (((exp) (n)) (m)) := fun n : nat => fun m : nat => ((((sym_leibniz) (nat)) (((exp) (n)) (m))) ((((filter_nat_type) (nat)) ((exp_body) (n))) (m))) (((eq_exp) (n)) (m)).
Axiom eq_exp_body_O : forall n : nat, (((leibniz) (nat)) (((exp_body) (n)) (O))) ((S) (O)).
Definition sym_eq_exp_body_O : forall n : nat, (((leibniz) (nat)) ((S) (O))) (((exp_body) (n)) (O)) := fun n : nat => ((((sym_leibniz) (nat)) (((exp_body) (n)) (O))) ((S) (O))) ((eq_exp_body_O) (n)).
Axiom eq_exp_body_S : forall n : nat, forall m : nat, (((leibniz) (nat)) (((exp_body) (n)) ((S) (m)))) (((times) (((exp) (n)) (m))) (n)).
Definition sym_eq_exp_body_S : forall n : nat, forall m : nat, (((leibniz) (nat)) (((times) (((exp) (n)) (m))) (n))) (((exp_body) (n)) ((S) (m))) := fun n : nat => fun m : nat => ((((sym_leibniz) (nat)) (((exp_body) (n)) ((S) (m)))) (((times) (((exp) (n)) (m))) (n))) (((eq_exp_body_S) (n)) (m)).
Definition lt_O_exp : forall n : nat, forall m : nat, (((lt) (O)) (n)) -> ((lt) (O)) (((exp) (n)) (m)) := fun n : nat => fun m : nat => ((((nat_ind) (fun Jokerx_365 : nat => (((lt) (O)) (n)) -> ((lt) (O)) (((exp) (n)) (Jokerx_365)))) (((((sym_eq_exp) (n)) (O)) (fun y : nat => (((lt) (O)) (n)) -> ((lt) (O)) (y))) (((((sym_eq_filter_nat_type_O) (nat)) ((exp_body) (n))) (fun y : nat => (((lt) (O)) (n)) -> ((lt) (O)) (y))) ((((sym_eq_exp_body_O) (n)) (fun y : nat => (((lt) (O)) (n)) -> ((lt) (O)) (y))) (fun auto : ((le) ((S) (O))) (n) => (lt_O_S) (O)))))) (fun a : nat => ((((sym_eq_exp) (n)) ((S) (a))) (fun y : nat => ((((lt) (O)) (n)) -> ((lt) (O)) (((exp) (n)) (a))) -> (((lt) (O)) (n)) -> ((lt) (O)) (y))) ((((((sym_eq_filter_nat_type_S) (nat)) ((exp_body) (n))) (a)) (fun y : nat => ((((lt) (O)) (n)) -> ((lt) (O)) (((exp) (n)) (a))) -> (((lt) (O)) (n)) -> ((lt) (O)) (y))) (((((sym_eq_exp_body_S) (n)) (a)) (fun y : nat => ((((lt) (O)) (n)) -> ((lt) (O)) (((exp) (n)) (a))) -> (((lt) (O)) (n)) -> ((lt) (O)) (y))) (fun Hind : (((le) ((S) (O))) (n)) -> ((le) ((S) (O))) (((exp) (n)) (a)) => fun posn : ((le) ((S) (O))) (n) => ((eq_times_body_O) (fun y : (nat) -> nat => ((le) ((S) ((y) ((S) (O))))) (((times) (((exp) (n)) (a))) (n)))) (((((eq_filter_nat_type_O) ((nat) -> nat)) (times_body)) (fun y : (nat) -> nat => ((le) ((S) ((y) ((S) (O))))) (((times) (((exp) (n)) (a))) (n)))) ((((eq_times) (O)) (fun y : (nat) -> nat => ((le) ((S) ((y) ((S) (O))))) (((times) (((exp) (n)) (a))) (n)))) (((eq_plus_body_O) (fun y : (nat) -> nat => ((le) ((S) ((y) (((times) (O)) ((S) (O)))))) (((times) (((exp) (n)) (a))) (n)))) (((((eq_filter_nat_type_O) ((nat) -> nat)) (plus_body)) (fun y : (nat) -> nat => ((le) ((S) ((y) (((times) (O)) ((S) (O)))))) (((times) (((exp) (n)) (a))) (n)))) ((((eq_plus) (O)) (fun y : (nat) -> nat => ((le) ((S) ((y) (((times) (O)) ((S) (O)))))) (((times) (((exp) (n)) (a))) (n)))) ((((eq_plus_body_S) (O)) (fun y : (nat) -> nat => ((le) ((y) (((times) (O)) ((S) (O))))) (((times) (((exp) (n)) (a))) (n)))) ((((((eq_filter_nat_type_S) ((nat) -> nat)) (plus_body)) (O)) (fun y : (nat) -> nat => ((le) ((y) (((times) (O)) ((S) (O))))) (((times) (((exp) (n)) (a))) (n)))) ((((eq_plus) ((S) (O))) (fun y : (nat) -> nat => ((le) ((y) (((times) (O)) ((S) (O))))) (((times) (((exp) (n)) (a))) (n)))) ((((eq_times_body_S) (O)) (fun y : (nat) -> nat => ((le) ((y) ((S) (O)))) (((times) (((exp) (n)) (a))) (n)))) ((((((eq_filter_nat_type_S) ((nat) -> nat)) (times_body)) (O)) (fun y : (nat) -> nat => ((le) ((y) ((S) (O)))) (((times) (((exp) (n)) (a))) (n)))) ((((eq_times) ((S) (O))) (fun y : (nat) -> nat => ((le) ((y) ((S) (O)))) (((times) (((exp) (n)) (a))) (n)))) (((((((le_times) ((S) (O))) (((exp) (n)) (a))) ((S) (O))) (n)) ((Hind) (posn))) (posn)))))))))))))))))) (m).
Definition exp_pi_l : forall n : nat, forall a : nat, forall f : (nat) -> nat, (((eq) (nat)) (((times) (((exp) (a)) (n))) (((((((bigop) (nat)) (n)) (fun i : nat => true)) ((S) (O))) (times)) (fun i : nat => (f) (i))))) (((((((bigop) (nat)) (n)) (fun i : nat => true)) ((S) (O))) (times)) (fun i : nat => ((times) (a)) ((f) (i)))) := fun n : nat => fun a : nat => fun f : (nat) -> nat => ((((nat_ind) (fun Jokerx_365 : nat => (((eq) (nat)) (((times) (((exp) (a)) (Jokerx_365))) (((((((bigop) (nat)) (Jokerx_365)) (fun i : nat => true)) ((S) (O))) (times)) (fun i : nat => (f) (i))))) (((((((bigop) (nat)) (Jokerx_365)) (fun i : nat => true)) ((S) (O))) (times)) (fun i : nat => ((times) (a)) ((f) (i)))))) ((((sym_eq_bigop_O) (nat)) (fun y : ((nat) -> bool) -> (nat) -> ((nat) -> (nat) -> nat) -> ((nat) -> nat) -> nat => (((eq) (nat)) (((times) (((exp) (a)) (O))) (((((((bigop) (nat)) (O)) (fun i : nat => true)) ((S) (O))) (times)) (fun i : nat => (f) (i))))) (((((y) (fun i : nat => true)) ((S) (O))) (times)) (fun i : nat => ((times) (a)) ((f) (i)))))) ((((sym_eq_bigop_body_O) (nat)) (fun y : ((nat) -> bool) -> (nat) -> ((nat) -> (nat) -> nat) -> ((nat) -> nat) -> nat => (((eq) (nat)) (((times) (((exp) (a)) (O))) (((((((bigop) (nat)) (O)) (fun i : nat => true)) ((S) (O))) (times)) (fun i : nat => (f) (i))))) (((((y) (fun i : nat => true)) ((S) (O))) (times)) (fun i : nat => ((times) (a)) ((f) (i)))))) (((eq_times_body_O) (fun y : (nat) -> nat => (((eq) (nat)) (((times) (((exp) (a)) (O))) (((((((bigop) (nat)) (O)) (fun i : nat => true)) ((S) (O))) (times)) (fun i : nat => (f) (i))))) ((S) ((y) ((S) (O)))))) (((((eq_filter_nat_type_O) ((nat) -> nat)) (times_body)) (fun y : (nat) -> nat => (((eq) (nat)) (((times) (((exp) (a)) (O))) (((((((bigop) (nat)) (O)) (fun i : nat => true)) ((S) (O))) (times)) (fun i : nat => (f) (i))))) ((S) ((y) ((S) (O)))))) ((((eq_times) (O)) (fun y : (nat) -> nat => (((eq) (nat)) (((times) (((exp) (a)) (O))) (((((((bigop) (nat)) (O)) (fun i : nat => true)) ((S) (O))) (times)) (fun i : nat => (f) (i))))) ((S) ((y) ((S) (O)))))) (((eq_plus_body_O) (fun y : (nat) -> nat => (((eq) (nat)) (((times) (((exp) (a)) (O))) (((((((bigop) (nat)) (O)) (fun i : nat => true)) ((S) (O))) (times)) (fun i : nat => (f) (i))))) ((S) ((y) (((times) (O)) ((S) (O))))))) (((((eq_filter_nat_type_O) ((nat) -> nat)) (plus_body)) (fun y : (nat) -> nat => (((eq) (nat)) (((times) (((exp) (a)) (O))) (((((((bigop) (nat)) (O)) (fun i : nat => true)) ((S) (O))) (times)) (fun i : nat => (f) (i))))) ((S) ((y) (((times) (O)) ((S) (O))))))) ((((eq_plus) (O)) (fun y : (nat) -> nat => (((eq) (nat)) (((times) (((exp) (a)) (O))) (((((((bigop) (nat)) (O)) (fun i : nat => true)) ((S) (O))) (times)) (fun i : nat => (f) (i))))) ((S) ((y) (((times) (O)) ((S) (O))))))) ((((eq_plus_body_S) (O)) (fun y : (nat) -> nat => (((eq) (nat)) (((times) (((exp) (a)) (O))) (((((((bigop) (nat)) (O)) (fun i : nat => true)) ((S) (O))) (times)) (fun i : nat => (f) (i))))) ((y) (((times) (O)) ((S) (O)))))) ((((((eq_filter_nat_type_S) ((nat) -> nat)) (plus_body)) (O)) (fun y : (nat) -> nat => (((eq) (nat)) (((times) (((exp) (a)) (O))) (((((((bigop) (nat)) (O)) (fun i : nat => true)) ((S) (O))) (times)) (fun i : nat => (f) (i))))) ((y) (((times) (O)) ((S) (O)))))) ((((eq_plus) ((S) (O))) (fun y : (nat) -> nat => (((eq) (nat)) (((times) (((exp) (a)) (O))) (((((((bigop) (nat)) (O)) (fun i : nat => true)) ((S) (O))) (times)) (fun i : nat => (f) (i))))) ((y) (((times) (O)) ((S) (O)))))) ((((eq_times_body_S) (O)) (fun y : (nat) -> nat => (((eq) (nat)) (((times) (((exp) (a)) (O))) (((((((bigop) (nat)) (O)) (fun i : nat => true)) ((S) (O))) (times)) (fun i : nat => (f) (i))))) ((y) ((S) (O))))) ((((((eq_filter_nat_type_S) ((nat) -> nat)) (times_body)) (O)) (fun y : (nat) -> nat => (((eq) (nat)) (((times) (((exp) (a)) (O))) (((((((bigop) (nat)) (O)) (fun i : nat => true)) ((S) (O))) (times)) (fun i : nat => (f) (i))))) ((y) ((S) (O))))) ((((eq_times) ((S) (O))) (fun y : (nat) -> nat => (((eq) (nat)) (((times) (((exp) (a)) (O))) (((((((bigop) (nat)) (O)) (fun i : nat => true)) ((S) (O))) (times)) (fun i : nat => (f) (i))))) ((y) ((S) (O))))) ((((((eq_match_nat_type_O) (nat)) ((S) (O))) (fun k : nat => ((((match_bool_type) (nat)) (((times) (((times) (a)) ((f) (k)))) (((((((bigop) (nat)) (k)) (fun i : nat => true)) ((S) (O))) (times)) (fun i : nat => ((times) (a)) ((f) (i)))))) (((((((bigop) (nat)) (k)) (fun i : nat => true)) ((S) (O))) (times)) (fun i : nat => ((times) (a)) ((f) (i))))) (true))) (fun y : nat => (((eq) (nat)) (((times) (((exp) (a)) (O))) (((((((bigop) (nat)) (O)) (fun i : nat => true)) ((S) (O))) (times)) (fun i : nat => (f) (i))))) (((times) ((S) (O))) (y)))) ((((eq_exp_body_O) (a)) (fun y : nat => (((eq) (nat)) (((times) (((exp) (a)) (O))) (((((((bigop) (nat)) (O)) (fun i : nat => true)) ((S) (O))) (times)) (fun i : nat => (f) (i))))) (((times) (y)) (((((fun p : (nat) -> bool => fun nil : nat => fun op : (nat) -> (nat) -> nat => fun f0 : (nat) -> nat => ((((match_nat_type) (nat)) (nil)) (fun k : nat => ((((match_bool_type) (nat)) (((op) ((f0) (k))) (((((((bigop) (nat)) (k)) (p)) (nil)) (op)) (f0)))) (((((((bigop) (nat)) (k)) (p)) (nil)) (op)) (f0))) ((p) (k)))) (O)) (fun i : nat => true)) ((S) (O))) (times)) (fun i : nat => ((times) (a)) ((f) (i))))))) (((((eq_filter_nat_type_O) (nat)) ((exp_body) (a))) (fun y : nat => (((eq) (nat)) (((times) (((exp) (a)) (O))) (((((((bigop) (nat)) (O)) (fun i : nat => true)) ((S) (O))) (times)) (fun i : nat => (f) (i))))) (((times) (y)) (((((fun p : (nat) -> bool => fun nil : nat => fun op : (nat) -> (nat) -> nat => fun f0 : (nat) -> nat => ((((match_nat_type) (nat)) (nil)) (fun k : nat => ((((match_bool_type) (nat)) (((op) ((f0) (k))) (((((((bigop) (nat)) (k)) (p)) (nil)) (op)) (f0)))) (((((((bigop) (nat)) (k)) (p)) (nil)) (op)) (f0))) ((p) (k)))) (O)) (fun i : nat => true)) ((S) (O))) (times)) (fun i : nat => ((times) (a)) ((f) (i))))))) (((((eq_exp) (a)) (O)) (fun y : nat => (((eq) (nat)) (((times) (((exp) (a)) (O))) (((((((bigop) (nat)) (O)) (fun i : nat => true)) ((S) (O))) (times)) (fun i : nat => (f) (i))))) (((times) (y)) (((((fun p : (nat) -> bool => fun nil : nat => fun op : (nat) -> (nat) -> nat => fun f0 : (nat) -> nat => ((((match_nat_type) (nat)) (nil)) (fun k : nat => ((((match_bool_type) (nat)) (((op) ((f0) (k))) (((((((bigop) (nat)) (k)) (p)) (nil)) (op)) (f0)))) (((((((bigop) (nat)) (k)) (p)) (nil)) (op)) (f0))) ((p) (k)))) (O)) (fun i : nat => true)) ((S) (O))) (times)) (fun i : nat => ((times) (a)) ((f) (i))))))) ((((((sym_eq_match_nat_type_O) (nat)) ((S) (O))) (fun k : nat => ((((match_bool_type) (nat)) (((times) (((times) (a)) ((f) (k)))) (((((((bigop) (nat)) (k)) (fun i : nat => true)) ((S) (O))) (times)) (fun i : nat => ((times) (a)) ((f) (i)))))) (((((((bigop) (nat)) (k)) (fun i : nat => true)) ((S) (O))) (times)) (fun i : nat => ((times) (a)) ((f) (i))))) (true))) (fun y : nat => (((eq) (nat)) (((times) (((exp) (a)) (O))) (((((((bigop) (nat)) (O)) (fun i : nat => true)) ((S) (O))) (times)) (fun i : nat => (f) (i))))) (((times) (((exp) (a)) (O))) (y)))) ((((eq_bigop_body_O) (nat)) (fun y : ((nat) -> bool) -> (nat) -> ((nat) -> (nat) -> nat) -> ((nat) -> nat) -> nat => (((eq) (nat)) (((times) (((exp) (a)) (O))) (((((((bigop) (nat)) (O)) (fun i : nat => true)) ((S) (O))) (times)) (fun i : nat => (f) (i))))) (((times) (((exp) (a)) (O))) (((((y) (fun i : nat => true)) ((S) (O))) (times)) (fun i : nat => (f) (i)))))) ((((eq_bigop_O) (nat)) (fun y : ((nat) -> bool) -> (nat) -> ((nat) -> (nat) -> nat) -> ((nat) -> nat) -> nat => (((eq) (nat)) (((times) (((exp) (a)) (O))) (((((((bigop) (nat)) (O)) (fun i : nat => true)) ((S) (O))) (times)) (fun i : nat => (f) (i))))) (((times) (((exp) (a)) (O))) (((((y) (fun i : nat => true)) ((S) (O))) (times)) (fun i : nat => (f) (i)))))) (((refl) (nat)) (((times) (((exp) (a)) (O))) (((((((bigop) (nat)) (O)) (fun i : nat => true)) ((S) (O))) (times)) (fun i : nat => (f) (i))))))))))))))))))))))))))) (fun i : nat => fun Hind : (((eq) (nat)) (((times) (((exp) (a)) (i))) (((((((bigop) (nat)) (i)) (fun i0 : nat => true)) ((S) (O))) (times)) (fun i0 : nat => (f) (i0))))) (((((((bigop) (nat)) (i)) (fun i0 : nat => true)) ((S) (O))) (times)) (fun i0 : nat => ((times) (a)) ((f) (i0)))) => ((((((eq_ind_r) (nat)) (((times) ((f) (i))) (((((((bigop) (nat)) (i)) (fun i0 : nat => true)) ((S) (O))) (times)) (fun i0 : nat => (f) (i0))))) (fun x : nat => (((eq) (nat)) (((times) (((exp) (a)) ((S) (i)))) (x))) (((((((bigop) (nat)) ((S) (i))) (fun i0 : nat => true)) ((S) (O))) (times)) (fun i0 : nat => ((times) (a)) ((f) (i0)))))) (((((((eq_ind_r) (nat)) (((times) (((times) (a)) ((f) (i)))) (((((((bigop) (nat)) (i)) (fun i0 : nat => true)) ((S) (O))) (times)) (fun i0 : nat => ((times) (a)) ((f) (i0)))))) (fun x : nat => (((eq) (nat)) (((times) (((exp) (a)) ((S) (i)))) (((times) ((f) (i))) (((((((bigop) (nat)) (i)) (fun i0 : nat => true)) ((S) (O))) (times)) (fun i0 : nat => (f) (i0)))))) (x))) (((((((eq_ind) (nat)) (((times) (((exp) (a)) (i))) (((((((bigop) (nat)) (i)) (fun i0 : nat => true)) ((S) (O))) (times)) (fun i0 : nat => (f) (i0))))) (fun x_1 : nat => (((eq) (nat)) (((times) (((exp) (a)) ((S) (i)))) (((times) ((f) (i))) (((((((bigop) (nat)) (i)) (fun i0 : nat => true)) ((S) (O))) (times)) (fun i0 : nat => (f) (i0)))))) (((times) (((times) (a)) ((f) (i)))) (x_1)))) (((((((eq_ind) (nat)) (((times) (((times) (((exp) (a)) ((S) (i)))) ((f) (i)))) (((((((bigop) (nat)) (i)) (fun i0 : nat => true)) ((S) (O))) (times)) (fun i0 : nat => (f) (i0))))) (fun x_1 : nat => (((eq) (nat)) (x_1)) (((times) (((times) (a)) ((f) (i)))) (((times) (((exp) (a)) (i))) (((((((bigop) (nat)) (i)) (fun i0 : nat => true)) ((S) (O))) (times)) (fun i0 : nat => (f) (i0))))))) (((((((eq_ind) (nat)) (((times) (((times) (((times) (a)) ((f) (i)))) (((exp) (a)) (i)))) (((((((bigop) (nat)) (i)) (fun i0 : nat => true)) ((S) (O))) (times)) (fun i0 : nat => (f) (i0))))) (fun x_1 : nat => (((eq) (nat)) (((times) (((times) (((exp) (a)) ((S) (i)))) ((f) (i)))) (((((((bigop) (nat)) (i)) (fun i0 : nat => true)) ((S) (O))) (times)) (fun i0 : nat => (f) (i0))))) (x_1))) (((((((((((eq_f2) (nat)) (nat)) (nat)) (times)) (((times) (((exp) (a)) ((S) (i)))) ((f) (i)))) (((times) (((times) (a)) ((f) (i)))) (((exp) (a)) (i)))) (((((((bigop) (nat)) (i)) (fun i0 : nat => true)) ((S) (O))) (times)) (fun i0 : nat => (f) (i0)))) (((((((bigop) (nat)) (i)) (fun i0 : nat => true)) ((S) (O))) (times)) (fun i0 : nat => (f) (i0)))) (((((sym_eq_exp) (a)) ((S) (i))) (fun y : nat => (((eq) (nat)) (((times) (y)) ((f) (i)))) (((times) (((times) (a)) ((f) (i)))) (((exp) (a)) (i))))) ((((((sym_eq_filter_nat_type_S) (nat)) ((exp_body) (a))) (i)) (fun y : nat => (((eq) (nat)) (((times) (y)) ((f) (i)))) (((times) (((times) (a)) ((f) (i)))) (((exp) (a)) (i))))) (((((sym_eq_exp_body_S) (a)) (i)) (fun y : nat => (((eq) (nat)) (((times) (y)) ((f) (i)))) (((times) (((times) (a)) ((f) (i)))) (((exp) (a)) (i))))) (((((((rewrite_r) (nat)) (((times) (a)) (((exp) (a)) (i)))) (fun Joker_ : nat => (((eq) (nat)) (((times) (Joker_)) ((f) (i)))) (((times) (((times) (a)) ((f) (i)))) (((exp) (a)) (i))))) (((((((rewrite_r) (nat)) (((times) ((f) (i))) (((times) (a)) (((exp) (a)) (i))))) (fun Joker_ : nat => (((eq) (nat)) (Joker_)) (((times) (((times) (a)) ((f) (i)))) (((exp) (a)) (i))))) (((((((rewrite_r) (nat)) (((times) (a)) (((times) ((f) (i))) (((exp) (a)) (i))))) (fun Joker_ : nat => (((eq) (nat)) (Joker_)) (((times) (((times) (a)) ((f) (i)))) (((exp) (a)) (i))))) (((((((rewrite_r) (nat)) (((times) (((exp) (a)) (i))) (((times) (a)) ((f) (i))))) (fun Joker_ : nat => (((eq) (nat)) (((times) (a)) (((times) ((f) (i))) (((exp) (a)) (i))))) (Joker_))) (((((((rewrite_r) (nat)) (((times) (a)) (((times) (((exp) (a)) (i))) ((f) (i))))) (fun Joker_ : nat => (((eq) (nat)) (((times) (a)) (((times) ((f) (i))) (((exp) (a)) (i))))) (Joker_))) (((((((rewrite_r) (nat)) (((times) ((f) (i))) (((exp) (a)) (i)))) (fun Joker_ : nat => (((eq) (nat)) (((times) (a)) (((times) ((f) (i))) (((exp) (a)) (i))))) (((times) (a)) (Joker_)))) (((refl) (nat)) (((times) (a)) (((times) ((f) (i))) (((exp) (a)) (i)))))) (((times) (((exp) (a)) (i))) ((f) (i)))) (((commutative_times) (((exp) (a)) (i))) ((f) (i))))) (((times) (((exp) (a)) (i))) (((times) (a)) ((f) (i))))) ((((times_times) (((exp) (a)) (i))) (a)) ((f) (i))))) (((times) (((times) (a)) ((f) (i)))) (((exp) (a)) (i)))) (((commutative_times) (((times) (a)) ((f) (i)))) (((exp) (a)) (i))))) (((times) ((f) (i))) (((times) (a)) (((exp) (a)) (i))))) ((((times_times) ((f) (i))) (a)) (((exp) (a)) (i))))) (((times) (((times) (a)) (((exp) (a)) (i)))) ((f) (i)))) (((commutative_times) (((times) (a)) (((exp) (a)) (i)))) ((f) (i))))) (((times) (((exp) (a)) (i))) (a))) (((commutative_times) (((exp) (a)) (i))) (a))))))) (((refl) (nat)) (((((((bigop) (nat)) (i)) (fun i0 : nat => true)) ((S) (O))) (times)) (fun i0 : nat => (f) (i0)))))) (((times) (((times) (a)) ((f) (i)))) (((times) (((exp) (a)) (i))) (((((((bigop) (nat)) (i)) (fun i0 : nat => true)) ((S) (O))) (times)) (fun i0 : nat => (f) (i0)))))) ((((associative_times) (((times) (a)) ((f) (i)))) (((exp) (a)) (i))) (((((((bigop) (nat)) (i)) (fun i0 : nat => true)) ((S) (O))) (times)) (fun i0 : nat => (f) (i0)))))) (((times) (((exp) (a)) ((S) (i)))) (((times) ((f) (i))) (((((((bigop) (nat)) (i)) (fun i0 : nat => true)) ((S) (O))) (times)) (fun i0 : nat => (f) (i0)))))) ((((associative_times) (((exp) (a)) ((S) (i)))) ((f) (i))) (((((((bigop) (nat)) (i)) (fun i0 : nat => true)) ((S) (O))) (times)) (fun i0 : nat => (f) (i0)))))) (((((((bigop) (nat)) (i)) (fun i0 : nat => true)) ((S) (O))) (times)) (fun i0 : nat => ((times) (a)) ((f) (i0))))) (Hind))) (((((((bigop) (nat)) ((S) (i))) (fun i0 : nat => true)) ((S) (O))) (times)) (fun i0 : nat => ((times) (a)) ((f) (i0))))) ((((((((bigop_Strue) (nat)) (i)) (fun Joker_ : nat => true)) ((S) (O))) (times)) (fun Joker_ : nat => ((times) (a)) ((f) (Joker_)))) (((refl) (bool)) (true))))) (((((((bigop) (nat)) ((S) (i))) (fun i0 : nat => true)) ((S) (O))) (times)) (fun i0 : nat => (f) (i0)))) ((((((((bigop_Strue) (nat)) (i)) (fun Joker_ : nat => true)) ((S) (O))) (times)) (f)) (((refl) (bool)) (true))))) (n).
Definition exp_pi_bc : forall a : nat, forall b : nat, forall c : nat, forall f : (nat) -> nat, (((eq) (nat)) (((times) (((exp) (a)) (((minus) (c)) (b)))) (((((((bigop) (nat)) (((minus) (c)) (b))) (fun i : nat => true)) ((S) (O))) (times)) (fun i : nat => (f) (((plus) (i)) (b)))))) (((((((bigop) (nat)) (((minus) (c)) (b))) (fun i : nat => true)) ((S) (O))) (times)) (fun i : nat => ((times) (a)) ((f) (((plus) (i)) (b))))) := fun a : nat => fun b : nat => fun c : nat => fun f : (nat) -> nat => (((exp_pi_l) (((minus) (c)) (b))) (a)) (fun Joker_ : nat => (f) (((plus) (Joker_)) (b))).
Parameter divides : (nat) -> (nat) -> Prop.
Axiom quotient : forall n : nat, forall m : nat, forall q : nat, ((((eq) (nat)) (m)) (((times) (n)) (q))) -> ((divides) (n)) (m).
Axiom match_divides_prop : forall n : nat, forall m : nat, forall return_type : Prop, (forall q : nat, ((((eq) (nat)) (m)) (((times) (n)) (q))) -> return_type) -> (((divides) (n)) (m)) -> return_type.
Definition reflexive_divides : ((reflexive) (nat)) (divides) := fun x : nat => ((((quotient) (x)) (x)) ((S) (O))) (((((((rewrite_r) (nat)) (((times) (x)) ((S) (O)))) (fun Joker_ : nat => (((eq) (nat)) (Joker_)) (((times) (x)) ((S) (O))))) (((refl) (nat)) (((times) (x)) ((S) (O))))) (x)) ((times_n_1) (x))).
Definition divides_to_div_mod_spec : forall n : nat, forall m : nat, (((lt) (O)) (n)) -> (((divides) (n)) (m)) -> ((((div_mod_spec) (m)) (n)) (((div) (m)) (n))) (O) := fun n : nat => fun m : nat => fun posn : ((lt) (O)) (n) => fun Jokerclearme : ((divides) (n)) (m) => (((((match_divides_prop) (n)) (m)) (((((div_mod_spec) (m)) (n)) (((div) (m)) (n))) (O))) (fun q : nat => fun eqm : (((eq) (nat)) (m)) (((times) (n)) (q)) => ((((((div_mod_spec_intro) (m)) (n)) (((div) (m)) (n))) (O)) (posn)) (((((((eq_ind_r) (nat)) (((times) (n)) (q))) (fun x : nat => (((eq) (nat)) (x)) (((plus) (((times) (((div) (x)) (n))) (n))) (O)))) (((((((eq_ind_r) (nat)) (((times) (q)) (n))) (fun x : nat => (((eq) (nat)) (x)) (((plus) (((times) (((div) (x)) (n))) (n))) (O)))) (((((((eq_ind_r) (nat)) (q)) (fun x : nat => (((eq) (nat)) (((times) (q)) (n))) (((plus) (((times) (x)) (n))) (O)))) (((((((rewrite_r) (nat)) (((times) (n)) (q))) (fun Joker_ : nat => (((eq) (nat)) (Joker_)) (((plus) (((times) (q)) (n))) (O)))) (((((((rewrite_l) (nat)) (m)) (fun Joker_ : nat => (((eq) (nat)) (Joker_)) (((plus) (((times) (q)) (n))) (O)))) (((((((rewrite_r) (nat)) (((times) (n)) (q))) (fun Joker_ : nat => (((eq) (nat)) (m)) (((plus) (Joker_)) (O)))) (((((((rewrite_l) (nat)) (m)) (fun Joker_ : nat => (((eq) (nat)) (m)) (((plus) (Joker_)) (O)))) (((((((rewrite_l) (nat)) (m)) (fun Joker_ : nat => (((eq) (nat)) (m)) (Joker_))) (((refl) (nat)) (m))) (((plus) (m)) (O))) ((plus_n_O) (m)))) (((times) (n)) (q))) (eqm))) (((times) (q)) (n))) (((commutative_times) (q)) (n)))) (((times) (n)) (q))) (eqm))) (((times) (q)) (n))) (((commutative_times) (q)) (n)))) (((div) (((times) (q)) (n))) (n))) ((((div_times) (q)) (n)) (posn)))) (((times) (n)) (q))) (((commutative_times) (n)) (q)))) (m)) (eqm)))) (Jokerclearme).
Definition divides_to_mod_O : forall n : nat, forall m : nat, (((lt) (O)) (n)) -> (((divides) (n)) (m)) -> (((eq) (nat)) (((mod) (m)) (n))) (O) := fun n : nat => fun m : nat => fun posn : ((lt) (O)) (n) => fun divnm : ((divides) (n)) (m) => ((((((((div_mod_spec_to_eq2) (m)) (n)) (((div) (m)) (n))) (((mod) (m)) (n))) (((div) (m)) (n))) (O)) ((((div_mod_spec_div_mod) (m)) (n)) (posn))) (((((divides_to_div_mod_spec) (n)) (m)) (posn)) (divnm)).
Definition mod_O_to_divides : forall n : nat, forall m : nat, (((lt) (O)) (n)) -> ((((eq) (nat)) (((mod) (m)) (n))) (O)) -> ((divides) (n)) (m) := fun n : nat => fun m : nat => fun auto : ((lt) (O)) (n) => fun auto' : (((eq) (nat)) (((mod) (m)) (n))) (O) => ((((quotient) (n)) (m)) (((div) (m)) (n))) (((((((rewrite_l) (nat)) (((times) (n)) (((div) (m)) (n)))) (fun Joker_ : nat => (((eq) (nat)) (Joker_)) (((times) (n)) (((div) (m)) (n))))) (((refl) (nat)) (((times) (n)) (((div) (m)) (n))))) (m)) (((((((rewrite_r) (nat)) (((minus) (m)) (O))) (fun Joker_ : nat => (((eq) (nat)) (((times) (n)) (((div) (m)) (n)))) (Joker_))) (((((((rewrite_l) (nat)) (((mod) (m)) (n))) (fun Joker_ : nat => (((eq) (nat)) (((times) (n)) (((div) (m)) (n)))) (((minus) (m)) (Joker_)))) (((((((rewrite_l) (nat)) (((times) (((div) (m)) (n))) (n))) (fun Joker_ : nat => (((eq) (nat)) (Joker_)) (((minus) (m)) (((mod) (m)) (n))))) (((eq_times_div_minus_mod) (m)) (n))) (((times) (n)) (((div) (m)) (n)))) (((commutative_times) (((div) (m)) (n))) (n)))) (O)) (auto'))) (m)) ((minus_n_O) (m)))).
Definition divides_n_O : forall n : nat, ((divides) (n)) (O) := fun n : nat => ((((quotient) (n)) (O)) (O)) (((((((rewrite_r) (nat)) (((times) (n)) (O))) (fun Joker_ : nat => (((eq) (nat)) (Joker_)) (((times) (n)) (O)))) (((refl) (nat)) (((times) (n)) (O)))) (O)) ((times_n_O) (n))).
Definition divides_n_n : forall n : nat, ((divides) (n)) (n) := fun n : nat => (reflexive_divides) (n).
Definition eq_mod_to_divides : forall n : nat, forall m : nat, forall q : nat, (((lt) (O)) (q)) -> ((((eq) (nat)) (((mod) (n)) (q))) (((mod) (m)) (q))) -> ((divides) (q)) (((minus) (n)) (m)) := fun n : nat => fun m : nat => fun q : nat => fun posq : ((lt) (O)) (q) => fun eqmod : (((eq) (nat)) (((mod) (n)) (q))) (((mod) (m)) (q)) => (((((leb_elim) (n)) (m)) (fun Joker_ : bool => ((divides) (q)) (((minus) (n)) (m)))) (fun nm : ((le) (n)) (m) => ((((eq_coerc) (((divides) (q)) (O))) (((divides) (q)) (((minus) (n)) (m)))) ((divides_n_O) (q))) (((((((rewrite_r) (nat)) (O)) (fun Joker_ : nat => (((eq) Prop) (((divides) (q)) (O))) (((divides) (q)) (Joker_)))) (((refl) Prop) (((divides) (q)) (O)))) (((minus) (n)) (m))) (((((sym_eq) (nat)) (O)) (((minus) (n)) (m))) (((((eq_coerc) ((((eq) (nat)) (((minus) (O)) (((minus) (m)) (n)))) (((minus) (((plus) (O)) (n))) (m)))) ((((eq) (nat)) (O)) (((minus) (n)) (m)))) (((((minus_le_minus_minus_comm) (m)) (n)) (O)) (nm))) (((((((rewrite_l) (nat)) (O)) (fun Joker_ : nat => (((eq) Prop) ((((eq) (nat)) (Joker_)) (((minus) (((plus) (O)) (n))) (m)))) ((((eq) (nat)) (O)) (((minus) (n)) (m))))) (((((((rewrite_l) (nat)) (n)) (fun Joker_ : nat => (((eq) Prop) ((((eq) (nat)) (O)) (((minus) (Joker_)) (m)))) ((((eq) (nat)) (O)) (((minus) (n)) (m))))) (((refl) Prop) ((((eq) (nat)) (O)) (((minus) (n)) (m))))) (((plus) (O)) (n))) ((plus_O_n) (n)))) (((minus) (O)) (((minus) (m)) (n)))) ((minus_O_n) (((minus) (m)) (n))))))))) (fun nm : (Not) (((le) (n)) (m)) => ((((quotient) (q)) (((minus) (n)) (m))) (((minus) (((div) (n)) (q))) (((div) (m)) (q)))) (((((((eq_ind_r) (nat)) (((minus) (((times) (q)) (((div) (n)) (q)))) (((times) (q)) (((div) (m)) (q))))) (fun x : nat => (((eq) (nat)) (((minus) (n)) (m))) (x))) (((((((eq_ind_r) (nat)) (((times) (((div) (n)) (q))) (q))) (fun x : nat => (((eq) (nat)) (((minus) (n)) (m))) (((minus) (x)) (((times) (q)) (((div) (m)) (q)))))) (((((((eq_ind_r) (nat)) (((times) (((div) (m)) (q))) (q))) (fun x : nat => (((eq) (nat)) (((minus) (n)) (m))) (((minus) (((times) (((div) (n)) (q))) (q))) (x)))) (((((((eq_ind_r) (nat)) (((minus) (n)) (((mod) (n)) (q)))) (fun x : nat => (((eq) (nat)) (((minus) (n)) (m))) (((minus) (x)) (((times) (((div) (m)) (q))) (q))))) (((((((eq_ind_r) (nat)) (((minus) (n)) (((plus) (((mod) (n)) (q))) (((times) (((div) (m)) (q))) (q))))) (fun x : nat => (((eq) (nat)) (((minus) (n)) (m))) (x))) (((((((eq_ind_r) (nat)) (((mod) (m)) (q))) (fun x : nat => (((eq) (nat)) (((minus) (n)) (m))) (((minus) (n)) (((plus) (x)) (((times) (((div) (m)) (q))) (q)))))) (((((((eq_ind_r) (nat)) (((plus) (((times) (((div) (m)) (q))) (q))) (((mod) (m)) (q)))) (fun x : nat => (((eq) (nat)) (((minus) (n)) (m))) (((minus) (n)) (x)))) (((((((eq_ind) (nat)) (m)) (fun x_1 : nat => (((eq) (nat)) (((minus) (n)) (m))) (((minus) (n)) (x_1)))) (((refl) (nat)) (((minus) (n)) (m)))) (((plus) (((times) (((div) (m)) (q))) (q))) (((mod) (m)) (q)))) (((div_mod) (m)) (q)))) (((plus) (((mod) (m)) (q))) (((times) (((div) (m)) (q))) (q)))) (((commutative_plus) (((mod) (m)) (q))) (((times) (((div) (m)) (q))) (q))))) (((mod) (n)) (q))) (eqmod))) (((minus) (((minus) (n)) (((mod) (n)) (q)))) (((times) (((div) (m)) (q))) (q)))) ((((minus_plus) (n)) (((mod) (n)) (q))) (((times) (((div) (m)) (q))) (q))))) (((times) (((div) (n)) (q))) (q))) (((((((rewrite_r) (nat)) (((times) (q)) (((div) (n)) (q)))) (fun Joker_ : nat => (((eq) (nat)) (Joker_)) (((minus) (n)) (((mod) (n)) (q))))) (((((((rewrite_l) (nat)) (((times) (q)) (((div) (n)) (q)))) (fun Joker_ : nat => (((eq) (nat)) (((times) (q)) (((div) (n)) (q)))) (Joker_))) (((refl) (nat)) (((times) (q)) (((div) (n)) (q))))) (((minus) (n)) (((mod) (n)) (q)))) (((((((rewrite_l) (nat)) (((times) (((div) (n)) (q))) (q))) (fun Joker_ : nat => (((eq) (nat)) (Joker_)) (((minus) (n)) (((mod) (n)) (q))))) (((eq_times_div_minus_mod) (n)) (q))) (((times) (q)) (((div) (n)) (q)))) (((commutative_times) (((div) (n)) (q))) (q))))) (((times) (((div) (n)) (q))) (q))) (((commutative_times) (((div) (n)) (q))) (q))))) (((times) (q)) (((div) (m)) (q)))) (((commutative_times) (q)) (((div) (m)) (q))))) (((times) (q)) (((div) (n)) (q)))) (((commutative_times) (q)) (((div) (n)) (q))))) (((times) (q)) (((minus) (((div) (n)) (q))) (((div) (m)) (q))))) ((((distributive_times_minus) (q)) (((div) (n)) (q))) (((div) (m)) (q))))).
Definition let_clause_1531 : forall n : nat, forall m : nat, (((lt) (O)) (m)) -> (((divides) (n)) (m)) -> forall d : nat, ((((eq) (nat)) (m)) (((times) (n)) (O))) -> (((eq) (nat)) (m)) (O) := fun n : nat => fun m : nat => fun posm : ((lt) (O)) (m) => fun Jokerclearme : ((divides) (n)) (m) => fun d : nat => fun eqm : (((eq) (nat)) (m)) (((times) (n)) (O)) => ((((((rewrite_r) (nat)) (((times) (n)) (O))) (fun Joker_ : nat => (((eq) (nat)) (m)) (Joker_))) (eqm)) (O)) ((times_n_O) (n)).
Definition let_clause_15311 : forall n : nat, forall m : nat, (((lt) (O)) (m)) -> (((divides) (n)) (m)) -> forall d : nat, forall p : nat, ((((eq) (nat)) (m)) (((times) (n)) ((S) (p)))) -> (((eq) (nat)) (m)) (((plus) (n)) (((times) (n)) (p))) := fun n : nat => fun m : nat => fun posm : ((lt) (O)) (m) => fun Jokerclearme : ((divides) (n)) (m) => fun d : nat => fun p : nat => fun eqm : (((eq) (nat)) (m)) (((times) (n)) ((S) (p))) => ((((((rewrite_r) (nat)) (((times) (n)) ((S) (p)))) (fun Joker_ : nat => (((eq) (nat)) (m)) (Joker_))) (eqm)) (((plus) (n)) (((times) (n)) (p)))) (((times_n_Sm) (n)) (p)).
Definition divides_to_le : forall n : nat, forall m : nat, (((lt) (O)) (m)) -> (((divides) (n)) (m)) -> ((le) (n)) (m) := fun n : nat => fun m : nat => fun posm : ((lt) (O)) (m) => fun Jokerclearme : ((divides) (n)) (m) => (((((match_divides_prop) (n)) (m)) (((le) (n)) (m))) (fun d : nat => ((((match_nat_prop) (fun Joker_ : nat => ((((eq) (nat)) (m)) (((times) (n)) (Joker_))) -> ((le) (n)) (m))) (fun eqm : (((eq) (nat)) (m)) (((times) (n)) (O)) => ((falsity) (((le) (n)) (m))) ((((absurd) (((le) ((S) (m))) (O))) (((((eq_coerc) (((le) ((S) (O))) (m))) (((le) ((S) (m))) (O))) (posm)) (((((((rewrite_l) (nat)) (m)) (fun Joker_ : nat => (((eq) Prop) (((le) ((S) (Joker_))) (m))) (((le) ((S) (m))) (O)))) (((((((rewrite_l) (nat)) (m)) (fun Joker_ : nat => (((eq) Prop) (((le) ((S) (m))) (m))) (((le) ((S) (m))) (Joker_)))) (((refl) Prop) (((le) ((S) (m))) (m)))) (O)) (((((((let_clause_1531) (n)) (m)) (posm)) (Jokerclearme)) (d)) (eqm)))) (O)) (((((((let_clause_1531) (n)) (m)) (posm)) (Jokerclearme)) (d)) (eqm))))) ((not_le_Sn_O) (m))))) (fun p : nat => fun eqm : (((eq) (nat)) (m)) (((times) (n)) ((S) (p))) => ((((((eq_ind_r) (nat)) (((times) (n)) ((S) (p)))) (fun x : nat => ((le) (n)) (x))) (((((eq_coerc) (((le) (n)) (((plus) (n)) (((times) (n)) (p))))) (((le) (n)) (((times) (n)) ((S) (p))))) (((le_plus_n_r) (((times) (n)) (p))) (n))) (((((((rewrite_l) (nat)) (((plus) (n)) (((times) (n)) (p)))) (fun Joker_ : nat => (((eq) Prop) (((le) (n)) (((plus) (n)) (((times) (n)) (p))))) (((le) (n)) (Joker_)))) (((((((rewrite_l) (nat)) (m)) (fun Joker_ : nat => (((eq) Prop) (((le) (n)) (((plus) (n)) (((times) (n)) (p))))) (((le) (n)) (Joker_)))) (((((((rewrite_l) (nat)) (m)) (fun Joker_ : nat => (((eq) Prop) (((le) (n)) (Joker_))) (((le) (n)) (m)))) (((refl) Prop) (((le) (n)) (m)))) (((plus) (n)) (((times) (n)) (p)))) ((((((((let_clause_15311) (n)) (m)) (posm)) (Jokerclearme)) (d)) (p)) (eqm)))) (((plus) (n)) (((times) (n)) (p)))) ((((((((let_clause_15311) (n)) (m)) (posm)) (Jokerclearme)) (d)) (p)) (eqm)))) (((times) (n)) ((S) (p)))) (((times_n_Sm) (n)) (p))))) (m)) (eqm))) (d))) (Jokerclearme).
Definition dividesb : (nat) -> (nat) -> bool := fun n : nat => fun m : nat => ((eqb) (((mod) (m)) (n))) (O).
Definition dividesb_true_to_divides : forall n : nat, forall m : nat, ((((eq) (bool)) (((dividesb) (n)) (m))) (true)) -> ((divides) (n)) (m) := fun n : nat => fun m : nat => ((((((match_Or_prop) (((lt) (O)) (n))) ((((eq) (nat)) (O)) (n))) (((((eq) (bool)) (((dividesb) (n)) (m))) (true)) -> ((divides) (n)) (m))) (fun posn : ((lt) (O)) (n) => fun divbnm : (((eq) (bool)) (((dividesb) (n)) (m))) (true) => ((((mod_O_to_divides) (n)) (m)) (posn)) ((((eqb_true_to_eq) (((mod) (m)) (n))) (O)) (divbnm)))) (fun eqnO : (((eq) (nat)) (O)) (n) => ((((((eq_ind) (nat)) (O)) (fun x_1 : nat => ((((eq) (bool)) (((dividesb) (x_1)) (m))) (true)) -> ((divides) (x_1)) (m))) ((((((sym_eq_match_nat_type_O) (nat)) (m)) (fun p : nat => (((mod_aux) (m)) (m)) (p))) (fun y : nat => ((((eq) (bool)) (((eqb) (y)) (O))) (true)) -> ((divides) (O)) (m))) (fun eqbmO : (((eq) (bool)) (((eqb) (m)) (O))) (true) => ((((((eq_ind_r) (nat)) (O)) (fun x : nat => ((divides) (O)) (x))) ((divides_n_n) (O))) (m)) ((((eqb_true_to_eq) (m)) (O)) (eqbmO))))) (n)) (eqnO))) ((((le_to_or_lt_eq) (O)) (n)) ((le_O_n) (n))).
Definition dividesb_false_to_not_divides : forall n : nat, forall m : nat, ((((eq) (bool)) (((dividesb) (n)) (m))) (false)) -> (Not) (((divides) (n)) (m)) := fun n : nat => fun m : nat => ((((((match_Or_prop) (((lt) (O)) (n))) ((((eq) (nat)) (O)) (n))) (((((eq) (bool)) (((dividesb) (n)) (m))) (false)) -> (Not) (((divides) (n)) (m)))) (fun posn : ((lt) (O)) (n) => fun ndivbnm : (((eq) (bool)) (((dividesb) (n)) (m))) (false) => ((((not_to_not) (((divides) (n)) (m))) ((((eq) (nat)) (((mod) (m)) (n))) (O))) ((((divides_to_mod_O) (n)) (m)) (posn))) ((((eqb_false_to_not_eq) (((mod) (m)) (n))) (O)) (ndivbnm)))) (fun eqnO : (((eq) (nat)) (O)) (n) => ((((((eq_ind) (nat)) (O)) (fun x_1 : nat => ((((eq) (bool)) (((dividesb) (x_1)) (m))) (false)) -> (Not) (((divides) (x_1)) (m)))) ((((((sym_eq_match_nat_type_O) (nat)) (m)) (fun p : nat => (((mod_aux) (m)) (m)) (p))) (fun y : nat => ((((eq) (bool)) (((eqb) (y)) (O))) (false)) -> (Not) (((divides) (O)) (m)))) (((((nat_case) (m)) (fun Joker_ : nat => ((((eq) (bool)) (((eqb) (Joker_)) (O))) (false)) -> (Not) (((divides) (O)) (Joker_)))) ((((sym_eq_eqb) (O)) (fun y : (nat) -> bool => ((((eq) (nat)) (m)) (O)) -> ((((eq) (bool)) ((y) (O))) (false)) -> (Not) (((divides) (O)) (O)))) (((((sym_eq_filter_nat_type_O) ((nat) -> bool)) (eqb_body)) (fun y : (nat) -> bool => ((((eq) (nat)) (m)) (O)) -> ((((eq) (bool)) ((y) (O))) (false)) -> (Not) (((divides) (O)) (O)))) (((sym_eq_eqb_body_O) (fun y : (nat) -> bool => ((((eq) (nat)) (m)) (O)) -> ((((eq) (bool)) ((y) (O))) (false)) -> (Not) (((divides) (O)) (O)))) ((((((sym_eq_match_nat_type_O) (bool)) (true)) (fun q : nat => false)) (fun y : bool => ((((eq) (nat)) (m)) (O)) -> ((((eq) (bool)) (y)) (false)) -> (Not) (((divides) (O)) (O)))) (fun auto : (((eq) (nat)) (m)) (O) => fun auto' : (((eq) (bool)) (true)) (false) => ((((not_to_not) (((divides) (O)) (O))) ((((eq) (bool)) (true)) (false))) (fun auto'' : ((divides) (O)) (O) => ((((((rewrite_l) (bool)) (true)) (fun Joker_ : bool => (((eq) (bool)) (true)) (Joker_))) (((refl) (bool)) (true))) (false)) (auto'))) (not_eq_true_false))))))) (fun a : nat => fun Joker_ : (((eq) (nat)) (m)) ((S) (a)) => fun Joker0 : (((eq) (bool)) (((eqb) ((S) (a))) (O))) (false) => fun Jokerclearme : ((divides) (O)) ((S) (a)) => (((((match_divides_prop) (O)) ((S) (a))) (False)) (fun q : nat => fun auto : (((eq) (nat)) ((S) (a))) (((times) (O)) (q)) => (((absurd) ((((eq) (nat)) (O)) ((S) (a)))) (((((((rewrite_r) (nat)) (n)) (fun Joker_1 : nat => (((eq) (nat)) (Joker_1)) ((S) (a)))) (((((((rewrite_l) (nat)) ((S) (a))) (fun Joker_1 : nat => (((eq) (nat)) (Joker_1)) ((S) (a)))) (((refl) (nat)) ((S) (a)))) (n)) (((((((rewrite_l) (nat)) (O)) (fun Joker_1 : nat => (((eq) (nat)) ((S) (a))) (Joker_1))) (((((((rewrite_r) (nat)) (((times) (q)) (O))) (fun Joker_1 : nat => (((eq) (nat)) ((S) (a))) (Joker_1))) (((((((rewrite_l) (nat)) (((times) (O)) (q))) (fun Joker_1 : nat => (((eq) (nat)) ((S) (a))) (Joker_1))) (auto)) (((times) (q)) (O))) (((commutative_times) (O)) (q)))) (O)) ((times_n_O) (q)))) (n)) (eqnO)))) (O)) (eqnO))) ((not_eq_O_S) (a)))) (Jokerclearme))))) (n)) (eqnO))) ((((le_to_or_lt_eq) (O)) (n)) ((le_O_n) (n))).
Definition decidable_divides : forall n : nat, forall m : nat, (decidable) (((divides) (n)) (m)) := fun n : nat => fun m : nat => ((((((match_Or_prop) ((((eq) (bool)) (((dividesb) (n)) (m))) (true))) ((((eq) (bool)) (((dividesb) (n)) (m))) (false))) ((decidable) (((divides) (n)) (m)))) (fun auto : (((eq) (bool)) (((dividesb) (n)) (m))) (true) => fun z : Prop => fun l : (((divides) (n)) (m)) -> z => fun r : ((Not) (((divides) (n)) (m))) -> z => (l) ((((dividesb_true_to_divides) (n)) (m)) (((((((rewrite_r) (bool)) (true)) (fun Joker_ : bool => (((eq) (bool)) (Joker_)) (true))) (((refl) (bool)) (true))) (((dividesb) (n)) (m))) (auto))))) (fun auto : (((eq) (bool)) (((dividesb) (n)) (m))) (false) => fun z : Prop => fun l : (((divides) (n)) (m)) -> z => fun r : ((Not) (((divides) (n)) (m))) -> z => (r) ((((dividesb_false_to_not_divides) (n)) (m)) (((((((rewrite_r) (bool)) (false)) (fun Joker_ : bool => (((eq) (bool)) (Joker_)) (false))) (((refl) (bool)) (false))) (((dividesb) (n)) (m))) (auto))))) ((true_or_false) (((dividesb) (n)) (m))).
Definition divides_to_dividesb_true : forall n : nat, forall m : nat, (((lt) (O)) (n)) -> (((divides) (n)) (m)) -> (((eq) (bool)) (((dividesb) (n)) (m))) (true) := fun n : nat => fun m : nat => fun posn : ((lt) (O)) (n) => fun divnm : ((divides) (n)) (m) => ((((((match_Or_prop) ((((eq) (bool)) (((dividesb) (n)) (m))) (true))) ((((eq) (bool)) (((dividesb) (n)) (m))) (false))) ((((eq) (bool)) (((dividesb) (n)) (m))) (true))) (fun auto : (((eq) (bool)) (((dividesb) (n)) (m))) (true) => ((((((rewrite_r) (bool)) (true)) (fun Joker_ : bool => (((eq) (bool)) (Joker_)) (true))) (((refl) (bool)) (true))) (((dividesb) (n)) (m))) (auto))) (fun ndivbnm : (((eq) (bool)) (((dividesb) (n)) (m))) (false) => ((falsity) ((((eq) (bool)) (((dividesb) (n)) (m))) (true))) ((((absurd) (((divides) (n)) (m))) (divnm)) ((((dividesb_false_to_not_divides) (n)) (m)) (((((((rewrite_r) (bool)) (false)) (fun Joker_ : bool => (((eq) (bool)) (Joker_)) (false))) (((refl) (bool)) (false))) (((dividesb) (n)) (m))) (ndivbnm)))))) ((true_or_false) (((dividesb) (n)) (m))).
Definition not_divides_to_dividesb_false : forall n : nat, forall m : nat, (((lt) (O)) (n)) -> ((Not) (((divides) (n)) (m))) -> (((eq) (bool)) (((dividesb) (n)) (m))) (false) := fun n : nat => fun m : nat => fun posn : ((lt) (O)) (n) => ((((((match_Or_prop) ((((eq) (bool)) (((dividesb) (n)) (m))) (true))) ((((eq) (bool)) (((dividesb) (n)) (m))) (false))) (((Not) (((divides) (n)) (m))) -> (((eq) (bool)) (((dividesb) (n)) (m))) (false))) (fun divbnm : (((eq) (bool)) (((dividesb) (n)) (m))) (true) => fun ndivnm : (Not) (((divides) (n)) (m)) => ((falsity) ((((eq) (bool)) (((dividesb) (n)) (m))) (false))) ((((absurd) (((divides) (n)) (m))) ((((dividesb_true_to_divides) (n)) (m)) (((((((rewrite_r) (bool)) (true)) (fun Joker_ : bool => (((eq) (bool)) (Joker_)) (true))) (((refl) (bool)) (true))) (((dividesb) (n)) (m))) (divbnm)))) (ndivnm)))) (fun auto : (((eq) (bool)) (((dividesb) (n)) (m))) (false) => fun auto' : (Not) (((divides) (n)) (m)) => ((((((rewrite_r) (bool)) (false)) (fun Joker_ : bool => (((eq) (bool)) (Joker_)) (false))) (((refl) (bool)) (false))) (((dividesb) (n)) (m))) (auto))) ((true_or_false) (((dividesb) (n)) (m))).
Definition prime : (nat) -> Prop := fun n : nat => ((And) (((lt) ((S) (O))) (n))) (forall m : nat, (((divides) (m)) (n)) -> (((lt) ((S) (O))) (m)) -> (((eq) (nat)) (m)) (n)).
Definition prime_to_lt_O : forall p : nat, ((prime) (p)) -> ((lt) (O)) (p) := fun p : nat => fun Jokerclearme : (prime) (p) => (((((match_And_prop) (((lt) ((S) (O))) (p))) (forall m : nat, (((divides) (m)) (p)) -> (((lt) ((S) (O))) (m)) -> (((eq) (nat)) (m)) (p))) (((lt) (O)) (p))) (fun lt1p : ((lt) ((S) (O))) (p) => fun auto : forall m : nat, (((divides) (m)) (p)) -> (((lt) ((S) (O))) (m)) -> (((eq) (nat)) (m)) (p) => (((lt_S_to_lt) (O)) (p)) (lt1p))) (Jokerclearme).
Definition prime_to_lt_SO : forall p : nat, ((prime) (p)) -> ((lt) ((S) (O))) (p) := fun p : nat => fun Jokerclearme : (prime) (p) => (((((match_And_prop) (((lt) ((S) (O))) (p))) (forall m : nat, (((divides) (m)) (p)) -> (((lt) ((S) (O))) (m)) -> (((eq) (nat)) (m)) (p))) (((lt) ((S) (O))) (p))) (fun lt1p : ((lt) ((S) (O))) (p) => fun auto : forall m : nat, (((divides) (m)) (p)) -> (((lt) ((S) (O))) (m)) -> (((eq) (nat)) (m)) (p) => lt1p)) (Jokerclearme).
Definition injn : ((nat) -> nat) -> (nat) -> Prop := fun f : (nat) -> nat => fun n : nat => forall i : nat, forall j : nat, (((le) (i)) (n)) -> (((le) (j)) (n)) -> ((((eq) (nat)) ((f) (i))) ((f) (j))) -> (((eq) (nat)) (i)) (j).
Definition injn_Sn_n : forall f : (nat) -> nat, forall n : nat, (((injn) (f)) ((S) (n))) -> ((injn) (f)) (n) := fun f : (nat) -> nat => fun n : nat => fun H : ((injn) (f)) ((S) (n)) => fun i : nat => fun j : nat => fun lei : ((le) (i)) (n) => fun lej : ((le) (j)) (n) => fun eqf : (((eq) (nat)) ((f) (i))) ((f) (j)) => (((((H) (i)) (j)) ((((le_S) (i)) (n)) (lei))) ((((le_S) (j)) (n)) (lej))) (((((((rewrite_l) (nat)) ((f) (i))) (fun Joker_ : nat => (((eq) (nat)) ((f) (i))) (Joker_))) (((refl) (nat)) ((f) (i)))) ((f) (j))) (eqf)).
Definition permut : ((nat) -> nat) -> (nat) -> Prop := fun f : (nat) -> nat => fun m : nat => ((And) (forall i : nat, (((le) (i)) (m)) -> ((le) ((f) (i))) (m))) (((injn) (f)) (m)).
Definition transpose : (nat) -> (nat) -> (nat) -> nat := fun i : nat => fun j : nat => fun n : nat => ((((match_bool_type) (nat)) (j)) (((((match_bool_type) (nat)) (i)) (n)) (((eqb) (n)) (j)))) (((eqb) (n)) (i)).
Definition transpose_i_j_i : forall i : nat, forall j : nat, (((eq) (nat)) ((((transpose) (i)) (j)) (i))) (j) := fun i : nat => fun j : nat => ((((((eq_ind_r) (bool)) (true)) (fun x : bool => (((eq) (nat)) (((((match_bool_type) (nat)) (j)) (((((match_bool_type) (nat)) (i)) (i)) (((eqb) (i)) (j)))) (x))) (j))) ((((((eq_match_bool_type_true) (nat)) (j)) (((((match_bool_type) (nat)) (i)) (i)) (((eqb) (i)) (j)))) (fun y : nat => (((eq) (nat)) (((((match_bool_type) (nat)) (j)) (((((match_bool_type) (nat)) (i)) (i)) (((eqb) (i)) (j)))) (true))) (y))) (((refl) (nat)) (((((match_bool_type) (nat)) (j)) (((((match_bool_type) (nat)) (i)) (i)) (((eqb) (i)) (j)))) (true))))) (((eqb) (i)) (i))) ((eqb_n_n) (i)).
Definition transpose_i_j_j : forall i : nat, forall j : nat, (((eq) (nat)) ((((transpose) (i)) (j)) (j))) (i) := fun i : nat => fun j : nat => ((((((match_Or_prop) ((((eq) (bool)) (((eqb) (j)) (i))) (true))) ((((eq) (bool)) (((eqb) (j)) (i))) (false))) ((((eq) (nat)) (((((match_bool_type) (nat)) (j)) (((((match_bool_type) (nat)) (i)) (j)) (((eqb) (j)) (j)))) (((eqb) (j)) (i)))) (i))) (fun Hc : (((eq) (bool)) (((eqb) (j)) (i))) (true) => ((((((eq_ind_r) (bool)) (true)) (fun x : bool => (((eq) (nat)) (((((match_bool_type) (nat)) (j)) (((((match_bool_type) (nat)) (i)) (j)) (((eqb) (j)) (j)))) (x))) (i))) ((((((sym_eq_match_bool_type_true) (nat)) (j)) (((((match_bool_type) (nat)) (i)) (j)) (((eqb) (j)) (j)))) (fun y : nat => (((eq) (nat)) (y)) (i))) (((((((eq_ind_r) (nat)) (i)) (fun x : nat => (((eq) (nat)) (x)) (i))) (((refl) (nat)) (i))) (j)) ((((eqb_true_to_eq) (j)) (i)) (Hc))))) (((eqb) (j)) (i))) (Hc))) (fun Hc : (((eq) (bool)) (((eqb) (j)) (i))) (false) => ((((((eq_ind_r) (bool)) (false)) (fun x : bool => (((eq) (nat)) (((((match_bool_type) (nat)) (j)) (((((match_bool_type) (nat)) (i)) (j)) (((eqb) (j)) (j)))) (x))) (i))) (((((((eq_ind_r) (bool)) (true)) (fun x : bool => (((eq) (nat)) (((((match_bool_type) (nat)) (j)) (((((match_bool_type) (nat)) (i)) (j)) (x))) (false))) (i))) ((((((sym_eq_match_bool_type_false) (nat)) (j)) (((((match_bool_type) (nat)) (i)) (j)) (true))) (fun y : nat => (((eq) (nat)) (y)) (i))) ((((((eq_match_bool_type_true) (nat)) (i)) (j)) (fun y : nat => (((eq) (nat)) (((((match_bool_type) (nat)) (i)) (j)) (true))) (y))) ((((((eq_match_bool_type_false) (nat)) (j)) (((((match_bool_type) (nat)) (i)) (j)) (true))) (fun y : nat => (((eq) (nat)) (((((match_bool_type) (nat)) (i)) (j)) (true))) (y))) ((((((eq_match_bool_type_false) (nat)) (j)) (((((match_bool_type) (nat)) (i)) (j)) (true))) (fun y : nat => (((eq) (nat)) (y)) (((((match_bool_type) (nat)) (j)) (((((match_bool_type) (nat)) (i)) (j)) (true))) (false)))) (((refl) (nat)) (((((match_bool_type) (nat)) (j)) (((((match_bool_type) (nat)) (i)) (j)) (true))) (false)))))))) (((eqb) (j)) (j))) ((eqb_n_n) (j)))) (((eqb) (j)) (i))) (Hc))) ((true_or_false) (((eqb) (j)) (i))).
Definition transpose_i_j_j_i : forall i : nat, forall j : nat, forall n : nat, (((eq) (nat)) ((((transpose) (i)) (j)) (n))) ((((transpose) (j)) (i)) (n)) := fun i : nat => fun j : nat => fun n : nat => ((((((match_Or_prop) ((((eq) (bool)) (((eqb) (n)) (i))) (true))) ((((eq) (bool)) (((eqb) (n)) (i))) (false))) ((((eq) (nat)) (((((match_bool_type) (nat)) (j)) (((((match_bool_type) (nat)) (i)) (n)) (((eqb) (n)) (j)))) (((eqb) (n)) (i)))) (((((match_bool_type) (nat)) (i)) (((((match_bool_type) (nat)) (j)) (n)) (((eqb) (n)) (i)))) (((eqb) (n)) (j))))) (fun Hni : (((eq) (bool)) (((eqb) (n)) (i))) (true) => ((((((eq_ind_r) (bool)) (true)) (fun x : bool => (((eq) (nat)) (((((match_bool_type) (nat)) (j)) (((((match_bool_type) (nat)) (i)) (n)) (((eqb) (n)) (j)))) (x))) (((((match_bool_type) (nat)) (i)) (((((match_bool_type) (nat)) (j)) (n)) (x))) (((eqb) (n)) (j))))) (((((((match_Or_prop) ((((eq) (bool)) (((eqb) (n)) (j))) (true))) ((((eq) (bool)) (((eqb) (n)) (j))) (false))) ((((eq) (nat)) (((((match_bool_type) (nat)) (j)) (((((match_bool_type) (nat)) (i)) (n)) (((eqb) (n)) (j)))) (true))) (((((match_bool_type) (nat)) (i)) (((((match_bool_type) (nat)) (j)) (n)) (true))) (((eqb) (n)) (j))))) (fun Hnj : (((eq) (bool)) (((eqb) (n)) (j))) (true) => ((((((eq_ind_r) (bool)) (true)) (fun x : bool => (((eq) (nat)) (((((match_bool_type) (nat)) (j)) (((((match_bool_type) (nat)) (i)) (n)) (x))) (true))) (((((match_bool_type) (nat)) (i)) (((((match_bool_type) (nat)) (j)) (n)) (true))) (x)))) ((((((sym_eq_match_bool_type_true) (nat)) (j)) (((((match_bool_type) (nat)) (i)) (n)) (true))) (fun y : nat => (((eq) (nat)) (y)) (((((match_bool_type) (nat)) (i)) (((((match_bool_type) (nat)) (j)) (n)) (true))) (true)))) ((((((sym_eq_match_bool_type_true) (nat)) (i)) (((((match_bool_type) (nat)) (j)) (n)) (true))) (fun y : nat => (((eq) (nat)) (j)) (y))) (((((((eq_ind) (nat)) (n)) (fun x_1 : nat => (((eq) (nat)) (j)) (x_1))) (((((((eq_ind) (nat)) (n)) (fun x_1 : nat => (((eq) (nat)) (x_1)) (n))) (((refl) (nat)) (n))) (j)) ((((eqb_true_to_eq) (n)) (j)) (Hnj)))) (i)) ((((eqb_true_to_eq) (n)) (i)) (Hni)))))) (((eqb) (n)) (j))) (Hnj))) (fun Hnj : (((eq) (bool)) (((eqb) (n)) (j))) (false) => ((((((eq_ind_r) (bool)) (false)) (fun x : bool => (((eq) (nat)) (((((match_bool_type) (nat)) (j)) (((((match_bool_type) (nat)) (i)) (n)) (x))) (true))) (((((match_bool_type) (nat)) (i)) (((((match_bool_type) (nat)) (j)) (n)) (true))) (x)))) ((((((sym_eq_match_bool_type_false) (nat)) (i)) (n)) (fun y : nat => (((eq) (nat)) (((((match_bool_type) (nat)) (j)) (y)) (true))) (((((match_bool_type) (nat)) (i)) (((((match_bool_type) (nat)) (j)) (n)) (true))) (false)))) ((((((sym_eq_match_bool_type_false) (nat)) (i)) (((((match_bool_type) (nat)) (j)) (n)) (true))) (fun y : nat => (((eq) (nat)) (((((match_bool_type) (nat)) (j)) (n)) (true))) (y))) ((((((sym_eq_match_bool_type_true) (nat)) (j)) (n)) (fun y : nat => (((eq) (nat)) (((((match_bool_type) (nat)) (j)) (n)) (true))) (y))) ((((((sym_eq_match_bool_type_true) (nat)) (j)) (n)) (fun y : nat => (((eq) (nat)) (y)) (j))) (((refl) (nat)) (j))))))) (((eqb) (n)) (j))) (Hnj))) ((true_or_false) (((eqb) (n)) (j))))) (((eqb) (n)) (i))) (Hni))) (fun Hni : (((eq) (bool)) (((eqb) (n)) (i))) (false) => ((((((eq_ind_r) (bool)) (false)) (fun x : bool => (((eq) (nat)) (((((match_bool_type) (nat)) (j)) (((((match_bool_type) (nat)) (i)) (n)) (((eqb) (n)) (j)))) (x))) (((((match_bool_type) (nat)) (i)) (((((match_bool_type) (nat)) (j)) (n)) (x))) (((eqb) (n)) (j))))) (((((((match_Or_prop) ((((eq) (bool)) (((eqb) (n)) (j))) (true))) ((((eq) (bool)) (((eqb) (n)) (j))) (false))) ((((eq) (nat)) (((((match_bool_type) (nat)) (j)) (((((match_bool_type) (nat)) (i)) (n)) (((eqb) (n)) (j)))) (false))) (((((match_bool_type) (nat)) (i)) (((((match_bool_type) (nat)) (j)) (n)) (false))) (((eqb) (n)) (j))))) (fun Hnj : (((eq) (bool)) (((eqb) (n)) (j))) (true) => ((((((eq_ind_r) (bool)) (true)) (fun x : bool => (((eq) (nat)) (((((match_bool_type) (nat)) (j)) (((((match_bool_type) (nat)) (i)) (n)) (x))) (false))) (((((match_bool_type) (nat)) (i)) (((((match_bool_type) (nat)) (j)) (n)) (false))) (x)))) ((((((sym_eq_match_bool_type_false) (nat)) (j)) (((((match_bool_type) (nat)) (i)) (n)) (true))) (fun y : nat => (((eq) (nat)) (y)) (((((match_bool_type) (nat)) (i)) (((((match_bool_type) (nat)) (j)) (n)) (false))) (true)))) ((((((sym_eq_match_bool_type_false) (nat)) (j)) (n)) (fun y : nat => (((eq) (nat)) (((((match_bool_type) (nat)) (i)) (n)) (true))) (((((match_bool_type) (nat)) (i)) (y)) (true)))) ((((((sym_eq_match_bool_type_true) (nat)) (i)) (n)) (fun y : nat => (((eq) (nat)) (((((match_bool_type) (nat)) (i)) (n)) (true))) (y))) ((((((sym_eq_match_bool_type_true) (nat)) (i)) (n)) (fun y : nat => (((eq) (nat)) (y)) (i))) (((refl) (nat)) (i))))))) (((eqb) (n)) (j))) (Hnj))) (fun Hnj : (((eq) (bool)) (((eqb) (n)) (j))) (false) => ((((((eq_ind_r) (bool)) (false)) (fun x : bool => (((eq) (nat)) (((((match_bool_type) (nat)) (j)) (((((match_bool_type) (nat)) (i)) (n)) (x))) (false))) (((((match_bool_type) (nat)) (i)) (((((match_bool_type) (nat)) (j)) (n)) (false))) (x)))) ((((((sym_eq_match_bool_type_false) (nat)) (i)) (n)) (fun y : nat => (((eq) (nat)) (((((match_bool_type) (nat)) (j)) (y)) (false))) (((((match_bool_type) (nat)) (i)) (((((match_bool_type) (nat)) (j)) (n)) (false))) (false)))) ((((((sym_eq_match_bool_type_false) (nat)) (j)) (n)) (fun y : nat => (((eq) (nat)) (((((match_bool_type) (nat)) (j)) (n)) (false))) (((((match_bool_type) (nat)) (i)) (y)) (false)))) ((((((sym_eq_match_bool_type_false) (nat)) (j)) (n)) (fun y : nat => (((eq) (nat)) (y)) (((((match_bool_type) (nat)) (i)) (n)) (false)))) ((((((sym_eq_match_bool_type_false) (nat)) (i)) (n)) (fun y : nat => (((eq) (nat)) (n)) (y))) (((refl) (nat)) (n))))))) (((eqb) (n)) (j))) (Hnj))) ((true_or_false) (((eqb) (n)) (j))))) (((eqb) (n)) (i))) (Hni))) ((true_or_false) (((eqb) (n)) (i))).
Definition transpose_transpose : forall i : nat, forall j : nat, forall n : nat, (((eq) (nat)) ((((transpose) (i)) (j)) ((((transpose) (i)) (j)) (n)))) (n) := fun i : nat => fun j : nat => fun n : nat => ((((((match_Or_prop) ((((eq) (bool)) (((eqb) (n)) (i))) (true))) ((((eq) (bool)) (((eqb) (n)) (i))) (false))) ((((eq) (nat)) (((((match_bool_type) (nat)) (j)) (((((match_bool_type) (nat)) (i)) (((((match_bool_type) (nat)) (j)) (((((match_bool_type) (nat)) (i)) (n)) (((eqb) (n)) (j)))) (((eqb) (n)) (i)))) (((eqb) (((((match_bool_type) (nat)) (j)) (((((match_bool_type) (nat)) (i)) (n)) (((eqb) (n)) (j)))) (((eqb) (n)) (i)))) (j)))) (((eqb) (((((match_bool_type) (nat)) (j)) (((((match_bool_type) (nat)) (i)) (n)) (((eqb) (n)) (j)))) (((eqb) (n)) (i)))) (i)))) (n))) (fun Hni : (((eq) (bool)) (((eqb) (n)) (i))) (true) => ((((((eq_ind_r) (bool)) (true)) (fun x : bool => (((eq) (nat)) (((((match_bool_type) (nat)) (j)) (((((match_bool_type) (nat)) (i)) (((((match_bool_type) (nat)) (j)) (((((match_bool_type) (nat)) (i)) (n)) (((eqb) (n)) (j)))) (x))) (((eqb) (((((match_bool_type) (nat)) (j)) (((((match_bool_type) (nat)) (i)) (n)) (((eqb) (n)) (j)))) (x))) (j)))) (((eqb) (((((match_bool_type) (nat)) (j)) (((((match_bool_type) (nat)) (i)) (n)) (((eqb) (n)) (j)))) (x))) (i)))) (n))) ((((((sym_eq_match_bool_type_true) (nat)) (j)) (((((match_bool_type) (nat)) (i)) (n)) (((eqb) (n)) (j)))) (fun y : nat => (((eq) (nat)) (((((match_bool_type) (nat)) (j)) (((((match_bool_type) (nat)) (i)) (((((match_bool_type) (nat)) (j)) (((((match_bool_type) (nat)) (i)) (n)) (((eqb) (n)) (j)))) (true))) (((eqb) (((((match_bool_type) (nat)) (j)) (((((match_bool_type) (nat)) (i)) (n)) (((eqb) (n)) (j)))) (true))) (j)))) (((eqb) (y)) (i)))) (n))) ((((((sym_eq_match_bool_type_true) (nat)) (j)) (((((match_bool_type) (nat)) (i)) (n)) (((eqb) (n)) (j)))) (fun y : nat => (((eq) (nat)) (((((match_bool_type) (nat)) (j)) (((((match_bool_type) (nat)) (i)) (((((match_bool_type) (nat)) (j)) (((((match_bool_type) (nat)) (i)) (n)) (((eqb) (n)) (j)))) (true))) (((eqb) (y)) (j)))) (((eqb) (j)) (i)))) (n))) ((((((sym_eq_match_bool_type_true) (nat)) (j)) (((((match_bool_type) (nat)) (i)) (n)) (((eqb) (n)) (j)))) (fun y : nat => (((eq) (nat)) (((((match_bool_type) (nat)) (j)) (((((match_bool_type) (nat)) (i)) (y)) (((eqb) (j)) (j)))) (((eqb) (j)) (i)))) (n))) (((((((match_Or_prop) ((((eq) (bool)) (((eqb) (j)) (i))) (true))) ((((eq) (bool)) (((eqb) (j)) (i))) (false))) ((((eq) (nat)) (((((match_bool_type) (nat)) (j)) (((((match_bool_type) (nat)) (i)) (j)) (((eqb) (j)) (j)))) (((eqb) (j)) (i)))) (n))) (fun Hji : (((eq) (bool)) (((eqb) (j)) (i))) (true) => ((((((eq_ind_r) (bool)) (true)) (fun x : bool => (((eq) (nat)) (((((match_bool_type) (nat)) (j)) (((((match_bool_type) (nat)) (i)) (j)) (((eqb) (j)) (j)))) (x))) (n))) ((((((sym_eq_match_bool_type_true) (nat)) (j)) (((((match_bool_type) (nat)) (i)) (j)) (((eqb) (j)) (j)))) (fun y : nat => (((eq) (nat)) (y)) (n))) (((((((eq_ind_r) (nat)) (i)) (fun x : nat => (((eq) (nat)) (j)) (x))) ((((eqb_true_to_eq) (j)) (i)) (Hji))) (n)) ((((eqb_true_to_eq) (n)) (i)) (Hni))))) (((eqb) (j)) (i))) (Hji))) (fun Hji : (((eq) (bool)) (((eqb) (j)) (i))) (false) => ((((((eq_ind_r) (bool)) (false)) (fun x : bool => (((eq) (nat)) (((((match_bool_type) (nat)) (j)) (((((match_bool_type) (nat)) (i)) (j)) (((eqb) (j)) (j)))) (x))) (n))) ((((((sym_eq_match_bool_type_false) (nat)) (j)) (((((match_bool_type) (nat)) (i)) (j)) (((eqb) (j)) (j)))) (fun y : nat => (((eq) (nat)) (y)) (n))) (((((((eq_ind_r) (bool)) (true)) (fun x : bool => (((eq) (nat)) (((((match_bool_type) (nat)) (i)) (j)) (x))) (n))) ((((((sym_eq_match_bool_type_true) (nat)) (i)) (j)) (fun y : nat => (((eq) (nat)) (y)) (n))) (((((sym_eq) (nat)) (n)) (i)) ((((eqb_true_to_eq) (n)) (i)) (Hni))))) (((eqb) (j)) (j))) ((eqb_n_n) (j))))) (((eqb) (j)) (i))) (Hji))) ((true_or_false) (((eqb) (j)) (i)))))))) (((eqb) (n)) (i))) (Hni))) (fun Hni : (((eq) (bool)) (((eqb) (n)) (i))) (false) => ((((((eq_ind_r) (bool)) (false)) (fun x : bool => (((eq) (nat)) (((((match_bool_type) (nat)) (j)) (((((match_bool_type) (nat)) (i)) (((((match_bool_type) (nat)) (j)) (((((match_bool_type) (nat)) (i)) (n)) (((eqb) (n)) (j)))) (x))) (((eqb) (((((match_bool_type) (nat)) (j)) (((((match_bool_type) (nat)) (i)) (n)) (((eqb) (n)) (j)))) (x))) (j)))) (((eqb) (((((match_bool_type) (nat)) (j)) (((((match_bool_type) (nat)) (i)) (n)) (((eqb) (n)) (j)))) (x))) (i)))) (n))) ((((((sym_eq_match_bool_type_false) (nat)) (j)) (((((match_bool_type) (nat)) (i)) (n)) (((eqb) (n)) (j)))) (fun y : nat => (((eq) (nat)) (((((match_bool_type) (nat)) (j)) (((((match_bool_type) (nat)) (i)) (((((match_bool_type) (nat)) (j)) (((((match_bool_type) (nat)) (i)) (n)) (((eqb) (n)) (j)))) (false))) (((eqb) (((((match_bool_type) (nat)) (j)) (((((match_bool_type) (nat)) (i)) (n)) (((eqb) (n)) (j)))) (false))) (j)))) (((eqb) (y)) (i)))) (n))) ((((((sym_eq_match_bool_type_false) (nat)) (j)) (((((match_bool_type) (nat)) (i)) (n)) (((eqb) (n)) (j)))) (fun y : nat => (((eq) (nat)) (((((match_bool_type) (nat)) (j)) (((((match_bool_type) (nat)) (i)) (((((match_bool_type) (nat)) (j)) (((((match_bool_type) (nat)) (i)) (n)) (((eqb) (n)) (j)))) (false))) (((eqb) (y)) (j)))) (((eqb) (((((match_bool_type) (nat)) (i)) (n)) (((eqb) (n)) (j)))) (i)))) (n))) ((((((sym_eq_match_bool_type_false) (nat)) (j)) (((((match_bool_type) (nat)) (i)) (n)) (((eqb) (n)) (j)))) (fun y : nat => (((eq) (nat)) (((((match_bool_type) (nat)) (j)) (((((match_bool_type) (nat)) (i)) (y)) (((eqb) (((((match_bool_type) (nat)) (i)) (n)) (((eqb) (n)) (j)))) (j)))) (((eqb) (((((match_bool_type) (nat)) (i)) (n)) (((eqb) (n)) (j)))) (i)))) (n))) (((((((match_Or_prop) ((((eq) (bool)) (((eqb) (n)) (j))) (true))) ((((eq) (bool)) (((eqb) (n)) (j))) (false))) ((((eq) (nat)) (((((match_bool_type) (nat)) (j)) (((((match_bool_type) (nat)) (i)) (((((match_bool_type) (nat)) (i)) (n)) (((eqb) (n)) (j)))) (((eqb) (((((match_bool_type) (nat)) (i)) (n)) (((eqb) (n)) (j)))) (j)))) (((eqb) (((((match_bool_type) (nat)) (i)) (n)) (((eqb) (n)) (j)))) (i)))) (n))) (fun Hnj : (((eq) (bool)) (((eqb) (n)) (j))) (true) => ((((((eq_ind_r) (bool)) (true)) (fun x : bool => (((eq) (nat)) (((((match_bool_type) (nat)) (j)) (((((match_bool_type) (nat)) (i)) (((((match_bool_type) (nat)) (i)) (n)) (x))) (((eqb) (((((match_bool_type) (nat)) (i)) (n)) (x))) (j)))) (((eqb) (((((match_bool_type) (nat)) (i)) (n)) (x))) (i)))) (n))) ((((((sym_eq_match_bool_type_true) (nat)) (i)) (n)) (fun y : nat => (((eq) (nat)) (((((match_bool_type) (nat)) (j)) (((((match_bool_type) (nat)) (i)) (((((match_bool_type) (nat)) (i)) (n)) (true))) (((eqb) (((((match_bool_type) (nat)) (i)) (n)) (true))) (j)))) (((eqb) (y)) (i)))) (n))) ((((((sym_eq_match_bool_type_true) (nat)) (i)) (n)) (fun y : nat => (((eq) (nat)) (((((match_bool_type) (nat)) (j)) (((((match_bool_type) (nat)) (i)) (((((match_bool_type) (nat)) (i)) (n)) (true))) (((eqb) (y)) (j)))) (((eqb) (i)) (i)))) (n))) ((((((sym_eq_match_bool_type_true) (nat)) (i)) (n)) (fun y : nat => (((eq) (nat)) (((((match_bool_type) (nat)) (j)) (((((match_bool_type) (nat)) (i)) (y)) (((eqb) (i)) (j)))) (((eqb) (i)) (i)))) (n))) (((((((eq_ind_r) (bool)) (true)) (fun x : bool => (((eq) (nat)) (((((match_bool_type) (nat)) (j)) (((((match_bool_type) (nat)) (i)) (i)) (((eqb) (i)) (j)))) (x))) (n))) ((((((sym_eq_match_bool_type_true) (nat)) (j)) (((((match_bool_type) (nat)) (i)) (i)) (((eqb) (i)) (j)))) (fun y : nat => (((eq) (nat)) (y)) (n))) (((((sym_eq) (nat)) (n)) (j)) ((((eqb_true_to_eq) (n)) (j)) (Hnj))))) (((eqb) (i)) (i))) ((eqb_n_n) (i))))))) (((eqb) (n)) (j))) (Hnj))) (fun Hnj : (((eq) (bool)) (((eqb) (n)) (j))) (false) => ((((((eq_ind_r) (bool)) (false)) (fun x : bool => (((eq) (nat)) (((((match_bool_type) (nat)) (j)) (((((match_bool_type) (nat)) (i)) (((((match_bool_type) (nat)) (i)) (n)) (x))) (((eqb) (((((match_bool_type) (nat)) (i)) (n)) (x))) (j)))) (((eqb) (((((match_bool_type) (nat)) (i)) (n)) (x))) (i)))) (n))) ((((((sym_eq_match_bool_type_false) (nat)) (i)) (n)) (fun y : nat => (((eq) (nat)) (((((match_bool_type) (nat)) (j)) (((((match_bool_type) (nat)) (i)) (((((match_bool_type) (nat)) (i)) (n)) (false))) (((eqb) (((((match_bool_type) (nat)) (i)) (n)) (false))) (j)))) (((eqb) (y)) (i)))) (n))) ((((((sym_eq_match_bool_type_false) (nat)) (i)) (n)) (fun y : nat => (((eq) (nat)) (((((match_bool_type) (nat)) (j)) (((((match_bool_type) (nat)) (i)) (((((match_bool_type) (nat)) (i)) (n)) (false))) (((eqb) (y)) (j)))) (((eqb) (n)) (i)))) (n))) ((((((sym_eq_match_bool_type_false) (nat)) (i)) (n)) (fun y : nat => (((eq) (nat)) (((((match_bool_type) (nat)) (j)) (((((match_bool_type) (nat)) (i)) (y)) (((eqb) (n)) (j)))) (((eqb) (n)) (i)))) (n))) (((((((eq_ind_r) (bool)) (false)) (fun x : bool => (((eq) (nat)) (((((match_bool_type) (nat)) (j)) (((((match_bool_type) (nat)) (i)) (n)) (((eqb) (n)) (j)))) (x))) (n))) (((((((eq_ind_r) (bool)) (false)) (fun x : bool => (((eq) (nat)) (((((match_bool_type) (nat)) (j)) (((((match_bool_type) (nat)) (i)) (n)) (x))) (false))) (n))) ((((((eq_match_bool_type_false) (nat)) (i)) (n)) (fun y : nat => (((eq) (nat)) (((((match_bool_type) (nat)) (j)) (((((match_bool_type) (nat)) (i)) (n)) (false))) (false))) (y))) ((((((eq_match_bool_type_false) (nat)) (j)) (((((match_bool_type) (nat)) (i)) (n)) (false))) (fun y : nat => (((eq) (nat)) (((((match_bool_type) (nat)) (j)) (((((match_bool_type) (nat)) (i)) (n)) (false))) (false))) (y))) (((refl) (nat)) (((((match_bool_type) (nat)) (j)) (((((match_bool_type) (nat)) (i)) (n)) (false))) (false)))))) (((eqb) (n)) (j))) (Hnj))) (((eqb) (n)) (i))) (Hni)))))) (((eqb) (n)) (j))) (Hnj))) ((true_or_false) (((eqb) (n)) (j)))))))) (((eqb) (n)) (i))) (Hni))) ((true_or_false) (((eqb) (n)) (i))).
Definition injective_transpose : forall i : nat, forall j : nat, (((injective) (nat)) (nat)) (((transpose) (i)) (j)) := fun i : nat => fun j : nat => fun x : nat => fun y : nat => fun auto : (((eq) (nat)) ((((transpose) (i)) (j)) (x))) ((((transpose) (i)) (j)) (y)) => ((((((rewrite_r) (nat)) (y)) (fun Joker_ : nat => (((eq) (nat)) (Joker_)) (y))) (((refl) (nat)) (y))) (x)) (((((((rewrite_l) (nat)) ((((transpose) (i)) (j)) ((((transpose) (i)) (j)) (x)))) (fun Joker_ : nat => (((eq) (nat)) (Joker_)) (y))) (((((((rewrite_r) (nat)) ((((transpose) (i)) (j)) (y))) (fun Joker_ : nat => (((eq) (nat)) ((((transpose) (i)) (j)) (Joker_))) (y))) ((((transpose_transpose) (i)) (j)) (y))) ((((transpose) (i)) (j)) (x))) (auto))) (x)) ((((transpose_transpose) (i)) (j)) (x))).
Definition permut_S_to_permut_transpose : forall f : (nat) -> nat, forall m : nat, (((permut) (f)) ((S) (m))) -> ((permut) (fun n : nat => (((transpose) ((f) ((S) (m)))) ((S) (m))) ((f) (n)))) (m) := fun f : (nat) -> nat => fun m : nat => fun Jokerclearme : ((permut) (f)) ((S) (m)) => (((((match_And_prop) (forall i : nat, (((le) (i)) ((S) (m))) -> ((le) ((f) (i))) ((S) (m)))) (((injn) (f)) ((S) (m)))) (((permut) (fun n : nat => (((transpose) ((f) ((S) (m)))) ((S) (m))) ((f) (n)))) (m))) (fun permf1 : forall i : nat, (((le) (i)) ((S) (m))) -> ((le) ((f) (i))) ((S) (m)) => fun permf2 : ((injn) (f)) ((S) (m)) => fun z : Prop => fun f2 : (forall x : nat, (((le) (x)) (m)) -> ((le) ((((transpose) ((f) ((S) (m)))) ((S) (m))) ((f) (x)))) (m)) -> (((injn) (fun n : nat => (((transpose) ((f) ((S) (m)))) ((S) (m))) ((f) (n)))) (m)) -> z => ((f2) (fun i : nat => fun leim : ((le) (i)) (m) => ((((((eq_ind_r) (bool)) (false)) (fun x : bool => ((le) (((((match_bool_type) (nat)) ((S) (m))) (((((match_bool_type) (nat)) ((f) ((S) (m)))) ((f) (i))) (((eqb) ((f) (i))) ((S) (m))))) (x))) (m))) ((((((sym_eq_match_bool_type_false) (nat)) ((S) (m))) (((((match_bool_type) (nat)) ((f) ((S) (m)))) ((f) (i))) (((eqb) ((f) (i))) ((S) (m))))) (fun y : nat => ((le) (y)) (m))) (((((((match_Or_prop) (((lt) ((f) (i))) ((S) (m)))) ((((eq) (nat)) ((f) (i))) ((S) (m)))) (((le) (((((match_bool_type) (nat)) ((f) ((S) (m)))) ((f) (i))) (((eqb) ((f) (i))) ((S) (m))))) (m))) (fun Hfi : ((lt) ((f) (i))) ((S) (m)) => ((((((eq_ind_r) (bool)) (false)) (fun x : bool => ((le) (((((match_bool_type) (nat)) ((f) ((S) (m)))) ((f) (i))) (x))) (m))) ((((((sym_eq_match_bool_type_false) (nat)) ((f) ((S) (m)))) ((f) (i))) (fun y : nat => ((le) (y)) (m))) ((((le_S_S_to_le) ((f) (i))) (m)) (Hfi)))) (((eqb) ((f) (i))) ((S) (m)))) ((((not_eq_to_eqb_false) ((f) (i))) ((S) (m))) ((((lt_to_not_eq) ((f) (i))) ((S) (m))) (Hfi))))) (fun Hfi : (((eq) (nat)) ((f) (i))) ((S) (m)) => ((((((eq_ind_r) (bool)) (true)) (fun x : bool => ((le) (((((match_bool_type) (nat)) ((f) ((S) (m)))) ((f) (i))) (x))) (m))) ((((((sym_eq_match_bool_type_true) (nat)) ((f) ((S) (m)))) ((f) (i))) (fun y : nat => ((le) (y)) (m))) (((((((match_Or_prop) (((lt) ((f) ((S) (m)))) ((S) (m)))) ((((eq) (nat)) ((f) ((S) (m)))) ((S) (m)))) (((le) ((f) ((S) (m)))) (m))) (fun H : ((lt) ((f) ((S) (m)))) ((S) (m)) => (((le_S_S_to_le) ((f) ((S) (m)))) (m)) (H))) (fun H : (((eq) (nat)) ((f) ((S) (m)))) ((S) (m)) => ((falsity) (((le) ((f) ((S) (m)))) (m))) ((((absurd) ((((eq) (nat)) (i)) ((S) (m)))) ((((((permf2) (i)) ((S) (m))) ((((le_S) (i)) (m)) (leim))) ((le_n) ((S) (m)))) (((((((rewrite_l) (nat)) ((f) (i))) (fun Joker_ : nat => (((eq) (nat)) ((f) (i))) ((f) (Joker_)))) (((((((rewrite_r) (nat)) ((f) (i))) (fun Joker_ : nat => (((eq) (nat)) ((f) (i))) (Joker_))) (((refl) (nat)) ((f) (i)))) ((f) ((f) (i)))) (((((((rewrite_r) (nat)) ((S) (m))) (fun Joker_ : nat => (((eq) (nat)) ((f) ((f) (i)))) (Joker_))) (((((((rewrite_r) (nat)) ((S) (m))) (fun Joker_ : nat => (((eq) (nat)) ((f) (Joker_))) ((S) (m)))) (H)) ((f) (i))) (Hfi))) ((f) (i))) (Hfi)))) ((S) (m))) (Hfi)))) (((((not_to_not) ((((eq) (nat)) (i)) ((S) (m)))) (((le) ((S) (m))) (m))) (fun auto : (((eq) (nat)) (i)) ((S) (m)) => ((((eq_coerc) (((le) (i)) (m))) (((le) ((S) (m))) (m))) (leim)) (((((((rewrite_l) (nat)) (i)) (fun Joker_ : nat => (((eq) Prop) (((le) (i)) (m))) (((le) (Joker_)) (m)))) (((refl) Prop) (((le) (i)) (m)))) ((S) (m))) (auto)))) ((((lt_to_not_le) (m)) ((S) (m))) ((le_n) ((S) (m)))))))) ((((le_to_or_lt_eq) ((f) ((S) (m)))) ((S) (m))) (((permf1) ((S) (m))) ((le_n) ((S) (m)))))))) (((eqb) ((f) (i))) ((S) (m)))) ((((eq_to_eqb_true) ((f) (i))) ((S) (m))) (Hfi)))) ((((le_to_or_lt_eq) ((f) (i))) ((S) (m))) (((permf1) (i)) ((((le_S) (i)) (m)) (leim))))))) (((eqb) ((f) (i))) ((f) ((S) (m))))) ((((not_eq_to_eqb_false) ((f) (i))) ((f) ((S) (m)))) (fun H : (((eq) (nat)) ((f) (i))) ((f) ((S) (m))) => (((absurd) ((((eq) (nat)) (i)) ((S) (m)))) ((((((permf2) (i)) ((S) (m))) ((((le_S) (i)) (m)) (leim))) ((le_n) ((S) (m)))) (H))) ((((lt_to_not_eq) (i)) ((S) (m))) ((((le_S_S) (i)) (m)) (leim))))))) (fun a : nat => fun b : nat => fun leam : ((le) (a)) (m) => fun lebm : ((le) (b)) (m) => fun H : (((eq) (nat)) ((((transpose) ((f) ((S) (m)))) ((S) (m))) ((f) (a)))) ((((transpose) ((f) ((S) (m)))) ((S) (m))) ((f) (b))) => (((((permf2) (a)) (b)) ((((le_S) (a)) (m)) (leam))) ((((le_S) (b)) (m)) (lebm))) ((((((injective_transpose) ((f) ((S) (m)))) ((S) (m))) ((f) (a))) ((f) (b))) (H))))) (Jokerclearme).
Definition bijn : ((nat) -> nat) -> (nat) -> Prop := fun f : (nat) -> nat => fun n : nat => forall m : nat, (((le) (m)) (n)) -> ((Ex) (nat)) (fun p : nat => ((And) (((le) (p)) (n))) ((((eq) (nat)) ((f) (p))) (m))).
Definition eq_to_bijn : forall f : (nat) -> nat, forall g : (nat) -> nat, forall n : nat, (forall i : nat, (((le) (i)) (n)) -> (((eq) (nat)) ((f) (i))) ((g) (i))) -> (((bijn) (f)) (n)) -> ((bijn) (g)) (n) := fun f : (nat) -> nat => fun g : (nat) -> nat => fun n : nat => fun H : forall i : nat, (((le) (i)) (n)) -> (((eq) (nat)) ((f) (i))) ((g) (i)) => fun bijf : ((bijn) (f)) (n) => fun i : nat => fun lein : ((le) (i)) (n) => (((((match_ex_prop) (nat)) (fun p : nat => ((And) (((le) (p)) (n))) ((((eq) (nat)) ((f) (p))) (i)))) (((Ex) (nat)) (fun p : nat => ((And) (((le) (p)) (n))) ((((eq) (nat)) ((g) (p))) (i))))) (fun a : nat => fun Jokerclearme : ((And) (((le) (a)) (n))) ((((eq) (nat)) ((f) (a))) (i)) => (((((match_And_prop) (((le) (a)) (n))) ((((eq) (nat)) ((f) (a))) (i))) (((Ex) (nat)) (fun p : nat => ((And) (((le) (p)) (n))) ((((eq) (nat)) ((g) (p))) (i))))) (fun lean : ((le) (a)) (n) => fun fa : (((eq) (nat)) ((f) (a))) (i) => fun z : Prop => fun f2 : forall x : nat, (((And) (((le) (x)) (n))) ((((eq) (nat)) ((g) (x))) (i))) -> z => ((f2) (a)) (fun z0 : Prop => fun f3 : (((le) (a)) (n)) -> ((((eq) (nat)) ((g) (a))) (i)) -> z0 => ((f3) (lean)) (((((((eq_ind) (nat)) ((f) (a))) (fun x_1 : nat => (((eq) (nat)) ((g) (a))) (x_1))) (((((sym_eq) (nat)) ((f) (a))) ((g) (a))) (((H) (a)) (lean)))) (i)) (fa))))) (Jokerclearme))) (((bijf) (i)) (lein)).
Definition bijn_n_Sn : forall f : (nat) -> nat, forall n : nat, (((bijn) (f)) (n)) -> ((((eq) (nat)) ((f) ((S) (n)))) ((S) (n))) -> ((bijn) (f)) ((S) (n)) := fun f : (nat) -> nat => fun n : nat => fun bijf : ((bijn) (f)) (n) => fun fS : (((eq) (nat)) ((f) ((S) (n)))) ((S) (n)) => fun i : nat => fun lein : ((le) (i)) ((S) (n)) => ((((((match_Or_prop) (((lt) (i)) ((S) (n)))) ((((eq) (nat)) (i)) ((S) (n)))) (((Ex) (nat)) (fun p : nat => ((And) (((le) (p)) ((S) (n)))) ((((eq) (nat)) ((f) (p))) (i))))) (fun Hi : ((lt) (i)) ((S) (n)) => (((((match_ex_prop) (nat)) (fun p : nat => ((And) (((le) (p)) (n))) ((((eq) (nat)) ((f) (p))) (i)))) (((Ex) (nat)) (fun p : nat => ((And) (((le) (p)) ((S) (n)))) ((((eq) (nat)) ((f) (p))) (i))))) (fun a : nat => fun Jokerclearme : ((And) (((le) (a)) (n))) ((((eq) (nat)) ((f) (a))) (i)) => (((((match_And_prop) (((le) (a)) (n))) ((((eq) (nat)) ((f) (a))) (i))) (((Ex) (nat)) (fun p : nat => ((And) (((le) (p)) ((S) (n)))) ((((eq) (nat)) ((f) (p))) (i))))) (fun lean : ((le) (a)) (n) => fun fa : (((eq) (nat)) ((f) (a))) (i) => fun z : Prop => fun f4 : forall x : nat, (((And) (((le) (x)) ((S) (n)))) ((((eq) (nat)) ((f) (x))) (i))) -> z => ((f4) (a)) (fun z0 : Prop => fun f5 : (((le) (a)) ((S) (n))) -> ((((eq) (nat)) ((f) (a))) (i)) -> z0 => ((f5) ((((le_S) (a)) (n)) (lean))) (((((((rewrite_r) (nat)) (i)) (fun Joker_ : nat => (((eq) (nat)) (Joker_)) (i))) (((refl) (nat)) (i))) ((f) (a))) (fa))))) (Jokerclearme))) (((bijf) (i)) ((((le_S_S_to_le) (i)) (n)) (Hi))))) (fun Hi : (((eq) (nat)) (i)) ((S) (n)) => fun z : Prop => fun f6 : forall x : nat, (((And) (((le) (x)) ((S) (n)))) ((((eq) (nat)) ((f) (x))) (i))) -> z => ((f6) (i)) (fun z0 : Prop => fun f7 : (((le) (i)) ((S) (n))) -> ((((eq) (nat)) ((f) (i))) (i)) -> z0 => ((f7) (((((eq_coerc) (((le) (i)) (i))) (((le) (i)) ((S) (n)))) ((le_n) (i))) (((((((rewrite_l) (nat)) (i)) (fun Joker_ : nat => (((eq) Prop) (((le) (i)) (i))) (((le) (i)) (Joker_)))) (((refl) Prop) (((le) (i)) (i)))) ((S) (n))) (Hi)))) (((((((rewrite_r) (nat)) (i)) (fun Joker_ : nat => (((eq) (nat)) (Joker_)) (i))) (((refl) (nat)) (i))) ((f) (i))) (((((((rewrite_r) (nat)) ((S) (n))) (fun Joker_ : nat => (((eq) (nat)) ((f) (i))) (Joker_))) (((((((rewrite_r) (nat)) ((S) (n))) (fun Joker_ : nat => (((eq) (nat)) ((f) (Joker_))) ((S) (n)))) (fS)) (i)) (Hi))) (i)) (Hi)))))) ((((le_to_or_lt_eq) (i)) ((S) (n))) (lein)).
Definition bijn_fg : forall f : (nat) -> nat, forall g : (nat) -> nat, forall n : nat, (((bijn) (f)) (n)) -> (((bijn) (g)) (n)) -> ((bijn) (fun p : nat => (f) ((g) (p)))) (n) := fun f : (nat) -> nat => fun g : (nat) -> nat => fun n : nat => fun bijf : ((bijn) (f)) (n) => fun bijg : ((bijn) (g)) (n) => fun i : nat => fun lein : ((le) (i)) (n) => (((((match_ex_prop) (nat)) (fun p : nat => ((And) (((le) (p)) (n))) ((((eq) (nat)) ((f) (p))) (i)))) (((Ex) (nat)) (fun p : nat => ((And) (((le) (p)) (n))) ((((eq) (nat)) ((f) ((g) (p)))) (i))))) (fun a : nat => fun Jokerclearme : ((And) (((le) (a)) (n))) ((((eq) (nat)) ((f) (a))) (i)) => (((((match_And_prop) (((le) (a)) (n))) ((((eq) (nat)) ((f) (a))) (i))) (((Ex) (nat)) (fun p : nat => ((And) (((le) (p)) (n))) ((((eq) (nat)) ((f) ((g) (p)))) (i))))) (fun lean : ((le) (a)) (n) => fun ga : (((eq) (nat)) ((f) (a))) (i) => (((((match_ex_prop) (nat)) (fun p : nat => ((And) (((le) (p)) (n))) ((((eq) (nat)) ((g) (p))) (a)))) (((Ex) (nat)) (fun p : nat => ((And) (((le) (p)) (n))) ((((eq) (nat)) ((f) ((g) (p)))) (i))))) (fun b : nat => fun Jokerclearme0 : ((And) (((le) (b)) (n))) ((((eq) (nat)) ((g) (b))) (a)) => (((((match_And_prop) (((le) (b)) (n))) ((((eq) (nat)) ((g) (b))) (a))) (((Ex) (nat)) (fun p : nat => ((And) (((le) (p)) (n))) ((((eq) (nat)) ((f) ((g) (p)))) (i))))) (fun lebn : ((le) (b)) (n) => fun gb : (((eq) (nat)) ((g) (b))) (a) => fun z : Prop => fun f2 : forall x : nat, (((And) (((le) (x)) (n))) ((((eq) (nat)) ((f) ((g) (x)))) (i))) -> z => ((f2) (b)) (fun z0 : Prop => fun f3 : (((le) (b)) (n)) -> ((((eq) (nat)) ((f) ((g) (b)))) (i)) -> z0 => ((f3) (lebn)) (((((((rewrite_r) (nat)) (a)) (fun Joker_ : nat => (((eq) (nat)) ((f) (Joker_))) (i))) (((((((rewrite_r) (nat)) (i)) (fun Joker_ : nat => (((eq) (nat)) (Joker_)) (i))) (((refl) (nat)) (i))) ((f) (a))) (ga))) ((g) (b))) (gb))))) (Jokerclearme0))) (((bijg) (a)) (lean)))) (Jokerclearme))) (((bijf) (i)) (lein)).
Definition bijn_transpose : forall n : nat, forall i : nat, forall j : nat, (((le) (i)) (n)) -> (((le) (j)) (n)) -> ((bijn) (((transpose) (i)) (j))) (n) := fun n : nat => fun i : nat => fun j : nat => fun lein : ((le) (i)) (n) => fun lejn : ((le) (j)) (n) => fun a : nat => fun lean : ((le) (a)) (n) => ((((((match_Or_prop) ((((eq) (bool)) (((eqb) (a)) (i))) (true))) ((((eq) (bool)) (((eqb) (a)) (i))) (false))) (((Ex) (nat)) (fun p : nat => ((And) (((le) (p)) (n))) ((((eq) (nat)) ((((transpose) (i)) (j)) (p))) (a))))) (fun Hi : (((eq) (bool)) (((eqb) (a)) (i))) (true) => fun z : Prop => fun f3 : forall x : nat, (((And) (((le) (x)) (n))) ((((eq) (nat)) ((((transpose) (i)) (j)) (x))) (a))) -> z => ((f3) (j)) (fun z0 : Prop => fun f4 : (((le) (j)) (n)) -> ((((eq) (nat)) ((((transpose) (i)) (j)) (j))) (a)) -> z0 => ((f4) (lejn)) (((((((eq_ind_r) (nat)) (i)) (fun x : nat => (((eq) (nat)) (x)) (a))) (((((sym_eq) (nat)) (a)) (i)) ((((eqb_true_to_eq) (a)) (i)) (Hi)))) ((((transpose) (i)) (j)) (j))) (((transpose_i_j_j) (i)) (j)))))) (fun Hi : (((eq) (bool)) (((eqb) (a)) (i))) (false) => ((((((match_Or_prop) ((((eq) (bool)) (((eqb) (a)) (j))) (true))) ((((eq) (bool)) (((eqb) (a)) (j))) (false))) (((Ex) (nat)) (fun p : nat => ((And) (((le) (p)) (n))) ((((eq) (nat)) ((((transpose) (i)) (j)) (p))) (a))))) (fun Hj : (((eq) (bool)) (((eqb) (a)) (j))) (true) => fun z : Prop => fun f5 : forall x : nat, (((And) (((le) (x)) (n))) ((((eq) (nat)) ((((transpose) (i)) (j)) (x))) (a))) -> z => ((f5) (i)) (fun z0 : Prop => fun f : (((le) (i)) (n)) -> ((((eq) (nat)) ((((transpose) (i)) (j)) (i))) (a)) -> z0 => ((f) (lein)) (((((((eq_ind_r) (nat)) (j)) (fun x : nat => (((eq) (nat)) (x)) (a))) (((((sym_eq) (nat)) (a)) (j)) ((((eqb_true_to_eq) (a)) (j)) (Hj)))) ((((transpose) (i)) (j)) (i))) (((transpose_i_j_i) (i)) (j)))))) (fun Hj : (((eq) (bool)) (((eqb) (a)) (j))) (false) => fun z : Prop => fun f7 : forall x : nat, (((And) (((le) (x)) (n))) ((((eq) (nat)) ((((transpose) (i)) (j)) (x))) (a))) -> z => ((f7) (a)) (fun z0 : Prop => fun f : (((le) (a)) (n)) -> ((((eq) (nat)) ((((transpose) (i)) (j)) (a))) (a)) -> z0 => ((f) (lean)) (((((((eq_ind_r) (bool)) (false)) (fun x : bool => (((eq) (nat)) (((((match_bool_type) (nat)) (j)) (((((match_bool_type) (nat)) (i)) (a)) (((eqb) (a)) (j)))) (x))) (a))) (((((((eq_ind_r) (bool)) (false)) (fun x : bool => (((eq) (nat)) (((((match_bool_type) (nat)) (j)) (((((match_bool_type) (nat)) (i)) (a)) (x))) (false))) (a))) ((((((eq_match_bool_type_false) (nat)) (i)) (a)) (fun y : nat => (((eq) (nat)) (((((match_bool_type) (nat)) (j)) (((((match_bool_type) (nat)) (i)) (a)) (false))) (false))) (y))) ((((((eq_match_bool_type_false) (nat)) (j)) (((((match_bool_type) (nat)) (i)) (a)) (false))) (fun y : nat => (((eq) (nat)) (((((match_bool_type) (nat)) (j)) (((((match_bool_type) (nat)) (i)) (a)) (false))) (false))) (y))) (((refl) (nat)) (((((match_bool_type) (nat)) (j)) (((((match_bool_type) (nat)) (i)) (a)) (false))) (false)))))) (((eqb) (a)) (j))) (Hj))) (((eqb) (a)) (i))) (Hi))))) ((true_or_false) (((eqb) (a)) (j))))) ((true_or_false) (((eqb) (a)) (i))).
Definition permut_to_bijn : forall n : nat, forall f : (nat) -> nat, (((permut) (f)) (n)) -> ((bijn) (f)) (n) := fun n : nat => ((((nat_ind) (fun Jokerx_365 : nat => forall f : (nat) -> nat, (((permut) (f)) (Jokerx_365)) -> ((bijn) (f)) (Jokerx_365))) (fun f : (nat) -> nat => fun Jokerclearme : ((And) (forall i : nat, (((le) (i)) (O)) -> ((le) ((f) (i))) (O))) (forall i : nat, forall j : nat, (((le) (i)) (O)) -> (((le) (j)) (O)) -> ((((eq) (nat)) ((f) (i))) ((f) (j))) -> (((eq) (nat)) (i)) (j)) => (((((match_And_prop) (forall i : nat, (((le) (i)) (O)) -> ((le) ((f) (i))) (O))) (forall i : nat, forall j : nat, (((le) (i)) (O)) -> (((le) (j)) (O)) -> ((((eq) (nat)) ((f) (i))) ((f) (j))) -> (((eq) (nat)) (i)) (j))) (forall m : nat, (((le) (m)) (O)) -> ((Ex) (nat)) (fun p : nat => ((And) (((le) (p)) (O))) ((((eq) (nat)) ((f) (p))) (m))))) (fun H : forall i : nat, (((le) (i)) (O)) -> ((le) ((f) (i))) (O) => fun H1 : forall i : nat, forall j : nat, (((le) (i)) (O)) -> (((le) (j)) (O)) -> ((((eq) (nat)) ((f) (i))) ((f) (j))) -> (((eq) (nat)) (i)) (j) => fun m : nat => fun lem0 : ((le) (m)) (O) => fun z : Prop => fun f8 : forall x : nat, (((And) (((le) (x)) (O))) ((((eq) (nat)) ((f) (x))) (m))) -> z => ((f8) (O)) (fun z0 : Prop => fun f80 : (((le) (O)) (O)) -> ((((eq) (nat)) ((f) (O))) (m)) -> z0 => ((f80) ((le_O_n) (O))) (((((le_n_O_elim) (m)) (lem0)) (((eq) (nat)) ((f) (O)))) (((((sym_eq) (nat)) (O)) ((f) (O))) (((le_n_O_to_eq) ((f) (O))) (((H) (O)) ((le_O_n) (O))))))))) (Jokerclearme))) (fun m : nat => fun Hind : forall f : (nat) -> nat, (((permut) (f)) (m)) -> ((bijn) (f)) (m) => fun f : (nat) -> nat => fun permf : ((permut) (f)) ((S) (m)) => (((((eq_to_bijn) (fun p : nat => (((transpose) ((f) ((S) (m)))) ((S) (m))) ((((transpose) ((f) ((S) (m)))) ((S) (m))) ((f) (p))))) (f)) ((S) (m))) (fun i : nat => fun lei : ((le) (i)) ((S) (m)) => (((transpose_transpose) ((f) ((S) (m)))) ((S) (m))) ((f) (i)))) ((((((bijn_fg) (((transpose) ((f) ((S) (m)))) ((S) (m)))) (fun Joker_ : nat => (((transpose) ((f) ((S) (m)))) ((S) (m))) ((f) (Joker_)))) ((S) (m))) ((((((match_And_prop) (forall i : nat, (((le) (i)) ((S) (m))) -> ((le) ((f) (i))) ((S) (m)))) (((injn) (f)) ((S) (m)))) (((bijn) (((transpose) ((f) ((S) (m)))) ((S) (m)))) ((S) (m)))) (fun lef : forall i : nat, (((le) (i)) ((S) (m))) -> ((le) ((f) (i))) ((S) (m)) => fun Joker_ : ((injn) (f)) ((S) (m)) => (((((bijn_transpose) ((S) (m))) ((f) ((S) (m)))) ((S) (m))) (((lef) ((S) (m))) ((le_n) ((S) (m))))) ((le_n) ((S) (m))))) (permf))) (((((bijn_n_Sn) (fun Joker_ : nat => (((transpose) ((f) ((S) (m)))) ((S) (m))) ((f) (Joker_)))) (m)) (((Hind) (fun Joker_ : nat => (((transpose) ((f) ((S) (m)))) ((S) (m))) ((f) (Joker_)))) ((((permut_S_to_permut_transpose) (f)) (m)) (permf)))) (((((((eq_ind_r) (bool)) (true)) (fun x : bool => (((eq) (nat)) (((((match_bool_type) (nat)) ((S) (m))) (((((match_bool_type) (nat)) ((f) ((S) (m)))) ((f) ((S) (m)))) (((eqb) ((f) ((S) (m)))) ((S) (m))))) (x))) ((S) (m)))) ((((((eq_match_bool_type_true) (nat)) ((S) (m))) (((((match_bool_type) (nat)) ((f) ((S) (m)))) ((f) ((S) (m)))) (((eqb) ((f) ((S) (m)))) ((S) (m))))) (fun y : nat => (((eq) (nat)) (((((match_bool_type) (nat)) ((S) (m))) (((((match_bool_type) (nat)) ((f) ((S) (m)))) ((f) ((S) (m)))) (((eqb) ((f) ((S) (m)))) ((S) (m))))) (true))) (y))) (((refl) (nat)) (((((match_bool_type) (nat)) ((S) (m))) (((((match_bool_type) (nat)) ((f) ((S) (m)))) ((f) ((S) (m)))) (((eqb) ((f) ((S) (m)))) ((S) (m))))) (true))))) (((eqb) ((f) ((S) (m)))) ((f) ((S) (m))))) ((eqb_n_n) ((f) ((S) (m))))))))) (n).
Parameter invert_permut : (nat) -> ((nat) -> nat) -> (nat) -> nat.
Parameter invert_permut_body : (nat) -> ((nat) -> nat) -> (nat) -> nat.
Axiom eq_invert_permut : forall n : nat, (((leibniz) (((nat) -> nat) -> (nat) -> nat)) ((invert_permut) (n))) ((((filter_nat_type) (((nat) -> nat) -> (nat) -> nat)) (invert_permut_body)) (n)).
Definition sym_eq_invert_permut : forall n : nat, (((leibniz) (((nat) -> nat) -> (nat) -> nat)) ((((filter_nat_type) (((nat) -> nat) -> (nat) -> nat)) (invert_permut_body)) (n))) ((invert_permut) (n)) := fun n : nat => ((((sym_leibniz) (((nat) -> nat) -> (nat) -> nat)) ((invert_permut) (n))) ((((filter_nat_type) (((nat) -> nat) -> (nat) -> nat)) (invert_permut_body)) (n))) ((eq_invert_permut) (n)).
Axiom eq_invert_permut_body_O : (((leibniz) (((nat) -> nat) -> (nat) -> nat)) ((invert_permut_body) (O))) (fun f : (nat) -> nat => fun m : nat => ((((match_bool_type) (nat)) (O)) (O)) (((eqb) (m)) ((f) (O)))).
Definition sym_eq_invert_permut_body_O : (((leibniz) (((nat) -> nat) -> (nat) -> nat)) (fun f : (nat) -> nat => fun m : nat => ((((match_bool_type) (nat)) (O)) (O)) (((eqb) (m)) ((f) (O))))) ((invert_permut_body) (O)) := ((((sym_leibniz) (((nat) -> nat) -> (nat) -> nat)) ((invert_permut_body) (O))) (fun f : (nat) -> nat => fun m : nat => ((((match_bool_type) (nat)) (O)) (O)) (((eqb) (m)) ((f) (O))))) (eq_invert_permut_body_O).
Axiom eq_invert_permut_body_S : forall n : nat, (((leibniz) (((nat) -> nat) -> (nat) -> nat)) ((invert_permut_body) ((S) (n)))) (fun f : (nat) -> nat => fun m : nat => ((((match_bool_type) (nat)) ((S) (n))) ((((invert_permut) (n)) (f)) (m))) (((eqb) (m)) ((f) ((S) (n))))).
Definition sym_eq_invert_permut_body_S : forall n : nat, (((leibniz) (((nat) -> nat) -> (nat) -> nat)) (fun f : (nat) -> nat => fun m : nat => ((((match_bool_type) (nat)) ((S) (n))) ((((invert_permut) (n)) (f)) (m))) (((eqb) (m)) ((f) ((S) (n)))))) ((invert_permut_body) ((S) (n))) := fun n : nat => ((((sym_leibniz) (((nat) -> nat) -> (nat) -> nat)) ((invert_permut_body) ((S) (n)))) (fun f : (nat) -> nat => fun m : nat => ((((match_bool_type) (nat)) ((S) (n))) ((((invert_permut) (n)) (f)) (m))) (((eqb) (m)) ((f) ((S) (n)))))) ((eq_invert_permut_body_S) (n)).
Definition invert_permut_f : forall f : (nat) -> nat, forall n : nat, forall m : nat, (((le) (m)) (n)) -> (((injn) (f)) (n)) -> (((eq) (nat)) ((((invert_permut) (n)) (f)) ((f) (m)))) (m) := fun f : (nat) -> nat => fun n : nat => fun m : nat => fun lenm : ((le) (m)) (n) => ((((((le_ind) (m)) (fun x_417 : nat => (((injn) (f)) (x_417)) -> (((eq) (nat)) ((((invert_permut) (x_417)) (f)) ((f) (m)))) (m))) (((((match_nat_prop) (fun Joker_ : nat => (((injn) (f)) (Joker_)) -> (((eq) (nat)) ((((invert_permut) (Joker_)) (f)) ((f) (Joker_)))) (Joker_))) ((((sym_eq_invert_permut) (O)) (fun y : ((nat) -> nat) -> (nat) -> nat => (((injn) (f)) (O)) -> (((eq) (nat)) (((y) (f)) ((f) (O)))) (O))) (((((sym_eq_filter_nat_type_O) (((nat) -> nat) -> (nat) -> nat)) (invert_permut_body)) (fun y : ((nat) -> nat) -> (nat) -> nat => (((injn) (f)) (O)) -> (((eq) (nat)) (((y) (f)) ((f) (O)))) (O))) (((sym_eq_invert_permut_body_O) (fun y : ((nat) -> nat) -> (nat) -> nat => (((injn) (f)) (O)) -> (((eq) (nat)) (((y) (f)) ((f) (O)))) (O))) (((((((eq_ind_r) (bool)) (true)) (fun x : bool => (forall i : nat, forall j : nat, (((le) (i)) (O)) -> (((le) (j)) (O)) -> ((((eq) (nat)) ((f) (i))) ((f) (j))) -> (((eq) (nat)) (i)) (j)) -> (((eq) (nat)) (((((match_bool_type) (nat)) (O)) (O)) (x))) (O))) (fun auto : forall i : nat, forall j : nat, (((le) (i)) (O)) -> (((le) (j)) (O)) -> ((((eq) (nat)) ((f) (i))) ((f) (j))) -> (((eq) (nat)) (i)) (j) => (((((eq_match_bool_type_true) (nat)) (O)) (O)) (fun y : nat => (((eq) (nat)) (((((match_bool_type) (nat)) (O)) (O)) (true))) (y))) (((refl) (nat)) (((((match_bool_type) (nat)) (O)) (O)) (true))))) (((eqb) ((f) (O))) ((f) (O)))) ((eqb_n_n) ((f) (O)))))))) (fun a : nat => (((sym_eq_invert_permut) ((S) (a))) (fun y : ((nat) -> nat) -> (nat) -> nat => (((injn) (f)) ((S) (a))) -> (((eq) (nat)) (((y) (f)) ((f) ((S) (a))))) ((S) (a)))) ((((((sym_eq_filter_nat_type_S) (((nat) -> nat) -> (nat) -> nat)) (invert_permut_body)) (a)) (fun y : ((nat) -> nat) -> (nat) -> nat => (((injn) (f)) ((S) (a))) -> (((eq) (nat)) (((y) (f)) ((f) ((S) (a))))) ((S) (a)))) ((((sym_eq_invert_permut_body_S) (a)) (fun y : ((nat) -> nat) -> (nat) -> nat => (((injn) (f)) ((S) (a))) -> (((eq) (nat)) (((y) (f)) ((f) ((S) (a))))) ((S) (a)))) (((((((eq_ind_r) (bool)) (true)) (fun x : bool => (forall i : nat, forall j : nat, (((le) (i)) ((S) (a))) -> (((le) (j)) ((S) (a))) -> ((((eq) (nat)) ((f) (i))) ((f) (j))) -> (((eq) (nat)) (i)) (j)) -> (((eq) (nat)) (((((match_bool_type) (nat)) ((S) (a))) ((((invert_permut) (a)) (f)) ((f) ((S) (a))))) (x))) ((S) (a)))) (fun auto : forall i : nat, forall j : nat, (((le) (i)) ((S) (a))) -> (((le) (j)) ((S) (a))) -> ((((eq) (nat)) ((f) (i))) ((f) (j))) -> (((eq) (nat)) (i)) (j) => (((((eq_match_bool_type_true) (nat)) ((S) (a))) ((((invert_permut) (a)) (f)) ((f) ((S) (a))))) (fun y : nat => (((eq) (nat)) (((((match_bool_type) (nat)) ((S) (a))) ((((invert_permut) (a)) (f)) ((f) ((S) (a))))) (true))) (y))) (((refl) (nat)) (((((match_bool_type) (nat)) ((S) (a))) ((((invert_permut) (a)) (f)) ((f) ((S) (a))))) (true))))) (((eqb) ((f) ((S) (a)))) ((f) ((S) (a))))) ((eqb_n_n) ((f) ((S) (a))))))))) (m))) (fun m0 : nat => (((sym_eq_invert_permut) ((S) (m0))) (fun y : ((nat) -> nat) -> (nat) -> nat => (((le) (m)) (m0)) -> ((((injn) (f)) (m0)) -> (((eq) (nat)) ((((invert_permut) (m0)) (f)) ((f) (m)))) (m)) -> (((injn) (f)) ((S) (m0))) -> (((eq) (nat)) (((y) (f)) ((f) (m)))) (m))) ((((((sym_eq_filter_nat_type_S) (((nat) -> nat) -> (nat) -> nat)) (invert_permut_body)) (m0)) (fun y : ((nat) -> nat) -> (nat) -> nat => (((le) (m)) (m0)) -> ((((injn) (f)) (m0)) -> (((eq) (nat)) ((((invert_permut) (m0)) (f)) ((f) (m)))) (m)) -> (((injn) (f)) ((S) (m0))) -> (((eq) (nat)) (((y) (f)) ((f) (m)))) (m))) ((((sym_eq_invert_permut_body_S) (m0)) (fun y : ((nat) -> nat) -> (nat) -> nat => (((le) (m)) (m0)) -> ((((injn) (f)) (m0)) -> (((eq) (nat)) ((((invert_permut) (m0)) (f)) ((f) (m)))) (m)) -> (((injn) (f)) ((S) (m0))) -> (((eq) (nat)) (((y) (f)) ((f) (m)))) (m))) (fun lem : ((le) (m)) (m0) => fun H : (((injn) (f)) (m0)) -> (((eq) (nat)) ((((invert_permut) (m0)) (f)) ((f) (m)))) (m) => fun H1 : ((injn) (f)) ((S) (m0)) => ((((((eq_ind_r) (bool)) (false)) (fun x : bool => (((eq) (nat)) (((((match_bool_type) (nat)) ((S) (m0))) ((((invert_permut) (m0)) (f)) ((f) (m)))) (x))) (m))) ((((((sym_eq_match_bool_type_false) (nat)) ((S) (m0))) ((((invert_permut) (m0)) (f)) ((f) (m)))) (fun y : nat => (((eq) (nat)) (y)) (m))) ((H) ((((injn_Sn_n) (f)) (m0)) (H1))))) (((eqb) ((f) (m))) ((f) ((S) (m0))))) ((((not_eq_to_eqb_false) ((f) (m))) ((f) ((S) (m0)))) (fun eqf : (((eq) (nat)) ((f) (m))) ((f) ((S) (m0))) => (((absurd) ((((eq) (nat)) (m)) ((S) (m0)))) ((((((H1) (m)) ((S) (m0))) ((((le_S) (m)) (m0)) (lem))) ((le_n) ((S) (m0)))) (((((((rewrite_l) (nat)) ((f) (m))) (fun Joker_ : nat => (((eq) (nat)) ((f) (m))) (Joker_))) (((refl) (nat)) ((f) (m)))) ((f) ((S) (m0)))) (eqf)))) ((((lt_to_not_eq) (m)) ((S) (m0))) ((((le_S_S) (m)) (m0)) (lem)))))))))) (n)) (lenm).
Definition let_clause_1063 : forall f : (nat) -> nat, forall n : nat, (((permut) (f)) (n)) -> forall i : nat, forall j : nat, (((le) (i)) (n)) -> (((le) (j)) (n)) -> forall a : nat, (((And) (((le) (a)) (n))) ((((eq) (nat)) ((f) (a))) (i))) -> (((le) (a)) (n)) -> ((((eq) (nat)) ((f) (a))) (i)) -> forall b : nat, (((And) (((le) (b)) (n))) ((((eq) (nat)) ((f) (b))) (j))) -> (((le) (b)) (n)) -> ((((eq) (nat)) ((f) (b))) (j)) -> (forall i0 : nat, (((le) (i0)) (n)) -> ((le) ((f) (i0))) (n)) -> (((injn) (f)) (n)) -> ((((eq) (nat)) (a)) (b)) -> (((eq) (nat)) ((f) (a))) (j) := fun f : (nat) -> nat => fun n : nat => fun permf : ((permut) (f)) (n) => fun i : nat => fun j : nat => fun lein : ((le) (i)) (n) => fun lejn : ((le) (j)) (n) => fun a : nat => fun Jokerclearme : ((And) (((le) (a)) (n))) ((((eq) (nat)) ((f) (a))) (i)) => fun lean : ((le) (a)) (n) => fun fa : (((eq) (nat)) ((f) (a))) (i) => fun b : nat => fun Jokerclearme0 : ((And) (((le) (b)) (n))) ((((eq) (nat)) ((f) (b))) (j)) => fun lebn : ((le) (b)) (n) => fun fb : (((eq) (nat)) ((f) (b))) (j) => fun Joker_ : forall i0 : nat, (((le) (i0)) (n)) -> ((le) ((f) (i0))) (n) => fun injf : ((injn) (f)) (n) => fun auto : (((eq) (nat)) (a)) (b) => ((((((rewrite_r) (nat)) (b)) (fun Joker_1 : nat => (((eq) (nat)) ((f) (Joker_1))) (j))) (fb)) (a)) (auto).
Definition let_clause_1068 : forall f : (nat) -> nat, forall n : nat, (((permut) (f)) (n)) -> forall i : nat, forall j : nat, (((le) (i)) (n)) -> (((le) (j)) (n)) -> forall a : nat, (((And) (((le) (a)) (n))) ((((eq) (nat)) ((f) (a))) (i))) -> (((le) (a)) (n)) -> ((((eq) (nat)) ((f) (a))) (i)) -> forall b : nat, (((And) (((le) (b)) (n))) ((((eq) (nat)) ((f) (b))) (j))) -> (((le) (b)) (n)) -> ((((eq) (nat)) ((f) (b))) (j)) -> (forall i0 : nat, (((le) (i0)) (n)) -> ((le) ((f) (i0))) (n)) -> (((injn) (f)) (n)) -> ((((eq) (nat)) (a)) (b)) -> (((eq) (nat)) ((f) (a))) (i) := fun f : (nat) -> nat => fun n : nat => fun permf : ((permut) (f)) (n) => fun i : nat => fun j : nat => fun lein : ((le) (i)) (n) => fun lejn : ((le) (j)) (n) => fun a : nat => fun Jokerclearme : ((And) (((le) (a)) (n))) ((((eq) (nat)) ((f) (a))) (i)) => fun lean : ((le) (a)) (n) => fun fa : (((eq) (nat)) ((f) (a))) (i) => fun b : nat => fun Jokerclearme0 : ((And) (((le) (b)) (n))) ((((eq) (nat)) ((f) (b))) (j)) => fun lebn : ((le) (b)) (n) => fun fb : (((eq) (nat)) ((f) (b))) (j) => fun Joker_ : forall i0 : nat, (((le) (i0)) (n)) -> ((le) ((f) (i0))) (n) => fun injf : ((injn) (f)) (n) => fun auto : (((eq) (nat)) (a)) (b) => ((((((rewrite_l) (nat)) (j)) (fun Joker_1 : nat => (((eq) (nat)) ((f) (a))) (Joker_1))) (((((((((((((((((((let_clause_1063) (f)) (n)) (permf)) (i)) (j)) (lein)) (lejn)) (a)) (Jokerclearme)) (lean)) (fa)) (b)) (Jokerclearme0)) (lebn)) (fb)) (Joker_)) (injf)) (auto))) (i)) (((((((rewrite_l) (nat)) ((f) (a))) (fun Joker_1 : nat => (((eq) (nat)) (Joker_1)) (i))) (fa)) (j)) (((((((((((((((((((let_clause_1063) (f)) (n)) (permf)) (i)) (j)) (lein)) (lejn)) (a)) (Jokerclearme)) (lean)) (fa)) (b)) (Jokerclearme0)) (lebn)) (fb)) (Joker_)) (injf)) (auto))).
Definition injective_invert_permut : forall f : (nat) -> nat, forall n : nat, (((permut) (f)) (n)) -> ((injn) (((invert_permut) (n)) (f))) (n) := fun f : (nat) -> nat => fun n : nat => fun permf : ((permut) (f)) (n) => fun i : nat => fun j : nat => fun lein : ((le) (i)) (n) => fun lejn : ((le) (j)) (n) => (((((match_ex_prop) (nat)) (fun p : nat => ((And) (((le) (p)) (n))) ((((eq) (nat)) ((f) (p))) (i)))) (((((eq) (nat)) ((((invert_permut) (n)) (f)) (i))) ((((invert_permut) (n)) (f)) (j))) -> (((eq) (nat)) (i)) (j))) (fun a : nat => fun Jokerclearme : ((And) (((le) (a)) (n))) ((((eq) (nat)) ((f) (a))) (i)) => (((((match_And_prop) (((le) (a)) (n))) ((((eq) (nat)) ((f) (a))) (i))) (((((eq) (nat)) ((((invert_permut) (n)) (f)) (i))) ((((invert_permut) (n)) (f)) (j))) -> (((eq) (nat)) (i)) (j))) (fun lean : ((le) (a)) (n) => fun fa : (((eq) (nat)) ((f) (a))) (i) => (((((match_ex_prop) (nat)) (fun p : nat => ((And) (((le) (p)) (n))) ((((eq) (nat)) ((f) (p))) (j)))) (((((eq) (nat)) ((((invert_permut) (n)) (f)) (i))) ((((invert_permut) (n)) (f)) (j))) -> (((eq) (nat)) (i)) (j))) (fun b : nat => fun Jokerclearme0 : ((And) (((le) (b)) (n))) ((((eq) (nat)) ((f) (b))) (j)) => (((((match_And_prop) (((le) (b)) (n))) ((((eq) (nat)) ((f) (b))) (j))) (((((eq) (nat)) ((((invert_permut) (n)) (f)) (i))) ((((invert_permut) (n)) (f)) (j))) -> (((eq) (nat)) (i)) (j))) (fun lebn : ((le) (b)) (n) => fun fb : (((eq) (nat)) ((f) (b))) (j) => (((((match_And_prop) (forall i1 : nat, (((le) (i1)) (n)) -> ((le) ((f) (i1))) (n))) (((injn) (f)) (n))) (((((eq) (nat)) ((((invert_permut) (n)) (f)) (i))) ((((invert_permut) (n)) (f)) (j))) -> (((eq) (nat)) (i)) (j))) (fun Joker_ : forall i0 : nat, (((le) (i0)) (n)) -> ((le) ((f) (i0))) (n) => fun injf : ((injn) (f)) (n) => ((((((eq_ind) (nat)) ((f) (a))) (fun x_1 : nat => ((((eq) (nat)) ((((invert_permut) (n)) (f)) (x_1))) ((((invert_permut) (n)) (f)) (j))) -> (((eq) (nat)) (x_1)) (j))) (((((((eq_ind) (nat)) ((f) (b))) (fun x_1 : nat => ((((eq) (nat)) ((((invert_permut) (n)) (f)) ((f) (a)))) ((((invert_permut) (n)) (f)) (x_1))) -> (((eq) (nat)) ((f) (a))) (x_1))) (((((((eq_ind_r) (nat)) (a)) (fun x : nat => ((((eq) (nat)) (x)) ((((invert_permut) (n)) (f)) ((f) (b)))) -> (((eq) (nat)) ((f) (a))) ((f) (b)))) (((((((eq_ind_r) (nat)) (b)) (fun x : nat => ((((eq) (nat)) (a)) (x)) -> (((eq) (nat)) ((f) (a))) ((f) (b)))) (fun auto : (((eq) (nat)) (a)) (b) => ((((((rewrite_r) (nat)) (i)) (fun Joker_1 : nat => (((eq) (nat)) (Joker_1)) ((f) (b)))) (((((((rewrite_l) (nat)) (a)) (fun Joker_1 : nat => (((eq) (nat)) (i)) ((f) (Joker_1)))) (((((((rewrite_r) (nat)) (i)) (fun Joker_1 : nat => (((eq) (nat)) (i)) (Joker_1))) (((refl) (nat)) (i))) ((f) (a))) (((((((((((((((((((let_clause_1068) (f)) (n)) (permf)) (i)) (j)) (lein)) (lejn)) (a)) (Jokerclearme)) (lean)) (fa)) (b)) (Jokerclearme0)) (lebn)) (fb)) (Joker_)) (injf)) (auto)))) (b)) (auto))) ((f) (a))) (((((((((((((((((((let_clause_1068) (f)) (n)) (permf)) (i)) (j)) (lein)) (lejn)) (a)) (Jokerclearme)) (lean)) (fa)) (b)) (Jokerclearme0)) (lebn)) (fb)) (Joker_)) (injf)) (auto)))) ((((invert_permut) (n)) (f)) ((f) (b)))) ((((((invert_permut_f) (f)) (n)) (b)) (lebn)) (injf)))) ((((invert_permut) (n)) (f)) ((f) (a)))) ((((((invert_permut_f) (f)) (n)) (a)) (lean)) (injf)))) (j)) (fb))) (i)) (fa))) (permf))) (Jokerclearme0))) ((((((permut_to_bijn) (n)) (f)) (permf)) (j)) (lejn)))) (Jokerclearme))) ((((((permut_to_bijn) (n)) (f)) (permf)) (i)) (lein)).
Definition permut_invert_permut : forall f : (nat) -> nat, forall n : nat, (((permut) (f)) (n)) -> ((permut) (((invert_permut) (n)) (f))) (n) := fun f : (nat) -> nat => fun n : nat => fun permf : ((permut) (f)) (n) => fun z : Prop => fun f9 : (forall x : nat, (((le) (x)) (n)) -> ((le) ((((invert_permut) (n)) (f)) (x))) (n)) -> (((injn) (((invert_permut) (n)) (f))) (n)) -> z => ((f9) (fun i : nat => fun lein : ((le) (i)) (n) => ((((nat_ind) (fun Jokerx_365 : nat => ((le) ((((invert_permut) (Jokerx_365)) (f)) (i))) (Jokerx_365))) ((((sym_eq_invert_permut) (O)) (fun y : ((nat) -> nat) -> (nat) -> nat => ((le) (((y) (f)) (i))) (O))) (((((sym_eq_filter_nat_type_O) (((nat) -> nat) -> (nat) -> nat)) (invert_permut_body)) (fun y : ((nat) -> nat) -> (nat) -> nat => ((le) (((y) (f)) (i))) (O))) (((sym_eq_invert_permut_body_O) (fun y : ((nat) -> nat) -> (nat) -> nat => ((le) (((y) (f)) (i))) (O))) (((((match_bool_prop) (fun Joker_ : bool => ((le) (((((match_bool_type) (nat)) (O)) (O)) (Joker_))) (O))) ((((((eq_match_bool_type_true) (nat)) (O)) (O)) (fun y : nat => ((le) (((((match_bool_type) (nat)) (O)) (O)) (true))) (y))) ((le_n) (((((match_bool_type) (nat)) (O)) (O)) (true))))) ((((((eq_match_bool_type_false) (nat)) (O)) (O)) (fun y : nat => ((le) (((((match_bool_type) (nat)) (O)) (O)) (false))) (y))) ((le_n) (((((match_bool_type) (nat)) (O)) (O)) (false))))) (((eqb) (i)) ((f) (O)))))))) (fun n1 : nat => (((sym_eq_invert_permut) ((S) (n1))) (fun y : ((nat) -> nat) -> (nat) -> nat => (((le) ((((invert_permut) (n1)) (f)) (i))) (n1)) -> ((le) (((y) (f)) (i))) ((S) (n1)))) ((((((sym_eq_filter_nat_type_S) (((nat) -> nat) -> (nat) -> nat)) (invert_permut_body)) (n1)) (fun y : ((nat) -> nat) -> (nat) -> nat => (((le) ((((invert_permut) (n1)) (f)) (i))) (n1)) -> ((le) (((y) (f)) (i))) ((S) (n1)))) ((((sym_eq_invert_permut_body_S) (n1)) (fun y : ((nat) -> nat) -> (nat) -> nat => (((le) ((((invert_permut) (n1)) (f)) (i))) (n1)) -> ((le) (((y) (f)) (i))) ((S) (n1)))) (fun Hind : ((le) ((((invert_permut) (n1)) (f)) (i))) (n1) => ((((match_bool_prop) (fun Joker_ : bool => ((le) (((((match_bool_type) (nat)) ((S) (n1))) ((((invert_permut) (n1)) (f)) (i))) (Joker_))) ((S) (n1)))) ((((((eq_match_bool_type_true) (nat)) ((S) (n1))) ((((invert_permut) (n1)) (f)) (i))) (fun y : nat => ((le) (((((match_bool_type) (nat)) ((S) (n1))) ((((invert_permut) (n1)) (f)) (i))) (true))) (y))) ((le_n) (((((match_bool_type) (nat)) ((S) (n1))) ((((invert_permut) (n1)) (f)) (i))) (true))))) ((((((sym_eq_match_bool_type_false) (nat)) ((S) (n1))) ((((invert_permut) (n1)) (f)) (i))) (fun y : nat => ((le) (y)) ((S) (n1)))) ((((le_S) ((((invert_permut) (n1)) (f)) (i))) (n1)) (Hind)))) (((eqb) (i)) ((f) ((S) (n1))))))))) (n))) ((((injective_invert_permut) (f)) (n)) (permf)).
Definition f_invert_permut : forall f : (nat) -> nat, forall n : nat, forall m : nat, (((le) (m)) (n)) -> (((permut) (f)) (n)) -> (((eq) (nat)) ((f) ((((invert_permut) (n)) (f)) (m)))) (m) := fun f : (nat) -> nat => fun n : nat => fun m : nat => fun lemn : ((le) (m)) (n) => fun permf : ((permut) (f)) (n) => (((((match_And_prop) (forall i : nat, (((le) (i)) (n)) -> ((le) ((((invert_permut) (n)) (f)) (i))) (n))) (((injn) (((invert_permut) (n)) (f))) (n))) ((((eq) (nat)) ((f) ((((invert_permut) (n)) (f)) (m)))) (m))) (fun Hle : forall i : nat, (((le) (i)) (n)) -> ((le) ((((invert_permut) (n)) (f)) (i))) (n) => fun Hinj : ((injn) (((invert_permut) (n)) (f))) (n) => (((((match_And_prop) (forall i : nat, (((le) (i)) (n)) -> ((le) ((f) (i))) (n))) (((injn) (f)) (n))) ((((eq) (nat)) ((f) ((((invert_permut) (n)) (f)) (m)))) (m))) (fun lef : forall i : nat, (((le) (i)) (n)) -> ((le) ((f) (i))) (n) => fun injf : ((injn) (f)) (n) => ((((((((injective_invert_permut) (f)) (n)) (permf)) ((f) ((((invert_permut) (n)) (f)) (m)))) (m)) (((lef) ((((invert_permut) (n)) (f)) (m))) (((Hle) (m)) (lemn)))) (lemn)) ((((((invert_permut_f) (f)) (n)) ((((invert_permut) (n)) (f)) (m))) (((Hle) (m)) (lemn))) (injf)))) (permf))) ((((permut_invert_permut) (f)) (n)) (permf)).
Parameter gcd_aux : (nat) -> (nat) -> (nat) -> nat.
Parameter gcd_aux_body : (nat) -> (nat) -> (nat) -> nat.
Axiom eq_gcd_aux : forall p : nat, (((leibniz) ((nat) -> (nat) -> nat)) ((gcd_aux) (p))) ((((filter_nat_type) ((nat) -> (nat) -> nat)) (gcd_aux_body)) (p)).
Definition sym_eq_gcd_aux : forall p : nat, (((leibniz) ((nat) -> (nat) -> nat)) ((((filter_nat_type) ((nat) -> (nat) -> nat)) (gcd_aux_body)) (p))) ((gcd_aux) (p)) := fun p : nat => ((((sym_leibniz) ((nat) -> (nat) -> nat)) ((gcd_aux) (p))) ((((filter_nat_type) ((nat) -> (nat) -> nat)) (gcd_aux_body)) (p))) ((eq_gcd_aux) (p)).
Axiom eq_gcd_aux_body_O : (((leibniz) ((nat) -> (nat) -> nat)) ((gcd_aux_body) (O))) (fun m : nat => fun n : nat => m).
Definition sym_eq_gcd_aux_body_O : (((leibniz) ((nat) -> (nat) -> nat)) (fun m : nat => fun n : nat => m)) ((gcd_aux_body) (O)) := ((((sym_leibniz) ((nat) -> (nat) -> nat)) ((gcd_aux_body) (O))) (fun m : nat => fun n : nat => m)) (eq_gcd_aux_body_O).
Axiom eq_gcd_aux_body_S : forall p : nat, (((leibniz) ((nat) -> (nat) -> nat)) ((gcd_aux_body) ((S) (p)))) (fun m : nat => fun n : nat => ((((match_bool_type) (nat)) (n)) ((((gcd_aux) (p)) (n)) (((mod) (m)) (n)))) (((dividesb) (n)) (m))).
Definition sym_eq_gcd_aux_body_S : forall p : nat, (((leibniz) ((nat) -> (nat) -> nat)) (fun m : nat => fun n : nat => ((((match_bool_type) (nat)) (n)) ((((gcd_aux) (p)) (n)) (((mod) (m)) (n)))) (((dividesb) (n)) (m)))) ((gcd_aux_body) ((S) (p))) := fun p : nat => ((((sym_leibniz) ((nat) -> (nat) -> nat)) ((gcd_aux_body) ((S) (p)))) (fun m : nat => fun n : nat => ((((match_bool_type) (nat)) (n)) ((((gcd_aux) (p)) (n)) (((mod) (m)) (n)))) (((dividesb) (n)) (m)))) ((eq_gcd_aux_body_S) (p)).
Definition gcd : (nat) -> (nat) -> nat := fun n : nat => fun m : nat => ((((match_bool_type) (nat)) ((((gcd_aux) (n)) (m)) (n))) ((((gcd_aux) (m)) (n)) (m))) (((leb) (n)) (m)).
Definition commutative_gcd : forall n : nat, forall m : nat, (((eq) (nat)) (((gcd) (n)) (m))) (((gcd) (m)) (n)) := fun n : nat => fun m : nat => (((((leb_elim) (n)) (m)) (fun Joker_ : bool => (((eq) (nat)) (((((match_bool_type) (nat)) ((((gcd_aux) (n)) (m)) (n))) ((((gcd_aux) (m)) (n)) (m))) (Joker_))) (((((match_bool_type) (nat)) ((((gcd_aux) (m)) (n)) (m))) ((((gcd_aux) (n)) (m)) (n))) (((leb) (m)) (n))))) (fun lenm : ((le) (n)) (m) => ((((((match_Or_prop) (((lt) (n)) (m))) ((((eq) (nat)) (n)) (m))) ((((eq) (nat)) (((((match_bool_type) (nat)) ((((gcd_aux) (n)) (m)) (n))) ((((gcd_aux) (m)) (n)) (m))) (true))) (((((match_bool_type) (nat)) ((((gcd_aux) (m)) (n)) (m))) ((((gcd_aux) (n)) (m)) (n))) (((leb) (m)) (n))))) (fun ltnm : ((lt) (n)) (m) => ((((((eq_ind_r) (bool)) (false)) (fun x : bool => (((eq) (nat)) (((((match_bool_type) (nat)) ((((gcd_aux) (n)) (m)) (n))) ((((gcd_aux) (m)) (n)) (m))) (true))) (((((match_bool_type) (nat)) ((((gcd_aux) (m)) (n)) (m))) ((((gcd_aux) (n)) (m)) (n))) (x)))) ((((((sym_eq_match_bool_type_false) (nat)) ((((gcd_aux) (m)) (n)) (m))) ((((gcd_aux) (n)) (m)) (n))) (fun y : nat => (((eq) (nat)) (((((match_bool_type) (nat)) ((((gcd_aux) (n)) (m)) (n))) ((((gcd_aux) (m)) (n)) (m))) (true))) (y))) ((((((eq_match_bool_type_true) (nat)) ((((gcd_aux) (n)) (m)) (n))) ((((gcd_aux) (m)) (n)) (m))) (fun y : nat => (((eq) (nat)) (((((match_bool_type) (nat)) ((((gcd_aux) (n)) (m)) (n))) ((((gcd_aux) (m)) (n)) (m))) (true))) (y))) (((refl) (nat)) (((((match_bool_type) (nat)) ((((gcd_aux) (n)) (m)) (n))) ((((gcd_aux) (m)) (n)) (m))) (true)))))) (((leb) (m)) (n))) ((((not_le_to_leb_false) (m)) (n)) ((((lt_to_not_le) (n)) (m)) (ltnm))))) (fun eqnm : (((eq) (nat)) (n)) (m) => ((((((eq_ind_r) (nat)) (m)) (fun x : nat => (((eq) (nat)) (((((match_bool_type) (nat)) ((((gcd_aux) (x)) (m)) (x))) ((((gcd_aux) (m)) (x)) (m))) (true))) (((((match_bool_type) (nat)) ((((gcd_aux) (m)) (x)) (m))) ((((gcd_aux) (x)) (m)) (x))) (((leb) (m)) (x))))) (((((match_bool_prop) (fun Joker_ : bool => (((eq) (nat)) (((((match_bool_type) (nat)) ((((gcd_aux) (m)) (m)) (m))) ((((gcd_aux) (m)) (m)) (m))) (true))) (((((match_bool_type) (nat)) ((((gcd_aux) (m)) (m)) (m))) ((((gcd_aux) (m)) (m)) (m))) (Joker_)))) (((refl) (nat)) (((((match_bool_type) (nat)) ((((gcd_aux) (m)) (m)) (m))) ((((gcd_aux) (m)) (m)) (m))) (true)))) ((((((sym_eq_match_bool_type_false) (nat)) ((((gcd_aux) (m)) (m)) (m))) ((((gcd_aux) (m)) (m)) (m))) (fun y : nat => (((eq) (nat)) (((((match_bool_type) (nat)) ((((gcd_aux) (m)) (m)) (m))) ((((gcd_aux) (m)) (m)) (m))) (true))) (y))) ((((((eq_match_bool_type_true) (nat)) ((((gcd_aux) (m)) (m)) (m))) ((((gcd_aux) (m)) (m)) (m))) (fun y : nat => (((eq) (nat)) (((((match_bool_type) (nat)) ((((gcd_aux) (m)) (m)) (m))) ((((gcd_aux) (m)) (m)) (m))) (true))) (y))) (((refl) (nat)) (((((match_bool_type) (nat)) ((((gcd_aux) (m)) (m)) (m))) ((((gcd_aux) (m)) (m)) (m))) (true)))))) (((leb) (m)) (m)))) (n)) (eqnm))) ((((le_to_or_lt_eq) (n)) (m)) (lenm)))) (fun notlenm : (Not) (((le) (n)) (m)) => ((((((eq_ind_r) (bool)) (true)) (fun x : bool => (((eq) (nat)) (((((match_bool_type) (nat)) ((((gcd_aux) (n)) (m)) (n))) ((((gcd_aux) (m)) (n)) (m))) (false))) (((((match_bool_type) (nat)) ((((gcd_aux) (m)) (n)) (m))) ((((gcd_aux) (n)) (m)) (n))) (x)))) ((((((sym_eq_match_bool_type_false) (nat)) ((((gcd_aux) (n)) (m)) (n))) ((((gcd_aux) (m)) (n)) (m))) (fun y : nat => (((eq) (nat)) (y)) (((((match_bool_type) (nat)) ((((gcd_aux) (m)) (n)) (m))) ((((gcd_aux) (n)) (m)) (n))) (true)))) ((((((sym_eq_match_bool_type_true) (nat)) ((((gcd_aux) (m)) (n)) (m))) ((((gcd_aux) (n)) (m)) (n))) (fun y : nat => (((eq) (nat)) ((((gcd_aux) (m)) (n)) (m))) (y))) ((((((eq_match_bool_type_false) (nat)) ((((gcd_aux) (n)) (m)) (n))) ((((gcd_aux) (m)) (n)) (m))) (fun y : nat => (((eq) (nat)) ((((gcd_aux) (m)) (n)) (m))) (y))) ((((((eq_match_bool_type_false) (nat)) ((((gcd_aux) (n)) (m)) (n))) ((((gcd_aux) (m)) (n)) (m))) (fun y : nat => (((eq) (nat)) (y)) (((((match_bool_type) (nat)) ((((gcd_aux) (n)) (m)) (n))) ((((gcd_aux) (m)) (n)) (m))) (false)))) (((refl) (nat)) (((((match_bool_type) (nat)) ((((gcd_aux) (n)) (m)) (n))) ((((gcd_aux) (m)) (n)) (m))) (false)))))))) (((leb) (m)) (n))) ((((le_to_leb_true) (m)) (n)) ((((((transitive_le) (m)) ((S) (m))) (n)) ((le_n_Sn) (m))) ((((not_le_to_lt) (n)) (m)) (notlenm))))).
Definition gcd_O_l : forall m : nat, (((eq) (nat)) (((gcd) (O)) (m))) (m) := fun m : nat => (((((eq_match_bool_type_true) (nat)) (m)) ((((gcd_aux) (m)) (O)) (m))) (fun y : nat => (((eq) (nat)) (((gcd) (O)) (m))) (y))) (((eq_leb_body_O) (fun y : (nat) -> bool => (((eq) (nat)) (((gcd) (O)) (m))) (((((match_bool_type) (nat)) (m)) ((((gcd_aux) (m)) (O)) (m))) ((y) (m))))) (((((eq_filter_nat_type_O) ((nat) -> bool)) (leb_body)) (fun y : (nat) -> bool => (((eq) (nat)) (((gcd) (O)) (m))) (((((match_bool_type) (nat)) (m)) ((((gcd_aux) (m)) (O)) (m))) ((y) (m))))) ((((eq_leb) (O)) (fun y : (nat) -> bool => (((eq) (nat)) (((gcd) (O)) (m))) (((((match_bool_type) (nat)) (m)) ((((gcd_aux) (m)) (O)) (m))) ((y) (m))))) (((eq_gcd_aux_body_O) (fun y : (nat) -> (nat) -> nat => (((eq) (nat)) (((gcd) (O)) (m))) (((((match_bool_type) (nat)) (((y) (m)) (O))) ((((gcd_aux) (m)) (O)) (m))) (((leb) (O)) (m))))) (((((eq_filter_nat_type_O) ((nat) -> (nat) -> nat)) (gcd_aux_body)) (fun y : (nat) -> (nat) -> nat => (((eq) (nat)) (((gcd) (O)) (m))) (((((match_bool_type) (nat)) (((y) (m)) (O))) ((((gcd_aux) (m)) (O)) (m))) (((leb) (O)) (m))))) ((((eq_gcd_aux) (O)) (fun y : (nat) -> (nat) -> nat => (((eq) (nat)) (((gcd) (O)) (m))) (((((match_bool_type) (nat)) (((y) (m)) (O))) ((((gcd_aux) (m)) (O)) (m))) (((leb) (O)) (m))))) (((refl) (nat)) (((gcd) (O)) (m))))))))).
Definition divides_mod_to_divides : forall p : nat, forall m : nat, forall n : nat, (((lt) (O)) (n)) -> (((divides) (p)) (((mod) (m)) (n))) -> (((divides) (p)) (n)) -> ((divides) (p)) (m) := fun p : nat => fun m : nat => fun n : nat => fun posn : ((lt) (O)) (n) => fun Jokerclearme : ((divides) (p)) (((mod) (m)) (n)) => (((((match_divides_prop) (p)) (((mod) (m)) (n))) ((((divides) (p)) (n)) -> ((divides) (p)) (m))) (fun q1 : nat => fun eq1 : (((eq) (nat)) (((mod) (m)) (n))) (((times) (p)) (q1)) => fun Jokerclearme0 : ((divides) (p)) (n) => (((((match_divides_prop) (p)) (n)) (((divides) (p)) (m))) (fun q2 : nat => fun eq2 : (((eq) (nat)) (n)) (((times) (p)) (q2)) => ((((quotient) (p)) (m)) (((plus) (((times) (q2)) (((div) (m)) (n)))) (q1))) (((((((eq_ind_r) (nat)) (((plus) (((times) (p)) (((times) (q2)) (((div) (m)) (n))))) (((times) (p)) (q1)))) (fun x : nat => (((eq) (nat)) (m)) (x))) (((((((eq_ind) (nat)) (((mod) (m)) (n))) (fun x_1 : nat => (((eq) (nat)) (m)) (((plus) (((times) (p)) (((times) (q2)) (((div) (m)) (n))))) (x_1)))) (((((((eq_ind) (nat)) (((times) (((times) (p)) (q2))) (((div) (m)) (n)))) (fun x_1 : nat => (((eq) (nat)) (m)) (((plus) (x_1)) (((mod) (m)) (n))))) (((((((eq_ind) (nat)) (n)) (fun x_1 : nat => (((eq) (nat)) (m)) (((plus) (((times) (x_1)) (((div) (m)) (n)))) (((mod) (m)) (n))))) (((((((rewrite_r) (nat)) (((plus) (((mod) (m)) (n))) (((times) (n)) (((div) (m)) (n))))) (fun Joker_ : nat => (((eq) (nat)) (m)) (Joker_))) (((((((rewrite_l) (nat)) (m)) (fun Joker_ : nat => (((eq) (nat)) (m)) (Joker_))) (((refl) (nat)) (m))) (((plus) (((mod) (m)) (n))) (((times) (n)) (((div) (m)) (n))))) (((((((rewrite_l) (nat)) (((plus) (((times) (n)) (((div) (m)) (n)))) (((mod) (m)) (n)))) (fun Joker_ : nat => (((eq) (nat)) (m)) (Joker_))) (((((((rewrite_l) (nat)) (((times) (((div) (m)) (n))) (n))) (fun Joker_ : nat => (((eq) (nat)) (m)) (((plus) (Joker_)) (((mod) (m)) (n))))) (((div_mod) (m)) (n))) (((times) (n)) (((div) (m)) (n)))) (((commutative_times) (((div) (m)) (n))) (n)))) (((plus) (((mod) (m)) (n))) (((times) (n)) (((div) (m)) (n))))) (((commutative_plus) (((times) (n)) (((div) (m)) (n)))) (((mod) (m)) (n)))))) (((plus) (((times) (n)) (((div) (m)) (n)))) (((mod) (m)) (n)))) (((commutative_plus) (((times) (n)) (((div) (m)) (n)))) (((mod) (m)) (n))))) (((times) (p)) (q2))) (eq2))) (((times) (p)) (((times) (q2)) (((div) (m)) (n))))) ((((associative_times) (p)) (q2)) (((div) (m)) (n))))) (((times) (p)) (q1))) (eq1))) (((times) (p)) (((plus) (((times) (q2)) (((div) (m)) (n)))) (q1)))) ((((distributive_times_plus) (p)) (((times) (q2)) (((div) (m)) (n)))) (q1))))) (Jokerclearme0))) (Jokerclearme).
Definition divides_to_gcd_aux : forall p : nat, forall m : nat, forall n : nat, (((lt) (O)) (p)) -> (((lt) (O)) (n)) -> (((divides) (n)) (m)) -> (((eq) (nat)) ((((gcd_aux) (p)) (m)) (n))) (n) := fun p : nat => fun m : nat => fun n : nat => fun posp : ((lt) (O)) (p) => ((((lt_O_n_elim) (p)) (posp)) (fun Joker_ : nat => (((lt) (O)) (n)) -> (((divides) (n)) (m)) -> (((eq) (nat)) ((((gcd_aux) (Joker_)) (m)) (n))) (n))) (fun l : nat => (((sym_eq_gcd_aux) ((S) (l))) (fun y : (nat) -> (nat) -> nat => (((lt) (O)) (n)) -> (((divides) (n)) (m)) -> (((eq) (nat)) (((y) (m)) (n))) (n))) ((((((sym_eq_filter_nat_type_S) ((nat) -> (nat) -> nat)) (gcd_aux_body)) (l)) (fun y : (nat) -> (nat) -> nat => (((lt) (O)) (n)) -> (((divides) (n)) (m)) -> (((eq) (nat)) (((y) (m)) (n))) (n))) ((((sym_eq_gcd_aux_body_S) (l)) (fun y : (nat) -> (nat) -> nat => (((lt) (O)) (n)) -> (((divides) (n)) (m)) -> (((eq) (nat)) (((y) (m)) (n))) (n))) (fun posn : ((lt) (O)) (n) => fun divnm : ((divides) (n)) (m) => ((((((eq_ind_r) (bool)) (true)) (fun x : bool => (((eq) (nat)) (((((match_bool_type) (nat)) (n)) ((((gcd_aux) (l)) (n)) (((mod) (m)) (n)))) (x))) (n))) ((((((sym_eq_match_bool_type_true) (nat)) (n)) ((((gcd_aux) (l)) (n)) (((((match_nat_type) (nat)) (m)) (fun p0 : nat => (((mod_aux) (m)) (m)) (p0))) (n)))) (fun y : nat => (((eq) (nat)) (y)) (n))) (((refl) (nat)) (n)))) (((dividesb) (n)) (m))) (((((divides_to_dividesb_true) (n)) (m)) (posn)) (divnm)))))).
Definition not_divides_to_gcd_aux : forall p : nat, forall m : nat, forall n : nat, (((lt) (O)) (n)) -> ((Not) (((divides) (n)) (m))) -> (((eq) (nat)) ((((gcd_aux) ((S) (p))) (m)) (n))) ((((gcd_aux) (p)) (n)) (((mod) (m)) (n))) := fun p : nat => fun m : nat => fun n : nat => (((sym_eq_gcd_aux) ((S) (p))) (fun y : (nat) -> (nat) -> nat => (((lt) (O)) (n)) -> ((Not) (((divides) (n)) (m))) -> (((eq) (nat)) (((y) (m)) (n))) ((((gcd_aux) (p)) (n)) (((mod) (m)) (n))))) ((((((sym_eq_filter_nat_type_S) ((nat) -> (nat) -> nat)) (gcd_aux_body)) (p)) (fun y : (nat) -> (nat) -> nat => (((lt) (O)) (n)) -> ((Not) (((divides) (n)) (m))) -> (((eq) (nat)) (((y) (m)) (n))) ((((gcd_aux) (p)) (n)) (((mod) (m)) (n))))) ((((sym_eq_gcd_aux_body_S) (p)) (fun y : (nat) -> (nat) -> nat => (((lt) (O)) (n)) -> ((Not) (((divides) (n)) (m))) -> (((eq) (nat)) (((y) (m)) (n))) ((((gcd_aux) (p)) (n)) (((mod) (m)) (n))))) (fun lenm : ((lt) (O)) (n) => fun divnm : (Not) (((divides) (n)) (m)) => ((((((eq_ind_r) (bool)) (false)) (fun x : bool => (((eq) (nat)) (((((match_bool_type) (nat)) (n)) ((((gcd_aux) (p)) (n)) (((mod) (m)) (n)))) (x))) ((((gcd_aux) (p)) (n)) (((mod) (m)) (n))))) ((((((sym_eq_match_bool_type_false) (nat)) (n)) ((((gcd_aux) (p)) (n)) (((((match_nat_type) (nat)) (m)) (fun p0 : nat => (((mod_aux) (m)) (m)) (p0))) (n)))) (fun y : nat => (((eq) (nat)) (y)) ((((gcd_aux) (p)) (n)) (((((match_nat_type) (nat)) (m)) (fun p0 : nat => (((mod_aux) (m)) (m)) (p0))) (n))))) (((refl) (nat)) ((((gcd_aux) (p)) (n)) (((((match_nat_type) (nat)) (m)) (fun p0 : nat => (((mod_aux) (m)) (m)) (p0))) (n)))))) (((dividesb) (n)) (m))) (((((not_divides_to_dividesb_false) (n)) (m)) (lenm)) (divnm))))).
Definition divides_gcd_aux_mn : forall p : nat, forall m : nat, forall n : nat, (((lt) (O)) (n)) -> (((le) (n)) (m)) -> (((le) (n)) (p)) -> ((And) (((divides) ((((gcd_aux) (p)) (m)) (n))) (m))) (((divides) ((((gcd_aux) (p)) (m)) (n))) (n)) := fun p : nat => ((((nat_ind) (fun Jokerx_365 : nat => forall m : nat, forall n : nat, (((lt) (O)) (n)) -> (((le) (n)) (m)) -> (((le) (n)) (Jokerx_365)) -> ((And) (((divides) ((((gcd_aux) (Jokerx_365)) (m)) (n))) (m))) (((divides) ((((gcd_aux) (Jokerx_365)) (m)) (n))) (n)))) (fun m : nat => fun n : nat => fun posn : ((lt) (O)) (n) => fun lenm : ((le) (n)) (m) => fun lenO : ((le) (n)) (O) => ((falsity) (((And) (((divides) ((((gcd_aux) (O)) (m)) (n))) (m))) (((divides) ((((gcd_aux) (O)) (m)) (n))) (n)))) ((((absurd) (((lt) (O)) (n))) (posn)) ((((le_to_not_lt) (n)) (O)) (lenO))))) (fun q : nat => fun Hind : forall m : nat, forall n : nat, (((lt) (O)) (n)) -> (((le) (n)) (m)) -> (((le) (n)) (q)) -> ((And) (((divides) ((((gcd_aux) (q)) (m)) (n))) (m))) (((divides) ((((gcd_aux) (q)) (m)) (n))) (n)) => fun m : nat => fun n : nat => fun posn : ((lt) (O)) (n) => fun lenm : ((le) (n)) (m) => fun lenS : ((le) (n)) ((S) (q)) => ((((((match_Or_prop) (((divides) (n)) (m))) ((Not) (((divides) (n)) (m)))) (((And) (((divides) ((((gcd_aux) ((S) (q))) (m)) (n))) (m))) (((divides) ((((gcd_aux) ((S) (q))) (m)) (n))) (n)))) (fun divnm : ((divides) (n)) (m) => ((((((eq_ind_r) (nat)) (n)) (fun x : nat => ((And) (((divides) (x)) (m))) (((divides) (x)) (n)))) (fun z : Prop => fun f : (((divides) (n)) (m)) -> (((divides) (n)) (n)) -> z => ((f) (divnm)) ((divides_n_n) (n)))) ((((gcd_aux) ((S) (q))) (m)) (n))) (((((((divides_to_gcd_aux) ((S) (q))) (m)) (n)) ((lt_O_S) (q))) (posn)) (divnm)))) (fun ndivnm : (Not) (((divides) (n)) (m)) => ((((((eq_ind_r) (nat)) ((((gcd_aux) (q)) (n)) (((mod) (m)) (n)))) (fun x : nat => ((And) (((divides) (x)) (m))) (((divides) (x)) (n)))) ((((((match_And_prop) (((divides) ((((gcd_aux) (q)) (n)) (((mod) (m)) (n)))) (n))) (((divides) ((((gcd_aux) (q)) (n)) (((mod) (m)) (n)))) (((mod) (m)) (n)))) (((And) (((divides) ((((gcd_aux) (q)) (n)) (((mod) (m)) (n)))) (m))) (((divides) ((((gcd_aux) (q)) (n)) (((mod) (m)) (n)))) (n)))) (fun H : ((divides) ((((gcd_aux) (q)) (n)) (((mod) (m)) (n)))) (n) => fun H1 : ((divides) ((((gcd_aux) (q)) (n)) (((mod) (m)) (n)))) (((mod) (m)) (n)) => fun z : Prop => fun f : (((divides) ((((gcd_aux) (q)) (n)) (((mod) (m)) (n)))) (m)) -> (((divides) ((((gcd_aux) (q)) (n)) (((mod) (m)) (n)))) (n)) -> z => ((f) (((((((divides_mod_to_divides) ((((gcd_aux) (q)) (n)) (((mod) (m)) (n)))) (m)) (n)) (posn)) (H1)) (H))) (H))) ((((((Hind) (n)) (((mod) (m)) (n))) (((((((match_Or_prop) (((lt) (O)) (((mod) (m)) (n)))) ((((eq) (nat)) (O)) (((mod) (m)) (n)))) (((lt) (O)) (((mod) (m)) (n)))) (fun auto : ((lt) (O)) (((mod) (m)) (n)) => auto)) (fun modO : (((eq) (nat)) (O)) (((mod) (m)) (n)) => ((falsity) (((lt) (O)) (((mod) (m)) (n)))) ((((absurd) (((divides) (n)) (m))) (((((mod_O_to_divides) (n)) (m)) (posn)) (((((((rewrite_l) (nat)) (O)) (fun Joker_ : nat => (((eq) (nat)) (Joker_)) (O))) (((refl) (nat)) (O))) (((mod) (m)) (n))) (modO)))) (ndivnm)))) ((((le_to_or_lt_eq) (O)) (((mod) (m)) (n))) ((le_O_n) (((mod) (m)) (n)))))) ((((lt_to_le) (((mod) (m)) (n))) (n)) ((((lt_mod_m_m) (m)) (n)) (posn)))) ((((le_S_S_to_le) (((mod) (m)) (n))) (q)) ((((((transitive_le) ((S) (((mod) (m)) (n)))) (n)) ((S) (q))) ((((lt_mod_m_m) (m)) (n)) (posn))) (lenS)))))) ((((gcd_aux) ((S) (q))) (m)) (n))) ((((((not_divides_to_gcd_aux) (q)) (m)) (n)) (posn)) (ndivnm)))) (((decidable_divides) (n)) (m)))) (p).
Definition divides_gcd_nm : forall n : nat, forall m : nat, ((And) (((divides) (((gcd) (n)) (m))) (m))) (((divides) (((gcd) (n)) (m))) (n)) := fun n : nat => fun m : nat => ((((((match_Or_prop) (((lt) (O)) (n))) ((((eq) (nat)) (O)) (n))) (((And) (((divides) (((gcd) (n)) (m))) (m))) (((divides) (((gcd) (n)) (m))) (n)))) (fun posn : ((lt) (O)) (n) => ((((((match_Or_prop) (((lt) (O)) (m))) ((((eq) (nat)) (O)) (m))) (((And) (((divides) (((gcd) (n)) (m))) (m))) (((divides) (((gcd) (n)) (m))) (n)))) (fun posm : ((lt) (O)) (m) => (((((leb_elim) (n)) (m)) (fun Joker_ : bool => ((And) (((divides) (((((match_bool_type) (nat)) ((((gcd_aux) (n)) (m)) (n))) ((((gcd_aux) (m)) (n)) (m))) (Joker_))) (m))) (((divides) (((((match_bool_type) (nat)) ((((gcd_aux) (n)) (m)) (n))) ((((gcd_aux) (m)) (n)) (m))) (Joker_))) (n)))) ((((((sym_eq_match_bool_type_true) (nat)) ((((gcd_aux) (n)) (m)) (n))) ((((gcd_aux) (m)) (n)) (m))) (fun y : nat => (((le) (n)) (m)) -> ((And) (((divides) (((((match_bool_type) (nat)) ((((gcd_aux) (n)) (m)) (n))) ((((gcd_aux) (m)) (n)) (m))) (true))) (m))) (((divides) (y)) (n)))) ((((((sym_eq_match_bool_type_true) (nat)) ((((gcd_aux) (n)) (m)) (n))) ((((gcd_aux) (m)) (n)) (m))) (fun y : nat => (((le) (n)) (m)) -> ((And) (((divides) (y)) (m))) (((divides) ((((gcd_aux) (n)) (m)) (n))) (n)))) (fun lenm : ((le) (n)) (m) => ((((((divides_gcd_aux_mn) (n)) (m)) (n)) (posn)) (lenm)) ((le_n) (n)))))) ((((((sym_eq_match_bool_type_false) (nat)) ((((gcd_aux) (n)) (m)) (n))) ((((gcd_aux) (m)) (n)) (m))) (fun y : nat => ((Not) (((le) (n)) (m))) -> ((And) (((divides) (((((match_bool_type) (nat)) ((((gcd_aux) (n)) (m)) (n))) ((((gcd_aux) (m)) (n)) (m))) (false))) (m))) (((divides) (y)) (n)))) ((((((sym_eq_match_bool_type_false) (nat)) ((((gcd_aux) (n)) (m)) (n))) ((((gcd_aux) (m)) (n)) (m))) (fun y : nat => ((Not) (((le) (n)) (m))) -> ((And) (((divides) (y)) (m))) (((divides) ((((gcd_aux) (m)) (n)) (m))) (n)))) (fun notlt : (Not) (((le) (n)) (m)) => (((((match_And_prop) (((divides) ((((gcd_aux) (m)) (n)) (m))) (n))) (((divides) ((((gcd_aux) (m)) (n)) (m))) (m))) (((And) (((divides) ((((gcd_aux) (m)) (n)) (m))) (m))) (((divides) ((((gcd_aux) (m)) (n)) (m))) (n)))) (fun auto : ((divides) ((((gcd_aux) (m)) (n)) (m))) (n) => fun auto' : ((divides) ((((gcd_aux) (m)) (n)) (m))) (m) => fun z : Prop => fun f : (((divides) ((((gcd_aux) (m)) (n)) (m))) (m)) -> (((divides) ((((gcd_aux) (m)) (n)) (m))) (n)) -> z => ((f) (auto')) (auto))) (((((((divides_gcd_aux_mn) (m)) (n)) (m)) (posm)) ((((((transitive_le) (m)) ((S) (m))) (n)) ((le_n_Sn) (m))) ((((not_le_to_lt) (n)) (m)) (notlt)))) ((le_n) (m)))))))) (fun eqmO : (((eq) (nat)) (O)) (m) => ((((((eq_ind) (nat)) (O)) (fun x_1 : nat => ((And) (((divides) (((gcd) (n)) (x_1))) (x_1))) (((divides) (((gcd) (n)) (x_1))) (n)))) (fun z : Prop => fun f : (((divides) (((gcd) (n)) (O))) (O)) -> (((divides) (((gcd) (n)) (O))) (n)) -> z => ((f) ((divides_n_O) (((gcd) (n)) (O)))) (((((eq_coerc) (((divides) (((gcd) (n)) (O))) (((gcd) (n)) (O)))) (((divides) (((gcd) (n)) (O))) (n))) ((divides_n_n) (((gcd) (n)) (O)))) (((((((rewrite_r) (nat)) (n)) (fun Joker_ : nat => (((eq) Prop) (((divides) (((gcd) (n)) (O))) (Joker_))) (((divides) (((gcd) (n)) (O))) (n)))) (((refl) Prop) (((divides) (((gcd) (n)) (O))) (n)))) (((gcd) (n)) (O))) (((((((rewrite_l) (nat)) (((gcd) (O)) (n))) (fun Joker_ : nat => (((eq) (nat)) (((gcd) (n)) (O))) (Joker_))) (((commutative_gcd) (n)) (O))) (n)) ((gcd_O_l) (n))))))) (m)) (eqmO))) ((((le_to_or_lt_eq) (O)) (m)) ((le_O_n) (m))))) (fun eqnO : (((eq) (nat)) (O)) (n) => ((((((eq_ind) (nat)) (O)) (fun x_1 : nat => ((And) (((divides) (((gcd) (x_1)) (m))) (m))) (((divides) (((gcd) (x_1)) (m))) (x_1)))) (fun z : Prop => fun f : (((divides) (((gcd) (O)) (m))) (m)) -> (((divides) (((gcd) (O)) (m))) (O)) -> z => ((f) ((((((eq_match_bool_type_true) (nat)) (m)) ((((gcd_aux) (m)) (O)) (m))) (fun y : nat => ((divides) (((((match_bool_type) (nat)) ((((gcd_aux) (O)) (m)) (O))) ((((gcd_aux) (m)) (O)) (m))) (((leb) (O)) (m)))) (y))) (((eq_leb_body_O) (fun y : (nat) -> bool => ((divides) (((((match_bool_type) (nat)) ((((gcd_aux) (O)) (m)) (O))) ((((gcd_aux) (m)) (O)) (m))) (((leb) (O)) (m)))) (((((match_bool_type) (nat)) (m)) ((((gcd_aux) (m)) (O)) (m))) ((y) (m))))) (((((eq_filter_nat_type_O) ((nat) -> bool)) (leb_body)) (fun y : (nat) -> bool => ((divides) (((((match_bool_type) (nat)) ((((gcd_aux) (O)) (m)) (O))) ((((gcd_aux) (m)) (O)) (m))) (((leb) (O)) (m)))) (((((match_bool_type) (nat)) (m)) ((((gcd_aux) (m)) (O)) (m))) ((y) (m))))) ((((eq_leb) (O)) (fun y : (nat) -> bool => ((divides) (((((match_bool_type) (nat)) ((((gcd_aux) (O)) (m)) (O))) ((((gcd_aux) (m)) (O)) (m))) (((leb) (O)) (m)))) (((((match_bool_type) (nat)) (m)) ((((gcd_aux) (m)) (O)) (m))) ((y) (m))))) (((eq_gcd_aux_body_O) (fun y : (nat) -> (nat) -> nat => ((divides) (((gcd) (O)) (m))) (((((match_bool_type) (nat)) (((y) (m)) (O))) ((((gcd_aux) (m)) (O)) (m))) (((leb) (O)) (m))))) (((((eq_filter_nat_type_O) ((nat) -> (nat) -> nat)) (gcd_aux_body)) (fun y : (nat) -> (nat) -> nat => ((divides) (((gcd) (O)) (m))) (((((match_bool_type) (nat)) (((y) (m)) (O))) ((((gcd_aux) (m)) (O)) (m))) (((leb) (O)) (m))))) ((((eq_gcd_aux) (O)) (fun y : (nat) -> (nat) -> nat => ((divides) (((gcd) (O)) (m))) (((((match_bool_type) (nat)) (((y) (m)) (O))) ((((gcd_aux) (m)) (O)) (m))) (((leb) (O)) (m))))) ((divides_n_n) (((gcd) (O)) (m))))))))))) ((divides_n_O) (((gcd) (O)) (m))))) (n)) (eqnO))) ((((le_to_or_lt_eq) (O)) (n)) ((le_O_n) (n))).
Definition divides_gcd_l : forall n : nat, forall m : nat, ((divides) (((gcd) (n)) (m))) (n) := fun n : nat => fun m : nat => (((proj2) (((divides) (((gcd) (n)) (m))) (m))) (((divides) (((gcd) (n)) (m))) (n))) (((divides_gcd_nm) (n)) (m)).
Definition divides_gcd_r : forall n : nat, forall m : nat, ((divides) (((gcd) (n)) (m))) (m) := fun n : nat => fun m : nat => (((proj1) (((divides) (((gcd) (n)) (m))) (m))) (((divides) (((gcd) (n)) (m))) (n))) (((divides_gcd_nm) (n)) (m)).
Definition let_clause_1544 : forall p : nat, forall q : nat, (forall m : nat, forall n : nat, (((lt) (O)) (n)) -> (((le) (n)) (m)) -> (((le) (n)) (q)) -> ((Ex) (nat)) (fun a : nat => ((Ex) (nat)) (fun b : nat => ((Or) ((((eq) (nat)) (((minus) (((times) (a)) (n))) (((times) (b)) (m)))) ((((gcd_aux) (q)) (m)) (n)))) ((((eq) (nat)) (((minus) (((times) (b)) (m))) (((times) (a)) (n)))) ((((gcd_aux) (q)) (m)) (n)))))) -> forall m : nat, forall n : nat, (((lt) (O)) (n)) -> (((le) (n)) (m)) -> (((le) (n)) ((S) (q))) -> ((Not) (((divides) (n)) (m))) -> forall a : nat, (((Ex) (nat)) (fun b : nat => ((Or) ((((eq) (nat)) (((minus) (((times) (a)) (((mod) (m)) (n)))) (((times) (b)) (n)))) ((((gcd_aux) (q)) (n)) (((mod) (m)) (n))))) ((((eq) (nat)) (((minus) (((times) (b)) (n))) (((times) (a)) (((mod) (m)) (n))))) ((((gcd_aux) (q)) (n)) (((mod) (m)) (n)))))) -> forall b : nat, (((Or) ((((eq) (nat)) (((minus) (((times) (a)) (((mod) (m)) (n)))) (((times) (b)) (n)))) ((((gcd_aux) (q)) (n)) (((mod) (m)) (n))))) ((((eq) (nat)) (((minus) (((times) (b)) (n))) (((times) (a)) (((mod) (m)) (n))))) ((((gcd_aux) (q)) (n)) (((mod) (m)) (n))))) -> ((((eq) (nat)) (((minus) (((times) (a)) (((mod) (m)) (n)))) (((times) (b)) (n)))) ((((gcd_aux) (q)) (n)) (((mod) (m)) (n)))) -> (((eq) (nat)) (((minus) (((times) (a)) (((mod) (m)) (n)))) (((times) (n)) (b)))) ((((gcd_aux) (q)) (n)) (((mod) (m)) (n))) := fun p : nat => fun q : nat => fun Hind : forall m : nat, forall n : nat, (((lt) (O)) (n)) -> (((le) (n)) (m)) -> (((le) (n)) (q)) -> ((Ex) (nat)) (fun a : nat => ((Ex) (nat)) (fun b : nat => ((Or) ((((eq) (nat)) (((minus) (((times) (a)) (n))) (((times) (b)) (m)))) ((((gcd_aux) (q)) (m)) (n)))) ((((eq) (nat)) (((minus) (((times) (b)) (m))) (((times) (a)) (n)))) ((((gcd_aux) (q)) (m)) (n))))) => fun m : nat => fun n : nat => fun posn : ((lt) (O)) (n) => fun lenm : ((le) (n)) (m) => fun lenS : ((le) (n)) ((S) (q)) => fun ndivnm : (Not) (((divides) (n)) (m)) => fun a : nat => fun Jokerclearme : ((Ex) (nat)) (fun b : nat => ((Or) ((((eq) (nat)) (((minus) (((times) (a)) (((mod) (m)) (n)))) (((times) (b)) (n)))) ((((gcd_aux) (q)) (n)) (((mod) (m)) (n))))) ((((eq) (nat)) (((minus) (((times) (b)) (n))) (((times) (a)) (((mod) (m)) (n))))) ((((gcd_aux) (q)) (n)) (((mod) (m)) (n))))) => fun b : nat => fun Jokerclearme0 : ((Or) ((((eq) (nat)) (((minus) (((times) (a)) (((mod) (m)) (n)))) (((times) (b)) (n)))) ((((gcd_aux) (q)) (n)) (((mod) (m)) (n))))) ((((eq) (nat)) (((minus) (((times) (b)) (n))) (((times) (a)) (((mod) (m)) (n))))) ((((gcd_aux) (q)) (n)) (((mod) (m)) (n)))) => fun H : (((eq) (nat)) (((minus) (((times) (a)) (((mod) (m)) (n)))) (((times) (b)) (n)))) ((((gcd_aux) (q)) (n)) (((mod) (m)) (n))) => ((((((rewrite_l) (nat)) (((times) (b)) (n))) (fun Joker_ : nat => (((eq) (nat)) (((minus) (((times) (a)) (((mod) (m)) (n)))) (Joker_))) ((((gcd_aux) (q)) (n)) (((mod) (m)) (n))))) (H)) (((times) (n)) (b))) (((commutative_times) (b)) (n)).
Definition let_clause_15441 : forall p : nat, forall q : nat, (forall m : nat, forall n : nat, (((lt) (O)) (n)) -> (((le) (n)) (m)) -> (((le) (n)) (q)) -> ((Ex) (nat)) (fun a : nat => ((Ex) (nat)) (fun b : nat => ((Or) ((((eq) (nat)) (((minus) (((times) (a)) (n))) (((times) (b)) (m)))) ((((gcd_aux) (q)) (m)) (n)))) ((((eq) (nat)) (((minus) (((times) (b)) (m))) (((times) (a)) (n)))) ((((gcd_aux) (q)) (m)) (n)))))) -> forall m : nat, forall n : nat, (((lt) (O)) (n)) -> (((le) (n)) (m)) -> (((le) (n)) ((S) (q))) -> ((Not) (((divides) (n)) (m))) -> forall a : nat, (((Ex) (nat)) (fun b : nat => ((Or) ((((eq) (nat)) (((minus) (((times) (a)) (((mod) (m)) (n)))) (((times) (b)) (n)))) ((((gcd_aux) (q)) (n)) (((mod) (m)) (n))))) ((((eq) (nat)) (((minus) (((times) (b)) (n))) (((times) (a)) (((mod) (m)) (n))))) ((((gcd_aux) (q)) (n)) (((mod) (m)) (n)))))) -> forall b : nat, (((Or) ((((eq) (nat)) (((minus) (((times) (a)) (((mod) (m)) (n)))) (((times) (b)) (n)))) ((((gcd_aux) (q)) (n)) (((mod) (m)) (n))))) ((((eq) (nat)) (((minus) (((times) (b)) (n))) (((times) (a)) (((mod) (m)) (n))))) ((((gcd_aux) (q)) (n)) (((mod) (m)) (n))))) -> ((((eq) (nat)) (((minus) (((times) (b)) (n))) (((times) (a)) (((mod) (m)) (n))))) ((((gcd_aux) (q)) (n)) (((mod) (m)) (n)))) -> (((eq) (nat)) (((minus) (((times) (n)) (b))) (((times) (a)) (((mod) (m)) (n))))) ((((gcd_aux) (q)) (n)) (((mod) (m)) (n))) := fun p : nat => fun q : nat => fun Hind : forall m : nat, forall n : nat, (((lt) (O)) (n)) -> (((le) (n)) (m)) -> (((le) (n)) (q)) -> ((Ex) (nat)) (fun a : nat => ((Ex) (nat)) (fun b : nat => ((Or) ((((eq) (nat)) (((minus) (((times) (a)) (n))) (((times) (b)) (m)))) ((((gcd_aux) (q)) (m)) (n)))) ((((eq) (nat)) (((minus) (((times) (b)) (m))) (((times) (a)) (n)))) ((((gcd_aux) (q)) (m)) (n))))) => fun m : nat => fun n : nat => fun posn : ((lt) (O)) (n) => fun lenm : ((le) (n)) (m) => fun lenS : ((le) (n)) ((S) (q)) => fun ndivnm : (Not) (((divides) (n)) (m)) => fun a : nat => fun Jokerclearme : ((Ex) (nat)) (fun b : nat => ((Or) ((((eq) (nat)) (((minus) (((times) (a)) (((mod) (m)) (n)))) (((times) (b)) (n)))) ((((gcd_aux) (q)) (n)) (((mod) (m)) (n))))) ((((eq) (nat)) (((minus) (((times) (b)) (n))) (((times) (a)) (((mod) (m)) (n))))) ((((gcd_aux) (q)) (n)) (((mod) (m)) (n))))) => fun b : nat => fun Jokerclearme0 : ((Or) ((((eq) (nat)) (((minus) (((times) (a)) (((mod) (m)) (n)))) (((times) (b)) (n)))) ((((gcd_aux) (q)) (n)) (((mod) (m)) (n))))) ((((eq) (nat)) (((minus) (((times) (b)) (n))) (((times) (a)) (((mod) (m)) (n))))) ((((gcd_aux) (q)) (n)) (((mod) (m)) (n)))) => fun H : (((eq) (nat)) (((minus) (((times) (b)) (n))) (((times) (a)) (((mod) (m)) (n))))) ((((gcd_aux) (q)) (n)) (((mod) (m)) (n))) => ((((((rewrite_l) (nat)) (((times) (b)) (n))) (fun Joker_ : nat => (((eq) (nat)) (((minus) (Joker_)) (((times) (a)) (((mod) (m)) (n))))) ((((gcd_aux) (q)) (n)) (((mod) (m)) (n))))) (H)) (((times) (n)) (b))) (((commutative_times) (b)) (n)).
Definition eq_minus_gcd_aux : forall p : nat, forall m : nat, forall n : nat, (((lt) (O)) (n)) -> (((le) (n)) (m)) -> (((le) (n)) (p)) -> ((Ex) (nat)) (fun a : nat => ((Ex) (nat)) (fun b : nat => ((Or) ((((eq) (nat)) (((minus) (((times) (a)) (n))) (((times) (b)) (m)))) ((((gcd_aux) (p)) (m)) (n)))) ((((eq) (nat)) (((minus) (((times) (b)) (m))) (((times) (a)) (n)))) ((((gcd_aux) (p)) (m)) (n))))) := fun p : nat => ((((nat_ind) (fun Jokerx_365 : nat => forall m : nat, forall n : nat, (((lt) (O)) (n)) -> (((le) (n)) (m)) -> (((le) (n)) (Jokerx_365)) -> ((Ex) (nat)) (fun a : nat => ((Ex) (nat)) (fun b : nat => ((Or) ((((eq) (nat)) (((minus) (((times) (a)) (n))) (((times) (b)) (m)))) ((((gcd_aux) (Jokerx_365)) (m)) (n)))) ((((eq) (nat)) (((minus) (((times) (b)) (m))) (((times) (a)) (n)))) ((((gcd_aux) (Jokerx_365)) (m)) (n))))))) (fun m : nat => fun n : nat => fun posn : ((lt) (O)) (n) => fun lenm : ((le) (n)) (m) => fun lenO : ((le) (n)) (O) => ((falsity) (((Ex) (nat)) (fun a : nat => ((Ex) (nat)) (fun b : nat => ((Or) ((((eq) (nat)) (((minus) (((times) (a)) (n))) (((times) (b)) (m)))) ((((gcd_aux) (O)) (m)) (n)))) ((((eq) (nat)) (((minus) (((times) (b)) (m))) (((times) (a)) (n)))) ((((gcd_aux) (O)) (m)) (n))))))) ((((absurd) (((lt) (O)) (n))) (posn)) ((((le_to_not_lt) (n)) (O)) (lenO))))) (fun q : nat => fun Hind : forall m : nat, forall n : nat, (((lt) (O)) (n)) -> (((le) (n)) (m)) -> (((le) (n)) (q)) -> ((Ex) (nat)) (fun a : nat => ((Ex) (nat)) (fun b : nat => ((Or) ((((eq) (nat)) (((minus) (((times) (a)) (n))) (((times) (b)) (m)))) ((((gcd_aux) (q)) (m)) (n)))) ((((eq) (nat)) (((minus) (((times) (b)) (m))) (((times) (a)) (n)))) ((((gcd_aux) (q)) (m)) (n))))) => fun m : nat => fun n : nat => fun posn : ((lt) (O)) (n) => fun lenm : ((le) (n)) (m) => fun lenS : ((le) (n)) ((S) (q)) => ((((((match_Or_prop) (((divides) (n)) (m))) ((Not) (((divides) (n)) (m)))) (((Ex) (nat)) (fun a : nat => ((Ex) (nat)) (fun b : nat => ((Or) ((((eq) (nat)) (((minus) (((times) (a)) (n))) (((times) (b)) (m)))) ((((gcd_aux) ((S) (q))) (m)) (n)))) ((((eq) (nat)) (((minus) (((times) (b)) (m))) (((times) (a)) (n)))) ((((gcd_aux) ((S) (q))) (m)) (n))))))) (fun divnm : ((divides) (n)) (m) => ((((((eq_ind_r) (nat)) (n)) (fun x : nat => ((Ex) (nat)) (fun a : nat => ((Ex) (nat)) (fun b : nat => ((Or) ((((eq) (nat)) (((minus) (((times) (a)) (n))) (((times) (b)) (m)))) (x))) ((((eq) (nat)) (((minus) (((times) (b)) (m))) (((times) (a)) (n)))) (x)))))) (fun z : Prop => fun f : forall x : nat, (((Ex) (nat)) (fun b : nat => ((Or) ((((eq) (nat)) (((minus) (((times) (x)) (n))) (((times) (b)) (m)))) (n))) ((((eq) (nat)) (((minus) (((times) (b)) (m))) (((times) (x)) (n)))) (n)))) -> z => ((f) ((S) (O))) (fun z0 : Prop => fun f2 : forall x : nat, (((Or) ((((eq) (nat)) (((minus) (((times) ((S) (O))) (n))) (((times) (x)) (m)))) (n))) ((((eq) (nat)) (((minus) (((times) (x)) (m))) (((times) ((S) (O))) (n)))) (n))) -> z0 => ((f2) (O)) (fun z1 : Prop => fun l : ((((eq) (nat)) (((minus) (((times) ((S) (O))) (n))) (((times) (O)) (m)))) (n)) -> z1 => fun r : ((((eq) (nat)) (((minus) (((times) (O)) (m))) (((times) ((S) (O))) (n)))) (n)) -> z1 => (l) (((((((rewrite_r) (nat)) (((times) (n)) ((S) (O)))) (fun Joker_ : nat => (((eq) (nat)) (((minus) (Joker_)) (((times) (O)) (m)))) (n))) (((((((rewrite_l) (nat)) (((plus) (n)) (((times) (n)) (O)))) (fun Joker_ : nat => (((eq) (nat)) (((minus) (Joker_)) (((times) (O)) (m)))) (n))) (((((((rewrite_l) (nat)) (O)) (fun Joker_ : nat => (((eq) (nat)) (((minus) (((plus) (n)) (Joker_))) (((times) (O)) (m)))) (n))) (((((((rewrite_l) (nat)) (n)) (fun Joker_ : nat => (((eq) (nat)) (((minus) (Joker_)) (((times) (O)) (m)))) (n))) (((((((rewrite_r) (nat)) (((times) (m)) (O))) (fun Joker_ : nat => (((eq) (nat)) (((minus) (n)) (Joker_))) (n))) (((((((rewrite_l) (nat)) (O)) (fun Joker_ : nat => (((eq) (nat)) (((minus) (n)) (Joker_))) (n))) (((((((rewrite_l) (nat)) (n)) (fun Joker_ : nat => (((eq) (nat)) (Joker_)) (n))) (((refl) (nat)) (n))) (((minus) (n)) (O))) ((minus_n_O) (n)))) (((times) (m)) (O))) ((times_n_O) (m)))) (((times) (O)) (m))) (((commutative_times) (O)) (m)))) (((plus) (n)) (O))) ((plus_n_O) (n)))) (((times) (n)) (O))) ((times_n_O) (n)))) (((times) (n)) ((S) (O)))) (((times_n_Sm) (n)) (O)))) (((times) ((S) (O))) (n))) (((commutative_times) ((S) (O))) (n))))))) ((((gcd_aux) ((S) (q))) (m)) (n))) (((((((divides_to_gcd_aux) ((S) (q))) (m)) (n)) ((lt_O_S) (q))) (posn)) (divnm)))) (fun ndivnm : (Not) (((divides) (n)) (m)) => ((((((eq_ind_r) (nat)) ((((gcd_aux) (q)) (n)) (((mod) (m)) (n)))) (fun x : nat => ((Ex) (nat)) (fun a : nat => ((Ex) (nat)) (fun b : nat => ((Or) ((((eq) (nat)) (((minus) (((times) (a)) (n))) (((times) (b)) (m)))) (x))) ((((eq) (nat)) (((minus) (((times) (b)) (m))) (((times) (a)) (n)))) (x)))))) ((((((match_ex_prop) (nat)) (fun a : nat => ((Ex) (nat)) (fun b : nat => ((Or) ((((eq) (nat)) (((minus) (((times) (a)) (((mod) (m)) (n)))) (((times) (b)) (n)))) ((((gcd_aux) (q)) (n)) (((mod) (m)) (n))))) ((((eq) (nat)) (((minus) (((times) (b)) (n))) (((times) (a)) (((mod) (m)) (n))))) ((((gcd_aux) (q)) (n)) (((mod) (m)) (n))))))) (((Ex) (nat)) (fun a : nat => ((Ex) (nat)) (fun b : nat => ((Or) ((((eq) (nat)) (((minus) (((times) (a)) (n))) (((times) (b)) (m)))) ((((gcd_aux) (q)) (n)) (((mod) (m)) (n))))) ((((eq) (nat)) (((minus) (((times) (b)) (m))) (((times) (a)) (n)))) ((((gcd_aux) (q)) (n)) (((mod) (m)) (n)))))))) (fun a : nat => fun Jokerclearme : ((Ex) (nat)) (fun b : nat => ((Or) ((((eq) (nat)) (((minus) (((times) (a)) (((mod) (m)) (n)))) (((times) (b)) (n)))) ((((gcd_aux) (q)) (n)) (((mod) (m)) (n))))) ((((eq) (nat)) (((minus) (((times) (b)) (n))) (((times) (a)) (((mod) (m)) (n))))) ((((gcd_aux) (q)) (n)) (((mod) (m)) (n))))) => (((((match_ex_prop) (nat)) (fun b : nat => ((Or) ((((eq) (nat)) (((minus) (((times) (a)) (((mod) (m)) (n)))) (((times) (b)) (n)))) ((((gcd_aux) (q)) (n)) (((mod) (m)) (n))))) ((((eq) (nat)) (((minus) (((times) (b)) (n))) (((times) (a)) (((mod) (m)) (n))))) ((((gcd_aux) (q)) (n)) (((mod) (m)) (n)))))) (((Ex) (nat)) (fun a0 : nat => ((Ex) (nat)) (fun b : nat => ((Or) ((((eq) (nat)) (((minus) (((times) (a0)) (n))) (((times) (b)) (m)))) ((((gcd_aux) (q)) (n)) (((mod) (m)) (n))))) ((((eq) (nat)) (((minus) (((times) (b)) (m))) (((times) (a0)) (n)))) ((((gcd_aux) (q)) (n)) (((mod) (m)) (n)))))))) (fun b : nat => fun Jokerclearme0 : ((Or) ((((eq) (nat)) (((minus) (((times) (a)) (((mod) (m)) (n)))) (((times) (b)) (n)))) ((((gcd_aux) (q)) (n)) (((mod) (m)) (n))))) ((((eq) (nat)) (((minus) (((times) (b)) (n))) (((times) (a)) (((mod) (m)) (n))))) ((((gcd_aux) (q)) (n)) (((mod) (m)) (n)))) => ((((((match_Or_prop) ((((eq) (nat)) (((minus) (((times) (a)) (((mod) (m)) (n)))) (((times) (b)) (n)))) ((((gcd_aux) (q)) (n)) (((mod) (m)) (n))))) ((((eq) (nat)) (((minus) (((times) (b)) (n))) (((times) (a)) (((mod) (m)) (n))))) ((((gcd_aux) (q)) (n)) (((mod) (m)) (n))))) (((Ex) (nat)) (fun a0 : nat => ((Ex) (nat)) (fun b0 : nat => ((Or) ((((eq) (nat)) (((minus) (((times) (a0)) (n))) (((times) (b0)) (m)))) ((((gcd_aux) (q)) (n)) (((mod) (m)) (n))))) ((((eq) (nat)) (((minus) (((times) (b0)) (m))) (((times) (a0)) (n)))) ((((gcd_aux) (q)) (n)) (((mod) (m)) (n)))))))) (fun H : (((eq) (nat)) (((minus) (((times) (a)) (((mod) (m)) (n)))) (((times) (b)) (n)))) ((((gcd_aux) (q)) (n)) (((mod) (m)) (n))) => ((((((eq_ind) (nat)) (((minus) (((times) (a)) (((mod) (m)) (n)))) (((times) (b)) (n)))) (fun x_1 : nat => ((Ex) (nat)) (fun a0 : nat => ((Ex) (nat)) (fun b0 : nat => ((Or) ((((eq) (nat)) (((minus) (((times) (a0)) (n))) (((times) (b0)) (m)))) (x_1))) ((((eq) (nat)) (((minus) (((times) (b0)) (m))) (((times) (a0)) (n)))) (x_1)))))) (fun z : Prop => fun f : forall x : nat, (((Ex) (nat)) (fun b0 : nat => ((Or) ((((eq) (nat)) (((minus) (((times) (x)) (n))) (((times) (b0)) (m)))) (((minus) (((times) (a)) (((mod) (m)) (n)))) (((times) (b)) (n))))) ((((eq) (nat)) (((minus) (((times) (b0)) (m))) (((times) (x)) (n)))) (((minus) (((times) (a)) (((mod) (m)) (n)))) (((times) (b)) (n)))))) -> z => ((f) (((plus) (b)) (((times) (a)) (((div) (m)) (n))))) (fun z0 : Prop => fun f0 : forall x : nat, (((Or) ((((eq) (nat)) (((minus) (((times) (((plus) (b)) (((times) (a)) (((div) (m)) (n))))) (n))) (((times) (x)) (m)))) (((minus) (((times) (a)) (((mod) (m)) (n)))) (((times) (b)) (n))))) ((((eq) (nat)) (((minus) (((times) (x)) (m))) (((times) (((plus) (b)) (((times) (a)) (((div) (m)) (n))))) (n)))) (((minus) (((times) (a)) (((mod) (m)) (n)))) (((times) (b)) (n))))) -> z0 => ((f0) (a)) (fun z1 : Prop => fun l : ((((eq) (nat)) (((minus) (((times) (((plus) (b)) (((times) (a)) (((div) (m)) (n))))) (n))) (((times) (a)) (m)))) (((minus) (((times) (a)) (((mod) (m)) (n)))) (((times) (b)) (n)))) -> z1 => fun r : ((((eq) (nat)) (((minus) (((times) (a)) (m))) (((times) (((plus) (b)) (((times) (a)) (((div) (m)) (n))))) (n)))) (((minus) (((times) (a)) (((mod) (m)) (n)))) (((times) (b)) (n)))) -> z1 => (r) (((((((eq_ind) (nat)) (((plus) (((times) (a)) (((div) (m)) (n)))) (b))) (fun x_1 : nat => (((eq) (nat)) (((minus) (((times) (a)) (m))) (((times) (x_1)) (n)))) (((minus) (((times) (a)) (((mod) (m)) (n)))) (((times) (b)) (n))))) (((((((eq_ind_r) (nat)) (((plus) (((times) (((times) (a)) (((div) (m)) (n)))) (n))) (((times) (b)) (n)))) (fun x : nat => (((eq) (nat)) (((minus) (((times) (a)) (m))) (x))) (((minus) (((times) (a)) (((mod) (m)) (n)))) (((times) (b)) (n))))) (((((((eq_ind_r) (nat)) (((plus) (((times) (((div) (m)) (n))) (n))) (((mod) (m)) (n)))) (fun x : nat => (((eq) (nat)) (((minus) (((times) (a)) (x))) (((plus) (((times) (((times) (a)) (((div) (m)) (n)))) (n))) (((times) (b)) (n))))) (((minus) (((times) (a)) (((mod) (m)) (n)))) (((times) (b)) (n))))) (((((((eq_ind_r) (nat)) (((times) (a)) (((times) (((div) (m)) (n))) (n)))) (fun x : nat => (((eq) (nat)) (((minus) (((times) (a)) (((plus) (((times) (((div) (m)) (n))) (n))) (((mod) (m)) (n))))) (((plus) (x)) (((times) (b)) (n))))) (((minus) (((times) (a)) (((mod) (m)) (n)))) (((times) (b)) (n))))) (((((((eq_ind) (nat)) (((plus) (((mod) (m)) (n))) (((times) (((div) (m)) (n))) (n)))) (fun x_1 : nat => (((eq) (nat)) (((minus) (((times) (a)) (x_1))) (((plus) (((times) (a)) (((times) (((div) (m)) (n))) (n)))) (((times) (b)) (n))))) (((minus) (((times) (a)) (((mod) (m)) (n)))) (((times) (b)) (n))))) (((((((eq_ind_r) (nat)) (((plus) (((times) (a)) (((mod) (m)) (n)))) (((times) (a)) (((times) (((div) (m)) (n))) (n))))) (fun x : nat => (((eq) (nat)) (((minus) (x)) (((plus) (((times) (a)) (((times) (((div) (m)) (n))) (n)))) (((times) (b)) (n))))) (((minus) (((times) (a)) (((mod) (m)) (n)))) (((times) (b)) (n))))) (((((((eq_ind) (nat)) (((minus) (((minus) (((plus) (((times) (a)) (((mod) (m)) (n)))) (((times) (a)) (((times) (((div) (m)) (n))) (n))))) (((times) (a)) (((times) (((div) (m)) (n))) (n))))) (((times) (b)) (n)))) (fun x_1 : nat => (((eq) (nat)) (x_1)) (((minus) (((times) (a)) (((mod) (m)) (n)))) (((times) (b)) (n))))) (((((((eq_ind) (nat)) (((plus) (((times) (a)) (((times) (((div) (m)) (n))) (n)))) (((times) (a)) (((mod) (m)) (n))))) (fun x_1 : nat => (((eq) (nat)) (((minus) (((minus) (x_1)) (((times) (a)) (((times) (((div) (m)) (n))) (n))))) (((times) (b)) (n)))) (((minus) (((times) (a)) (((mod) (m)) (n)))) (((times) (b)) (n))))) (((((((eq_ind) (nat)) (((plus) (((minus) (((times) (a)) (((times) (((div) (m)) (n))) (n)))) (((times) (a)) (((times) (((div) (m)) (n))) (n))))) (((times) (a)) (((mod) (m)) (n))))) (fun x_1 : nat => (((eq) (nat)) (((minus) (x_1)) (((times) (b)) (n)))) (((minus) (((times) (a)) (((mod) (m)) (n)))) (((times) (b)) (n))))) (((((((rewrite_r) (nat)) (((times) (n)) (((div) (m)) (n)))) (fun Joker_ : nat => (((eq) (nat)) (((minus) (((plus) (((minus) (((times) (a)) (Joker_))) (((times) (a)) (((times) (((div) (m)) (n))) (n))))) (((times) (a)) (((mod) (m)) (n))))) (((times) (b)) (n)))) (((minus) (((times) (a)) (((mod) (m)) (n)))) (((times) (b)) (n))))) (((((((rewrite_r) (nat)) (((times) (n)) (((times) (a)) (((div) (m)) (n))))) (fun Joker_ : nat => (((eq) (nat)) (((minus) (((plus) (((minus) (Joker_)) (((times) (a)) (((times) (((div) (m)) (n))) (n))))) (((times) (a)) (((mod) (m)) (n))))) (((times) (b)) (n)))) (((minus) (((times) (a)) (((mod) (m)) (n)))) (((times) (b)) (n))))) (((((((rewrite_r) (nat)) (((times) (n)) (((div) (m)) (n)))) (fun Joker_ : nat => (((eq) (nat)) (((minus) (((plus) (((minus) (((times) (n)) (((times) (a)) (((div) (m)) (n))))) (((times) (a)) (Joker_)))) (((times) (a)) (((mod) (m)) (n))))) (((times) (b)) (n)))) (((minus) (((times) (a)) (((mod) (m)) (n)))) (((times) (b)) (n))))) (((((((rewrite_r) (nat)) (((times) (n)) (((times) (a)) (((div) (m)) (n))))) (fun Joker_ : nat => (((eq) (nat)) (((minus) (((plus) (((minus) (((times) (n)) (((times) (a)) (((div) (m)) (n))))) (Joker_))) (((times) (a)) (((mod) (m)) (n))))) (((times) (b)) (n)))) (((minus) (((times) (a)) (((mod) (m)) (n)))) (((times) (b)) (n))))) (((((((rewrite_l) (nat)) (O)) (fun Joker_ : nat => (((eq) (nat)) (((minus) (((plus) (Joker_)) (((times) (a)) (((mod) (m)) (n))))) (((times) (b)) (n)))) (((minus) (((times) (a)) (((mod) (m)) (n)))) (((times) (b)) (n))))) (((((((rewrite_l) (nat)) (((times) (a)) (((mod) (m)) (n)))) (fun Joker_ : nat => (((eq) (nat)) (((minus) (Joker_)) (((times) (b)) (n)))) (((minus) (((times) (a)) (((mod) (m)) (n)))) (((times) (b)) (n))))) (((((((rewrite_r) (nat)) (((times) (n)) (b))) (fun Joker_ : nat => (((eq) (nat)) (((minus) (((times) (a)) (((mod) (m)) (n)))) (Joker_))) (((minus) (((times) (a)) (((mod) (m)) (n)))) (((times) (b)) (n))))) (((((((rewrite_r) (nat)) ((((gcd_aux) (q)) (n)) (((mod) (m)) (n)))) (fun Joker_ : nat => (((eq) (nat)) (Joker_)) (((minus) (((times) (a)) (((mod) (m)) (n)))) (((times) (b)) (n))))) (((((((rewrite_r) (nat)) (((times) (n)) (b))) (fun Joker_ : nat => (((eq) (nat)) ((((gcd_aux) (q)) (n)) (((mod) (m)) (n)))) (((minus) (((times) (a)) (((mod) (m)) (n)))) (Joker_)))) (((((((rewrite_r) (nat)) ((((gcd_aux) (q)) (n)) (((mod) (m)) (n)))) (fun Joker_ : nat => (((eq) (nat)) ((((gcd_aux) (q)) (n)) (((mod) (m)) (n)))) (Joker_))) (((refl) (nat)) ((((gcd_aux) (q)) (n)) (((mod) (m)) (n))))) (((minus) (((times) (a)) (((mod) (m)) (n)))) (((times) (n)) (b)))) (((((((((((((((let_clause_1544) (p)) (q)) (Hind)) (m)) (n)) (posn)) (lenm)) (lenS)) (ndivnm)) (a)) (Jokerclearme)) (b)) (Jokerclearme0)) (H)))) (((times) (b)) (n))) (((commutative_times) (b)) (n)))) (((minus) (((times) (a)) (((mod) (m)) (n)))) (((times) (n)) (b)))) (((((((((((((((let_clause_1544) (p)) (q)) (Hind)) (m)) (n)) (posn)) (lenm)) (lenS)) (ndivnm)) (a)) (Jokerclearme)) (b)) (Jokerclearme0)) (H)))) (((times) (b)) (n))) (((commutative_times) (b)) (n)))) (((plus) (O)) (((times) (a)) (((mod) (m)) (n))))) ((plus_O_n) (((times) (a)) (((mod) (m)) (n)))))) (((minus) (((times) (n)) (((times) (a)) (((div) (m)) (n))))) (((times) (n)) (((times) (a)) (((div) (m)) (n)))))) ((minus_n_n) (((times) (n)) (((times) (a)) (((div) (m)) (n))))))) (((times) (a)) (((times) (n)) (((div) (m)) (n))))) ((((times_times) (a)) (n)) (((div) (m)) (n))))) (((times) (((div) (m)) (n))) (n))) (((commutative_times) (((div) (m)) (n))) (n)))) (((times) (a)) (((times) (n)) (((div) (m)) (n))))) ((((times_times) (a)) (n)) (((div) (m)) (n))))) (((times) (((div) (m)) (n))) (n))) (((commutative_times) (((div) (m)) (n))) (n)))) (((minus) (((plus) (((times) (a)) (((times) (((div) (m)) (n))) (n)))) (((times) (a)) (((mod) (m)) (n))))) (((times) (a)) (((times) (((div) (m)) (n))) (n))))) (((((plus_minus) (((times) (a)) (((times) (((div) (m)) (n))) (n)))) (((times) (a)) (((times) (((div) (m)) (n))) (n)))) (((times) (a)) (((mod) (m)) (n)))) ((le_n) (((times) (a)) (((times) (((div) (m)) (n))) (n))))))) (((plus) (((times) (a)) (((mod) (m)) (n)))) (((times) (a)) (((times) (((div) (m)) (n))) (n))))) (((commutative_plus) (((times) (a)) (((times) (((div) (m)) (n))) (n)))) (((times) (a)) (((mod) (m)) (n)))))) (((minus) (((plus) (((times) (a)) (((mod) (m)) (n)))) (((times) (a)) (((times) (((div) (m)) (n))) (n))))) (((plus) (((times) (a)) (((times) (((div) (m)) (n))) (n)))) (((times) (b)) (n))))) ((((minus_plus) (((plus) (((times) (a)) (((mod) (m)) (n)))) (((times) (a)) (((times) (((div) (m)) (n))) (n))))) (((times) (a)) (((times) (((div) (m)) (n))) (n)))) (((times) (b)) (n))))) (((times) (a)) (((plus) (((mod) (m)) (n))) (((times) (((div) (m)) (n))) (n))))) ((((distributive_times_plus) (a)) (((mod) (m)) (n))) (((times) (((div) (m)) (n))) (n))))) (((plus) (((times) (((div) (m)) (n))) (n))) (((mod) (m)) (n)))) (((commutative_plus) (((mod) (m)) (n))) (((times) (((div) (m)) (n))) (n))))) (((times) (((times) (a)) (((div) (m)) (n)))) (n))) ((((associative_times) (a)) (((div) (m)) (n))) (n)))) (m)) (((div_mod) (m)) (n)))) (((times) (((plus) (((times) (a)) (((div) (m)) (n)))) (b))) (n))) ((((distributive_times_plus_r) (n)) (((times) (a)) (((div) (m)) (n)))) (b)))) (((plus) (b)) (((times) (a)) (((div) (m)) (n))))) (((commutative_plus) (((times) (a)) (((div) (m)) (n)))) (b))))))) ((((gcd_aux) (q)) (n)) (((mod) (m)) (n)))) (H))) (fun H : (((eq) (nat)) (((minus) (((times) (b)) (n))) (((times) (a)) (((mod) (m)) (n))))) ((((gcd_aux) (q)) (n)) (((mod) (m)) (n))) => ((((((eq_ind) (nat)) (((minus) (((times) (b)) (n))) (((times) (a)) (((mod) (m)) (n))))) (fun x_1 : nat => ((Ex) (nat)) (fun a0 : nat => ((Ex) (nat)) (fun b0 : nat => ((Or) ((((eq) (nat)) (((minus) (((times) (a0)) (n))) (((times) (b0)) (m)))) (x_1))) ((((eq) (nat)) (((minus) (((times) (b0)) (m))) (((times) (a0)) (n)))) (x_1)))))) (fun z : Prop => fun f : forall x : nat, (((Ex) (nat)) (fun b0 : nat => ((Or) ((((eq) (nat)) (((minus) (((times) (x)) (n))) (((times) (b0)) (m)))) (((minus) (((times) (b)) (n))) (((times) (a)) (((mod) (m)) (n)))))) ((((eq) (nat)) (((minus) (((times) (b0)) (m))) (((times) (x)) (n)))) (((minus) (((times) (b)) (n))) (((times) (a)) (((mod) (m)) (n))))))) -> z => ((f) (((plus) (b)) (((times) (a)) (((div) (m)) (n))))) (fun z0 : Prop => fun f0 : forall x : nat, (((Or) ((((eq) (nat)) (((minus) (((times) (((plus) (b)) (((times) (a)) (((div) (m)) (n))))) (n))) (((times) (x)) (m)))) (((minus) (((times) (b)) (n))) (((times) (a)) (((mod) (m)) (n)))))) ((((eq) (nat)) (((minus) (((times) (x)) (m))) (((times) (((plus) (b)) (((times) (a)) (((div) (m)) (n))))) (n)))) (((minus) (((times) (b)) (n))) (((times) (a)) (((mod) (m)) (n)))))) -> z0 => ((f0) (a)) (fun z1 : Prop => fun l : ((((eq) (nat)) (((minus) (((times) (((plus) (b)) (((times) (a)) (((div) (m)) (n))))) (n))) (((times) (a)) (m)))) (((minus) (((times) (b)) (n))) (((times) (a)) (((mod) (m)) (n))))) -> z1 => fun r : ((((eq) (nat)) (((minus) (((times) (a)) (m))) (((times) (((plus) (b)) (((times) (a)) (((div) (m)) (n))))) (n)))) (((minus) (((times) (b)) (n))) (((times) (a)) (((mod) (m)) (n))))) -> z1 => (l) (((((((eq_ind_r) (nat)) (((plus) (((times) (b)) (n))) (((times) (((times) (a)) (((div) (m)) (n)))) (n)))) (fun x : nat => (((eq) (nat)) (((minus) (x)) (((times) (a)) (m)))) (((minus) (((times) (b)) (n))) (((times) (a)) (((mod) (m)) (n)))))) (((((((eq_ind_r) (nat)) (((plus) (((times) (((div) (m)) (n))) (n))) (((mod) (m)) (n)))) (fun x : nat => (((eq) (nat)) (((minus) (((plus) (((times) (b)) (n))) (((times) (((times) (a)) (((div) (m)) (n)))) (n)))) (((times) (a)) (x)))) (((minus) (((times) (b)) (n))) (((times) (a)) (((mod) (m)) (n)))))) (((((((eq_ind_r) (nat)) (((plus) (((times) (a)) (((times) (((div) (m)) (n))) (n)))) (((times) (a)) (((mod) (m)) (n))))) (fun x : nat => (((eq) (nat)) (((minus) (((plus) (((times) (b)) (n))) (((times) (((times) (a)) (((div) (m)) (n)))) (n)))) (x))) (((minus) (((times) (b)) (n))) (((times) (a)) (((mod) (m)) (n)))))) (((((((eq_ind_r) (nat)) (((times) (a)) (((times) (((div) (m)) (n))) (n)))) (fun x : nat => (((eq) (nat)) (((minus) (((plus) (((times) (b)) (n))) (x))) (((plus) (((times) (a)) (((times) (((div) (m)) (n))) (n)))) (((times) (a)) (((mod) (m)) (n)))))) (((minus) (((times) (b)) (n))) (((times) (a)) (((mod) (m)) (n)))))) (((((((eq_ind) (nat)) (((minus) (((minus) (((plus) (((times) (b)) (n))) (((times) (a)) (((times) (((div) (m)) (n))) (n))))) (((times) (a)) (((times) (((div) (m)) (n))) (n))))) (((times) (a)) (((mod) (m)) (n))))) (fun x_1 : nat => (((eq) (nat)) (x_1)) (((minus) (((times) (b)) (n))) (((times) (a)) (((mod) (m)) (n)))))) (((((((eq_ind) (nat)) (((plus) (((times) (a)) (((times) (((div) (m)) (n))) (n)))) (((times) (b)) (n)))) (fun x_1 : nat => (((eq) (nat)) (((minus) (((minus) (x_1)) (((times) (a)) (((times) (((div) (m)) (n))) (n))))) (((times) (a)) (((mod) (m)) (n))))) (((minus) (((times) (b)) (n))) (((times) (a)) (((mod) (m)) (n)))))) (((((((eq_ind) (nat)) (((plus) (((minus) (((times) (a)) (((times) (((div) (m)) (n))) (n)))) (((times) (a)) (((times) (((div) (m)) (n))) (n))))) (((times) (b)) (n)))) (fun x_1 : nat => (((eq) (nat)) (((minus) (x_1)) (((times) (a)) (((mod) (m)) (n))))) (((minus) (((times) (b)) (n))) (((times) (a)) (((mod) (m)) (n)))))) (((((((rewrite_r) (nat)) (((times) (n)) (((div) (m)) (n)))) (fun Joker_ : nat => (((eq) (nat)) (((minus) (((plus) (((minus) (((times) (a)) (Joker_))) (((times) (a)) (((times) (((div) (m)) (n))) (n))))) (((times) (b)) (n)))) (((times) (a)) (((mod) (m)) (n))))) (((minus) (((times) (b)) (n))) (((times) (a)) (((mod) (m)) (n)))))) (((((((rewrite_r) (nat)) (((times) (n)) (((times) (a)) (((div) (m)) (n))))) (fun Joker_ : nat => (((eq) (nat)) (((minus) (((plus) (((minus) (Joker_)) (((times) (a)) (((times) (((div) (m)) (n))) (n))))) (((times) (b)) (n)))) (((times) (a)) (((mod) (m)) (n))))) (((minus) (((times) (b)) (n))) (((times) (a)) (((mod) (m)) (n)))))) (((((((rewrite_r) (nat)) (((times) (n)) (((div) (m)) (n)))) (fun Joker_ : nat => (((eq) (nat)) (((minus) (((plus) (((minus) (((times) (n)) (((times) (a)) (((div) (m)) (n))))) (((times) (a)) (Joker_)))) (((times) (b)) (n)))) (((times) (a)) (((mod) (m)) (n))))) (((minus) (((times) (b)) (n))) (((times) (a)) (((mod) (m)) (n)))))) (((((((rewrite_r) (nat)) (((times) (n)) (((times) (a)) (((div) (m)) (n))))) (fun Joker_ : nat => (((eq) (nat)) (((minus) (((plus) (((minus) (((times) (n)) (((times) (a)) (((div) (m)) (n))))) (Joker_))) (((times) (b)) (n)))) (((times) (a)) (((mod) (m)) (n))))) (((minus) (((times) (b)) (n))) (((times) (a)) (((mod) (m)) (n)))))) (((((((rewrite_l) (nat)) (O)) (fun Joker_ : nat => (((eq) (nat)) (((minus) (((plus) (Joker_)) (((times) (b)) (n)))) (((times) (a)) (((mod) (m)) (n))))) (((minus) (((times) (b)) (n))) (((times) (a)) (((mod) (m)) (n)))))) (((((((rewrite_r) (nat)) (((times) (n)) (b))) (fun Joker_ : nat => (((eq) (nat)) (((minus) (((plus) (O)) (Joker_))) (((times) (a)) (((mod) (m)) (n))))) (((minus) (((times) (b)) (n))) (((times) (a)) (((mod) (m)) (n)))))) (((((((rewrite_l) (nat)) (((times) (n)) (b))) (fun Joker_ : nat => (((eq) (nat)) (((minus) (Joker_)) (((times) (a)) (((mod) (m)) (n))))) (((minus) (((times) (b)) (n))) (((times) (a)) (((mod) (m)) (n)))))) (((((((rewrite_r) (nat)) ((((gcd_aux) (q)) (n)) (((mod) (m)) (n)))) (fun Joker_ : nat => (((eq) (nat)) (Joker_)) (((minus) (((times) (b)) (n))) (((times) (a)) (((mod) (m)) (n)))))) (((((((rewrite_r) (nat)) (((times) (n)) (b))) (fun Joker_ : nat => (((eq) (nat)) ((((gcd_aux) (q)) (n)) (((mod) (m)) (n)))) (((minus) (Joker_)) (((times) (a)) (((mod) (m)) (n)))))) (((((((rewrite_r) (nat)) ((((gcd_aux) (q)) (n)) (((mod) (m)) (n)))) (fun Joker_ : nat => (((eq) (nat)) ((((gcd_aux) (q)) (n)) (((mod) (m)) (n)))) (Joker_))) (((refl) (nat)) ((((gcd_aux) (q)) (n)) (((mod) (m)) (n))))) (((minus) (((times) (n)) (b))) (((times) (a)) (((mod) (m)) (n))))) (((((((((((((((let_clause_15441) (p)) (q)) (Hind)) (m)) (n)) (posn)) (lenm)) (lenS)) (ndivnm)) (a)) (Jokerclearme)) (b)) (Jokerclearme0)) (H)))) (((times) (b)) (n))) (((commutative_times) (b)) (n)))) (((minus) (((times) (n)) (b))) (((times) (a)) (((mod) (m)) (n))))) (((((((((((((((let_clause_15441) (p)) (q)) (Hind)) (m)) (n)) (posn)) (lenm)) (lenS)) (ndivnm)) (a)) (Jokerclearme)) (b)) (Jokerclearme0)) (H)))) (((plus) (O)) (((times) (n)) (b)))) ((plus_O_n) (((times) (n)) (b))))) (((times) (b)) (n))) (((commutative_times) (b)) (n)))) (((minus) (((times) (n)) (((times) (a)) (((div) (m)) (n))))) (((times) (n)) (((times) (a)) (((div) (m)) (n)))))) ((minus_n_n) (((times) (n)) (((times) (a)) (((div) (m)) (n))))))) (((times) (a)) (((times) (n)) (((div) (m)) (n))))) ((((times_times) (a)) (n)) (((div) (m)) (n))))) (((times) (((div) (m)) (n))) (n))) (((commutative_times) (((div) (m)) (n))) (n)))) (((times) (a)) (((times) (n)) (((div) (m)) (n))))) ((((times_times) (a)) (n)) (((div) (m)) (n))))) (((times) (((div) (m)) (n))) (n))) (((commutative_times) (((div) (m)) (n))) (n)))) (((minus) (((plus) (((times) (a)) (((times) (((div) (m)) (n))) (n)))) (((times) (b)) (n)))) (((times) (a)) (((times) (((div) (m)) (n))) (n))))) (((((plus_minus) (((times) (a)) (((times) (((div) (m)) (n))) (n)))) (((times) (a)) (((times) (((div) (m)) (n))) (n)))) (((times) (b)) (n))) ((le_n) (((times) (a)) (((times) (((div) (m)) (n))) (n))))))) (((plus) (((times) (b)) (n))) (((times) (a)) (((times) (((div) (m)) (n))) (n))))) (((commutative_plus) (((times) (a)) (((times) (((div) (m)) (n))) (n)))) (((times) (b)) (n))))) (((minus) (((plus) (((times) (b)) (n))) (((times) (a)) (((times) (((div) (m)) (n))) (n))))) (((plus) (((times) (a)) (((times) (((div) (m)) (n))) (n)))) (((times) (a)) (((mod) (m)) (n)))))) ((((minus_plus) (((plus) (((times) (b)) (n))) (((times) (a)) (((times) (((div) (m)) (n))) (n))))) (((times) (a)) (((times) (((div) (m)) (n))) (n)))) (((times) (a)) (((mod) (m)) (n)))))) (((times) (((times) (a)) (((div) (m)) (n)))) (n))) ((((associative_times) (a)) (((div) (m)) (n))) (n)))) (((times) (a)) (((plus) (((times) (((div) (m)) (n))) (n))) (((mod) (m)) (n))))) ((((distributive_times_plus) (a)) (((times) (((div) (m)) (n))) (n))) (((mod) (m)) (n))))) (m)) (((div_mod) (m)) (n)))) (((times) (((plus) (b)) (((times) (a)) (((div) (m)) (n))))) (n))) ((((distributive_times_plus_r) (n)) (b)) (((times) (a)) (((div) (m)) (n))))))))) ((((gcd_aux) (q)) (n)) (((mod) (m)) (n)))) (H))) (Jokerclearme0))) (Jokerclearme))) ((((((Hind) (n)) (((mod) (m)) (n))) (((((((match_Or_prop) (((lt) (O)) (((mod) (m)) (n)))) ((((eq) (nat)) (O)) (((mod) (m)) (n)))) (((lt) (O)) (((mod) (m)) (n)))) (fun auto : ((lt) (O)) (((mod) (m)) (n)) => auto)) (fun modO : (((eq) (nat)) (O)) (((mod) (m)) (n)) => ((falsity) (((lt) (O)) (((mod) (m)) (n)))) ((((absurd) (((divides) (n)) (m))) (((((mod_O_to_divides) (n)) (m)) (posn)) (((((((rewrite_l) (nat)) (O)) (fun Joker_ : nat => (((eq) (nat)) (Joker_)) (O))) (((refl) (nat)) (O))) (((mod) (m)) (n))) (modO)))) (ndivnm)))) ((((le_to_or_lt_eq) (O)) (((mod) (m)) (n))) ((le_O_n) (((mod) (m)) (n)))))) ((((lt_to_le) (((mod) (m)) (n))) (n)) ((((lt_mod_m_m) (m)) (n)) (posn)))) ((((le_S_S_to_le) (((mod) (m)) (n))) (q)) ((((((transitive_le) ((S) (((mod) (m)) (n)))) (n)) ((S) (q))) ((((lt_mod_m_m) (m)) (n)) (posn))) (lenS)))))) ((((gcd_aux) ((S) (q))) (m)) (n))) ((((((not_divides_to_gcd_aux) (q)) (m)) (n)) (posn)) (ndivnm)))) (((decidable_divides) (n)) (m)))) (p).
Definition let_clause_1549 : forall m : nat, forall n : nat, (((lt) (O)) (n)) -> ((((eq) (nat)) (O)) (m)) -> forall x1106 : nat, (((eq) (nat)) (x1106)) (((minus) (x1106)) (m)) := fun m : nat => fun n : nat => fun posn : ((lt) (O)) (n) => fun eqm0 : (((eq) (nat)) (O)) (m) => fun x1106 : nat => ((((((rewrite_l) (nat)) (O)) (fun Joker_ : nat => (((eq) (nat)) (x1106)) (((minus) (x1106)) (Joker_)))) ((minus_n_O) (x1106))) (m)) (eqm0).
Definition let_clause_15491 : forall m : nat, forall n : nat, ((((eq) (nat)) (O)) (n)) -> forall x1106 : nat, (((eq) (nat)) (x1106)) (((minus) (x1106)) (n)) := fun m : nat => fun n : nat => fun eqn0 : (((eq) (nat)) (O)) (n) => fun x1106 : nat => ((((((rewrite_l) (nat)) (O)) (fun Joker_ : nat => (((eq) (nat)) (x1106)) (((minus) (x1106)) (Joker_)))) ((minus_n_O) (x1106))) (n)) (eqn0).
Definition let_clause_1551 : forall m : nat, forall n : nat, ((((eq) (nat)) (O)) (n)) -> forall x347 : nat, (((eq) (nat)) (n)) (((times) (x347)) (n)) := fun m : nat => fun n : nat => fun eqn0 : (((eq) (nat)) (O)) (n) => fun x347 : nat => ((((((rewrite_l) (nat)) (O)) (fun Joker_ : nat => (((eq) (nat)) (n)) (((times) (x347)) (Joker_)))) (((((((rewrite_l) (nat)) (O)) (fun Joker_ : nat => (((eq) (nat)) (Joker_)) (((times) (x347)) (O)))) ((times_n_O) (x347))) (n)) (eqn0))) (n)) (eqn0).
Definition eq_minus_gcd : forall m : nat, forall n : nat, ((Ex) (nat)) (fun a : nat => ((Ex) (nat)) (fun b : nat => ((Or) ((((eq) (nat)) (((minus) (((times) (a)) (n))) (((times) (b)) (m)))) (((gcd) (n)) (m)))) ((((eq) (nat)) (((minus) (((times) (b)) (m))) (((times) (a)) (n)))) (((gcd) (n)) (m))))) := fun m : nat => fun n : nat => ((((((match_Or_prop) (((lt) (O)) (n))) ((((eq) (nat)) (O)) (n))) (((Ex) (nat)) (fun a : nat => ((Ex) (nat)) (fun b : nat => ((Or) ((((eq) (nat)) (((minus) (((times) (a)) (n))) (((times) (b)) (m)))) (((gcd) (n)) (m)))) ((((eq) (nat)) (((minus) (((times) (b)) (m))) (((times) (a)) (n)))) (((gcd) (n)) (m))))))) (fun posn : ((lt) (O)) (n) => ((((((match_Or_prop) (((lt) (O)) (m))) ((((eq) (nat)) (O)) (m))) (((Ex) (nat)) (fun a : nat => ((Ex) (nat)) (fun b : nat => ((Or) ((((eq) (nat)) (((minus) (((times) (a)) (n))) (((times) (b)) (m)))) (((gcd) (n)) (m)))) ((((eq) (nat)) (((minus) (((times) (b)) (m))) (((times) (a)) (n)))) (((gcd) (n)) (m))))))) (fun posm : ((lt) (O)) (m) => (((((leb_elim) (n)) (m)) (fun Joker_ : bool => ((Ex) (nat)) (fun a : nat => ((Ex) (nat)) (fun b : nat => ((Or) ((((eq) (nat)) (((minus) (((times) (a)) (n))) (((times) (b)) (m)))) (((((match_bool_type) (nat)) ((((gcd_aux) (n)) (m)) (n))) ((((gcd_aux) (m)) (n)) (m))) (Joker_)))) ((((eq) (nat)) (((minus) (((times) (b)) (m))) (((times) (a)) (n)))) (((((match_bool_type) (nat)) ((((gcd_aux) (n)) (m)) (n))) ((((gcd_aux) (m)) (n)) (m))) (Joker_))))))) ((((((sym_eq_match_bool_type_true) (nat)) ((((gcd_aux) (n)) (m)) (n))) ((((gcd_aux) (m)) (n)) (m))) (fun y : nat => (((le) (n)) (m)) -> ((Ex) (nat)) (fun a : nat => ((Ex) (nat)) (fun b : nat => ((Or) ((((eq) (nat)) (((minus) (((times) (a)) (n))) (((times) (b)) (m)))) (((((match_bool_type) (nat)) ((((gcd_aux) (n)) (m)) (n))) ((((gcd_aux) (m)) (n)) (m))) (true)))) ((((eq) (nat)) (((minus) (((times) (b)) (m))) (((times) (a)) (n)))) (y)))))) ((((((sym_eq_match_bool_type_true) (nat)) ((((gcd_aux) (n)) (m)) (n))) ((((gcd_aux) (m)) (n)) (m))) (fun y : nat => (((le) (n)) (m)) -> ((Ex) (nat)) (fun a : nat => ((Ex) (nat)) (fun b : nat => ((Or) ((((eq) (nat)) (((minus) (((times) (a)) (n))) (((times) (b)) (m)))) (y))) ((((eq) (nat)) (((minus) (((times) (b)) (m))) (((times) (a)) (n)))) ((((gcd_aux) (n)) (m)) (n))))))) (fun lenm : ((le) (n)) (m) => ((((((eq_minus_gcd_aux) (n)) (m)) (n)) (posn)) (lenm)) ((le_n) (n)))))) ((((((sym_eq_match_bool_type_false) (nat)) ((((gcd_aux) (n)) (m)) (n))) ((((gcd_aux) (m)) (n)) (m))) (fun y : nat => ((Not) (((le) (n)) (m))) -> ((Ex) (nat)) (fun a : nat => ((Ex) (nat)) (fun b : nat => ((Or) ((((eq) (nat)) (((minus) (((times) (a)) (n))) (((times) (b)) (m)))) (((((match_bool_type) (nat)) ((((gcd_aux) (n)) (m)) (n))) ((((gcd_aux) (m)) (n)) (m))) (false)))) ((((eq) (nat)) (((minus) (((times) (b)) (m))) (((times) (a)) (n)))) (y)))))) ((((((sym_eq_match_bool_type_false) (nat)) ((((gcd_aux) (n)) (m)) (n))) ((((gcd_aux) (m)) (n)) (m))) (fun y : nat => ((Not) (((le) (n)) (m))) -> ((Ex) (nat)) (fun a : nat => ((Ex) (nat)) (fun b : nat => ((Or) ((((eq) (nat)) (((minus) (((times) (a)) (n))) (((times) (b)) (m)))) (y))) ((((eq) (nat)) (((minus) (((times) (b)) (m))) (((times) (a)) (n)))) ((((gcd_aux) (m)) (n)) (m))))))) (fun nlenm : (Not) (((le) (n)) (m)) => (((((match_ex_prop) (nat)) (fun a : nat => ((Ex) (nat)) (fun b : nat => ((Or) ((((eq) (nat)) (((minus) (((times) (a)) (m))) (((times) (b)) (n)))) ((((gcd_aux) (m)) (n)) (m)))) ((((eq) (nat)) (((minus) (((times) (b)) (n))) (((times) (a)) (m)))) ((((gcd_aux) (m)) (n)) (m)))))) (((Ex) (nat)) (fun a : nat => ((Ex) (nat)) (fun b : nat => ((Or) ((((eq) (nat)) (((minus) (((times) (a)) (n))) (((times) (b)) (m)))) ((((gcd_aux) (m)) (n)) (m)))) ((((eq) (nat)) (((minus) (((times) (b)) (m))) (((times) (a)) (n)))) ((((gcd_aux) (m)) (n)) (m))))))) (fun a : nat => fun Jokerclearme : ((Ex) (nat)) (fun b : nat => ((Or) ((((eq) (nat)) (((minus) (((times) (a)) (m))) (((times) (b)) (n)))) ((((gcd_aux) (m)) (n)) (m)))) ((((eq) (nat)) (((minus) (((times) (b)) (n))) (((times) (a)) (m)))) ((((gcd_aux) (m)) (n)) (m)))) => (((((match_ex_prop) (nat)) (fun b : nat => ((Or) ((((eq) (nat)) (((minus) (((times) (a)) (m))) (((times) (b)) (n)))) ((((gcd_aux) (m)) (n)) (m)))) ((((eq) (nat)) (((minus) (((times) (b)) (n))) (((times) (a)) (m)))) ((((gcd_aux) (m)) (n)) (m))))) (((Ex) (nat)) (fun a0 : nat => ((Ex) (nat)) (fun b : nat => ((Or) ((((eq) (nat)) (((minus) (((times) (a0)) (n))) (((times) (b)) (m)))) ((((gcd_aux) (m)) (n)) (m)))) ((((eq) (nat)) (((minus) (((times) (b)) (m))) (((times) (a0)) (n)))) ((((gcd_aux) (m)) (n)) (m))))))) (fun b : nat => fun Jokerclearme0 : ((Or) ((((eq) (nat)) (((minus) (((times) (a)) (m))) (((times) (b)) (n)))) ((((gcd_aux) (m)) (n)) (m)))) ((((eq) (nat)) (((minus) (((times) (b)) (n))) (((times) (a)) (m)))) ((((gcd_aux) (m)) (n)) (m))) => ((((((match_Or_prop) ((((eq) (nat)) (((minus) (((times) (a)) (m))) (((times) (b)) (n)))) ((((gcd_aux) (m)) (n)) (m)))) ((((eq) (nat)) (((minus) (((times) (b)) (n))) (((times) (a)) (m)))) ((((gcd_aux) (m)) (n)) (m)))) (((Ex) (nat)) (fun a0 : nat => ((Ex) (nat)) (fun b0 : nat => ((Or) ((((eq) (nat)) (((minus) (((times) (a0)) (n))) (((times) (b0)) (m)))) ((((gcd_aux) (m)) (n)) (m)))) ((((eq) (nat)) (((minus) (((times) (b0)) (m))) (((times) (a0)) (n)))) ((((gcd_aux) (m)) (n)) (m))))))) (fun H : (((eq) (nat)) (((minus) (((times) (a)) (m))) (((times) (b)) (n)))) ((((gcd_aux) (m)) (n)) (m)) => fun z : Prop => fun f : forall x : nat, (((Ex) (nat)) (fun b0 : nat => ((Or) ((((eq) (nat)) (((minus) (((times) (x)) (n))) (((times) (b0)) (m)))) ((((gcd_aux) (m)) (n)) (m)))) ((((eq) (nat)) (((minus) (((times) (b0)) (m))) (((times) (x)) (n)))) ((((gcd_aux) (m)) (n)) (m))))) -> z => ((f) (b)) (fun z0 : Prop => fun f2 : forall x : nat, (((Or) ((((eq) (nat)) (((minus) (((times) (b)) (n))) (((times) (x)) (m)))) ((((gcd_aux) (m)) (n)) (m)))) ((((eq) (nat)) (((minus) (((times) (x)) (m))) (((times) (b)) (n)))) ((((gcd_aux) (m)) (n)) (m)))) -> z0 => ((f2) (a)) (fun z1 : Prop => fun l : ((((eq) (nat)) (((minus) (((times) (b)) (n))) (((times) (a)) (m)))) ((((gcd_aux) (m)) (n)) (m))) -> z1 => fun r : ((((eq) (nat)) (((minus) (((times) (a)) (m))) (((times) (b)) (n)))) ((((gcd_aux) (m)) (n)) (m))) -> z1 => (r) (((((((rewrite_r) (nat)) (((times) (m)) (a))) (fun Joker_ : nat => (((eq) (nat)) (((minus) (Joker_)) (((times) (b)) (n)))) ((((gcd_aux) (m)) (n)) (m)))) (((((((rewrite_r) (nat)) (((times) (n)) (b))) (fun Joker_ : nat => (((eq) (nat)) (((minus) (((times) (m)) (a))) (Joker_))) ((((gcd_aux) (m)) (n)) (m)))) (((((((rewrite_r) (nat)) ((((gcd_aux) (m)) (n)) (m))) (fun Joker_ : nat => (((eq) (nat)) (Joker_)) ((((gcd_aux) (m)) (n)) (m)))) (((refl) (nat)) ((((gcd_aux) (m)) (n)) (m)))) (((minus) (((times) (m)) (a))) (((times) (n)) (b)))) (((((((rewrite_l) (nat)) (((times) (b)) (n))) (fun Joker_ : nat => (((eq) (nat)) (((minus) (((times) (m)) (a))) (Joker_))) ((((gcd_aux) (m)) (n)) (m)))) (((((((rewrite_l) (nat)) (((times) (a)) (m))) (fun Joker_ : nat => (((eq) (nat)) (((minus) (Joker_)) (((times) (b)) (n)))) ((((gcd_aux) (m)) (n)) (m)))) (H)) (((times) (m)) (a))) (((commutative_times) (a)) (m)))) (((times) (n)) (b))) (((commutative_times) (b)) (n))))) (((times) (b)) (n))) (((commutative_times) (b)) (n)))) (((times) (a)) (m))) (((commutative_times) (a)) (m))))))) (fun H : (((eq) (nat)) (((minus) (((times) (b)) (n))) (((times) (a)) (m)))) ((((gcd_aux) (m)) (n)) (m)) => fun z : Prop => fun f : forall y : nat, (((Ex) (nat)) (fun b0 : nat => ((Or) ((((eq) (nat)) (((minus) (((times) (y)) (n))) (((times) (b0)) (m)))) ((((gcd_aux) (m)) (n)) (m)))) ((((eq) (nat)) (((minus) (((times) (b0)) (m))) (((times) (y)) (n)))) ((((gcd_aux) (m)) (n)) (m))))) -> z => ((f) (b)) (fun z0 : Prop => fun f2 : forall x : nat, (((Or) ((((eq) (nat)) (((minus) (((times) (b)) (n))) (((times) (x)) (m)))) ((((gcd_aux) (m)) (n)) (m)))) ((((eq) (nat)) (((minus) (((times) (x)) (m))) (((times) (b)) (n)))) ((((gcd_aux) (m)) (n)) (m)))) -> z0 => ((f2) (a)) (fun z1 : Prop => fun l : ((((eq) (nat)) (((minus) (((times) (b)) (n))) (((times) (a)) (m)))) ((((gcd_aux) (m)) (n)) (m))) -> z1 => fun r : ((((eq) (nat)) (((minus) (((times) (a)) (m))) (((times) (b)) (n)))) ((((gcd_aux) (m)) (n)) (m))) -> z1 => (l) (((((((rewrite_r) (nat)) (((times) (n)) (b))) (fun Joker_ : nat => (((eq) (nat)) (((minus) (Joker_)) (((times) (a)) (m)))) ((((gcd_aux) (m)) (n)) (m)))) (((((((rewrite_r) (nat)) (((times) (m)) (a))) (fun Joker_ : nat => (((eq) (nat)) (((minus) (((times) (n)) (b))) (Joker_))) ((((gcd_aux) (m)) (n)) (m)))) (((((((rewrite_r) (nat)) ((((gcd_aux) (m)) (n)) (m))) (fun Joker_ : nat => (((eq) (nat)) (Joker_)) ((((gcd_aux) (m)) (n)) (m)))) (((refl) (nat)) ((((gcd_aux) (m)) (n)) (m)))) (((minus) (((times) (n)) (b))) (((times) (m)) (a)))) (((((((rewrite_l) (nat)) (((times) (a)) (m))) (fun Joker_ : nat => (((eq) (nat)) (((minus) (((times) (n)) (b))) (Joker_))) ((((gcd_aux) (m)) (n)) (m)))) (((((((rewrite_l) (nat)) (((times) (b)) (n))) (fun Joker_ : nat => (((eq) (nat)) (((minus) (Joker_)) (((times) (a)) (m)))) ((((gcd_aux) (m)) (n)) (m)))) (H)) (((times) (n)) (b))) (((commutative_times) (b)) (n)))) (((times) (m)) (a))) (((commutative_times) (a)) (m))))) (((times) (a)) (m))) (((commutative_times) (a)) (m)))) (((times) (b)) (n))) (((commutative_times) (b)) (n))))))) (Jokerclearme0))) (Jokerclearme))) (((((((eq_minus_gcd_aux) (m)) (n)) (m)) (posm)) ((((((transitive_le) (m)) ((S) (m))) (n)) ((le_n_Sn) (m))) ((((not_le_to_lt) (n)) (m)) (nlenm)))) ((le_n) (m)))))))) (fun eqm0 : (((eq) (nat)) (O)) (m) => ((((((eq_ind_r) (nat)) (m)) (fun x : nat => ((Ex) (nat)) (fun a : nat => ((Ex) (nat)) (fun b : nat => ((Or) ((((eq) (nat)) (((minus) (((times) (a)) (n))) (((times) (b)) (m)))) (((gcd) (n)) (m)))) ((((eq) (nat)) (((minus) (((times) (b)) (m))) (((times) (a)) (n)))) (((gcd) (n)) (m))))))) (fun z : Prop => fun f : forall x : nat, (((Ex) (nat)) (fun b : nat => ((Or) ((((eq) (nat)) (((minus) (((times) (x)) (n))) (((times) (b)) (m)))) (((gcd) (n)) (m)))) ((((eq) (nat)) (((minus) (((times) (b)) (m))) (((times) (x)) (n)))) (((gcd) (n)) (m))))) -> z => ((f) ((S) (O))) (fun z0 : Prop => fun f2 : forall y : nat, (((Or) ((((eq) (nat)) (((minus) (((times) ((S) (O))) (n))) (((times) (y)) (m)))) (((gcd) (n)) (m)))) ((((eq) (nat)) (((minus) (((times) (y)) (m))) (((times) ((S) (O))) (n)))) (((gcd) (n)) (m)))) -> z0 => ((f2) (O)) (fun z1 : Prop => fun l : ((((eq) (nat)) (((minus) (((times) ((S) (O))) (n))) (((times) (O)) (m)))) (((gcd) (n)) (m))) -> z1 => fun r : ((((eq) (nat)) (((minus) (((times) (O)) (m))) (((times) ((S) (O))) (n)))) (((gcd) (n)) (m))) -> z1 => (l) (((((eq_coerc) ((((eq) (nat)) (n)) (((minus) (n)) (O)))) ((((eq) (nat)) (((minus) (((times) ((S) (O))) (n))) (((times) (O)) (m)))) (((gcd) (n)) (m)))) ((minus_n_O) (n))) (((((((rewrite_r) (nat)) (m)) (fun Joker_ : nat => (((eq) Prop) ((((eq) (nat)) (n)) (((minus) (n)) (Joker_)))) ((((eq) (nat)) (((minus) (((times) ((S) (O))) (n))) (((times) (O)) (m)))) (((gcd) (n)) (m))))) (((((((rewrite_l) (nat)) (n)) (fun Joker_ : nat => (((eq) Prop) ((((eq) (nat)) (n)) (Joker_))) ((((eq) (nat)) (((minus) (((times) ((S) (O))) (n))) (((times) (O)) (m)))) (((gcd) (n)) (m))))) (((((((rewrite_r) (nat)) (m)) (fun Joker_ : nat => (((eq) Prop) ((((eq) (nat)) (n)) (n))) ((((eq) (nat)) (((minus) (((times) ((S) (Joker_))) (n))) (((times) (O)) (m)))) (((gcd) (n)) (m))))) (((((((rewrite_r) (nat)) (((times) (n)) ((S) (m)))) (fun Joker_ : nat => (((eq) Prop) ((((eq) (nat)) (n)) (n))) ((((eq) (nat)) (((minus) (Joker_)) (((times) (O)) (m)))) (((gcd) (n)) (m))))) (((((((rewrite_l) (nat)) (((plus) (n)) (((times) (n)) (m)))) (fun Joker_ : nat => (((eq) Prop) ((((eq) (nat)) (n)) (n))) ((((eq) (nat)) (((minus) (Joker_)) (((times) (O)) (m)))) (((gcd) (n)) (m))))) (((((((rewrite_r) (nat)) (((times) (m)) (n))) (fun Joker_ : nat => (((eq) Prop) ((((eq) (nat)) (n)) (n))) ((((eq) (nat)) (((minus) (((plus) (n)) (Joker_))) (((times) (O)) (m)))) (((gcd) (n)) (m))))) (((((((rewrite_l) (nat)) (m)) (fun Joker_ : nat => (((eq) Prop) ((((eq) (nat)) (n)) (n))) ((((eq) (nat)) (((minus) (((plus) (n)) (Joker_))) (((times) (O)) (m)))) (((gcd) (n)) (m))))) (((((((rewrite_r) (nat)) (((plus) (m)) (n))) (fun Joker_ : nat => (((eq) Prop) ((((eq) (nat)) (n)) (n))) ((((eq) (nat)) (((minus) (Joker_)) (((times) (O)) (m)))) (((gcd) (n)) (m))))) (((((((rewrite_l) (nat)) (n)) (fun Joker_ : nat => (((eq) Prop) ((((eq) (nat)) (n)) (n))) ((((eq) (nat)) (((minus) (Joker_)) (((times) (O)) (m)))) (((gcd) (n)) (m))))) (((((((rewrite_r) (nat)) (m)) (fun Joker_ : nat => (((eq) Prop) ((((eq) (nat)) (n)) (n))) ((((eq) (nat)) (((minus) (n)) (((times) (Joker_)) (m)))) (((gcd) (n)) (m))))) (((((((rewrite_l) (nat)) (m)) (fun Joker_ : nat => (((eq) Prop) ((((eq) (nat)) (n)) (n))) ((((eq) (nat)) (((minus) (n)) (Joker_))) (((gcd) (n)) (m))))) (((((((rewrite_l) (nat)) (n)) (fun Joker_ : nat => (((eq) Prop) ((((eq) (nat)) (n)) (n))) ((((eq) (nat)) (Joker_)) (((gcd) (n)) (m))))) (((((((rewrite_r) (nat)) (((gcd) (m)) (n))) (fun Joker_ : nat => (((eq) Prop) ((((eq) (nat)) (n)) (n))) ((((eq) (nat)) (n)) (Joker_)))) (((((((rewrite_r) (nat)) (n)) (fun Joker_ : nat => (((eq) Prop) ((((eq) (nat)) (n)) (n))) ((((eq) (nat)) (n)) (Joker_)))) (((refl) Prop) ((((eq) (nat)) (n)) (n)))) (((gcd) (m)) (n))) (((((((rewrite_l) (nat)) (O)) (fun Joker_ : nat => (((eq) (nat)) (((gcd) (Joker_)) (n))) (n))) ((gcd_O_l) (n))) (m)) (eqm0)))) (((gcd) (n)) (m))) (((commutative_gcd) (n)) (m)))) (((minus) (n)) (m))) ((((((let_clause_1549) (m)) (n)) (posn)) (eqm0)) (n)))) (((times) (m)) (m))) (((((((rewrite_l) (nat)) (O)) (fun Joker_ : nat => (((eq) (nat)) (m)) (((times) (m)) (Joker_)))) (((((((rewrite_l) (nat)) (O)) (fun Joker_ : nat => (((eq) (nat)) (Joker_)) (((times) (m)) (O)))) ((times_n_O) (m))) (m)) (eqm0))) (m)) (eqm0)))) (O)) (eqm0))) (((plus) (m)) (n))) (((((((rewrite_l) (nat)) (O)) (fun Joker_ : nat => (((eq) (nat)) (n)) (((plus) (Joker_)) (n)))) ((plus_O_n) (n))) (m)) (eqm0)))) (((plus) (n)) (m))) (((commutative_plus) (n)) (m)))) (((times) (m)) (n))) (((((((rewrite_l) (nat)) (O)) (fun Joker_ : nat => (((eq) (nat)) (m)) (((times) (Joker_)) (n)))) (((((((rewrite_l) (nat)) (O)) (fun Joker_ : nat => (((eq) (nat)) (Joker_)) (((times) (O)) (n)))) ((times_O_n) (n))) (m)) (eqm0))) (m)) (eqm0)))) (((times) (n)) (m))) (((commutative_times) (n)) (m)))) (((times) (n)) ((S) (m)))) (((times_n_Sm) (n)) (m)))) (((times) ((S) (m))) (n))) (((commutative_times) ((S) (m))) (n)))) (O)) (eqm0))) (((minus) (n)) (m))) ((((((let_clause_1549) (m)) (n)) (posn)) (eqm0)) (n)))) (O)) (eqm0))))))) (O)) (eqm0))) ((((le_to_or_lt_eq) (O)) (m)) ((le_O_n) (m))))) (fun eqn0 : (((eq) (nat)) (O)) (n) => ((((((eq_ind_r) (nat)) (n)) (fun x : nat => ((Ex) (nat)) (fun a : nat => ((Ex) (nat)) (fun b : nat => ((Or) ((((eq) (nat)) (((minus) (((times) (a)) (n))) (((times) (b)) (m)))) (((gcd) (n)) (m)))) ((((eq) (nat)) (((minus) (((times) (b)) (m))) (((times) (a)) (n)))) (((gcd) (n)) (m))))))) (fun z : Prop => fun f : forall x : nat, (((Ex) (nat)) (fun b : nat => ((Or) ((((eq) (nat)) (((minus) (((times) (x)) (n))) (((times) (b)) (m)))) (((gcd) (n)) (m)))) ((((eq) (nat)) (((minus) (((times) (b)) (m))) (((times) (x)) (n)))) (((gcd) (n)) (m))))) -> z => ((f) (O)) (fun z0 : Prop => fun f0 : forall x : nat, (((Or) ((((eq) (nat)) (((minus) (((times) (O)) (n))) (((times) (x)) (m)))) (((gcd) (n)) (m)))) ((((eq) (nat)) (((minus) (((times) (x)) (m))) (((times) (O)) (n)))) (((gcd) (n)) (m)))) -> z0 => ((f0) ((S) (O))) (fun z1 : Prop => fun l : ((((eq) (nat)) (((minus) (((times) (O)) (n))) (((times) ((S) (O))) (m)))) (((gcd) (n)) (m))) -> z1 => fun r : ((((eq) (nat)) (((minus) (((times) ((S) (O))) (m))) (((times) (O)) (n)))) (((gcd) (n)) (m))) -> z1 => (r) (((((eq_coerc) ((((eq) (nat)) (m)) (((minus) (m)) (O)))) ((((eq) (nat)) (((minus) (((times) ((S) (O))) (m))) (((times) (O)) (n)))) (((gcd) (n)) (m)))) ((minus_n_O) (m))) (((((((rewrite_r) (nat)) (m)) (fun Joker_ : nat => (((eq) Prop) ((((eq) (nat)) (m)) (((minus) (m)) (O)))) ((((eq) (nat)) (((minus) (((times) ((S) (O))) (m))) (((times) (O)) (n)))) (Joker_)))) (((((((rewrite_r) (nat)) (n)) (fun Joker_ : nat => (((eq) Prop) ((((eq) (nat)) (m)) (((minus) (m)) (Joker_)))) ((((eq) (nat)) (((minus) (((times) ((S) (O))) (m))) (((times) (O)) (n)))) (m)))) (((((((rewrite_l) (nat)) (m)) (fun Joker_ : nat => (((eq) Prop) ((((eq) (nat)) (m)) (Joker_))) ((((eq) (nat)) (((minus) (((times) ((S) (O))) (m))) (((times) (O)) (n)))) (m)))) (((((((rewrite_r) (nat)) (n)) (fun Joker_ : nat => (((eq) Prop) ((((eq) (nat)) (m)) (m))) ((((eq) (nat)) (((minus) (((times) ((S) (Joker_))) (m))) (((times) (O)) (n)))) (m)))) (((((((rewrite_r) (nat)) (((times) (m)) ((S) (n)))) (fun Joker_ : nat => (((eq) Prop) ((((eq) (nat)) (m)) (m))) ((((eq) (nat)) (((minus) (Joker_)) (((times) (O)) (n)))) (m)))) (((((((rewrite_l) (nat)) (((plus) (m)) (((times) (m)) (n)))) (fun Joker_ : nat => (((eq) Prop) ((((eq) (nat)) (m)) (m))) ((((eq) (nat)) (((minus) (Joker_)) (((times) (O)) (n)))) (m)))) (((((((rewrite_l) (nat)) (n)) (fun Joker_ : nat => (((eq) Prop) ((((eq) (nat)) (m)) (m))) ((((eq) (nat)) (((minus) (((plus) (m)) (Joker_))) (((times) (O)) (n)))) (m)))) (((((((rewrite_l) (nat)) (m)) (fun Joker_ : nat => (((eq) Prop) ((((eq) (nat)) (m)) (m))) ((((eq) (nat)) (((minus) (Joker_)) (((times) (O)) (n)))) (m)))) (((((((rewrite_r) (nat)) (n)) (fun Joker_ : nat => (((eq) Prop) ((((eq) (nat)) (m)) (m))) ((((eq) (nat)) (((minus) (m)) (((times) (Joker_)) (n)))) (m)))) (((((((rewrite_l) (nat)) (n)) (fun Joker_ : nat => (((eq) Prop) ((((eq) (nat)) (m)) (m))) ((((eq) (nat)) (((minus) (m)) (Joker_))) (m)))) (((((((rewrite_l) (nat)) (m)) (fun Joker_ : nat => (((eq) Prop) ((((eq) (nat)) (m)) (m))) ((((eq) (nat)) (Joker_)) (m)))) (((refl) Prop) ((((eq) (nat)) (m)) (m)))) (((minus) (m)) (n))) (((((let_clause_15491) (m)) (n)) (eqn0)) (m)))) (((times) (n)) (n))) (((((let_clause_1551) (m)) (n)) (eqn0)) (n)))) (O)) (eqn0))) (((plus) (m)) (n))) (((((((rewrite_l) (nat)) (O)) (fun Joker_ : nat => (((eq) (nat)) (m)) (((plus) (m)) (Joker_)))) ((plus_n_O) (m))) (n)) (eqn0)))) (((times) (m)) (n))) (((((let_clause_1551) (m)) (n)) (eqn0)) (m)))) (((times) (m)) ((S) (n)))) (((times_n_Sm) (m)) (n)))) (((times) ((S) (n))) (m))) (((commutative_times) ((S) (n))) (m)))) (O)) (eqn0))) (((minus) (m)) (n))) (((((let_clause_15491) (m)) (n)) (eqn0)) (m)))) (O)) (eqn0))) (((gcd) (n)) (m))) (((((((rewrite_l) (nat)) (O)) (fun Joker_ : nat => (((eq) (nat)) (((gcd) (Joker_)) (m))) (m))) ((gcd_O_l) (m))) (n)) (eqn0)))))))) (O)) (eqn0))) ((((le_to_or_lt_eq) (O)) (n)) ((le_O_n) (n))).
Definition let_clause_1545 : forall m : nat, forall n : nat, ((((eq) (nat)) (((gcd) (m)) (n))) (O)) -> (((divides) (O)) (n)) -> forall q1 : nat, ((((eq) (nat)) (n)) (((times) (O)) (q1))) -> (((divides) (O)) (m)) -> forall q2 : nat, ((((eq) (nat)) (m)) (((times) (O)) (q2))) -> (((eq) (nat)) (m)) (O) := fun m : nat => fun n : nat => fun H : (((eq) (nat)) (((gcd) (m)) (n))) (O) => fun Jokerclearme : ((divides) (O)) (n) => fun q1 : nat => fun H1 : (((eq) (nat)) (n)) (((times) (O)) (q1)) => fun Jokerclearme0 : ((divides) (O)) (m) => fun q2 : nat => fun H2 : (((eq) (nat)) (m)) (((times) (O)) (q2)) => ((((((rewrite_r) (nat)) (((times) (q2)) (O))) (fun Joker_ : nat => (((eq) (nat)) (m)) (Joker_))) (((((((rewrite_l) (nat)) (((times) (O)) (q2))) (fun Joker_ : nat => (((eq) (nat)) (m)) (Joker_))) (H2)) (((times) (q2)) (O))) (((commutative_times) (O)) (q2)))) (O)) ((times_n_O) (q2)).
Definition gcd_O_to_eq_O : forall m : nat, forall n : nat, ((((eq) (nat)) (((gcd) (m)) (n))) (O)) -> ((And) ((((eq) (nat)) (m)) (O))) ((((eq) (nat)) (n)) (O)) := fun m : nat => fun n : nat => fun H : (((eq) (nat)) (((gcd) (m)) (n))) (O) => (((((match_And_prop) (((divides) (O)) (n))) (((divides) (O)) (m))) (((And) ((((eq) (nat)) (m)) (O))) ((((eq) (nat)) (n)) (O)))) (fun Jokerclearme : ((divides) (O)) (n) => (((((match_divides_prop) (O)) (n)) ((((divides) (O)) (m)) -> ((And) ((((eq) (nat)) (m)) (O))) ((((eq) (nat)) (n)) (O)))) (fun q1 : nat => fun H1 : (((eq) (nat)) (n)) (((times) (O)) (q1)) => fun Jokerclearme0 : ((divides) (O)) (m) => (((((match_divides_prop) (O)) (m)) (((And) ((((eq) (nat)) (m)) (O))) ((((eq) (nat)) (n)) (O)))) (fun q2 : nat => fun H2 : (((eq) (nat)) (m)) (((times) (O)) (q2)) => fun z : Prop => fun f : ((((eq) (nat)) (m)) (O)) -> ((((eq) (nat)) (n)) (O)) -> z => ((f) (((((((rewrite_l) (nat)) (m)) (fun Joker_ : nat => (((eq) (nat)) (m)) (Joker_))) (((refl) (nat)) (m))) (O)) (((((((rewrite_r) (nat)) (((times) (q2)) (O))) (fun Joker_ : nat => (((eq) (nat)) (m)) (Joker_))) (((((((rewrite_l) (nat)) (((times) (O)) (q2))) (fun Joker_ : nat => (((eq) (nat)) (m)) (Joker_))) (H2)) (((times) (q2)) (O))) (((commutative_times) (O)) (q2)))) (O)) ((times_n_O) (q2))))) (((((((rewrite_r) (nat)) (m)) (fun Joker_ : nat => (((eq) (nat)) (Joker_)) (O))) (((((((rewrite_l) (nat)) (m)) (fun Joker_ : nat => (((eq) (nat)) (m)) (Joker_))) (((refl) (nat)) (m))) (O)) ((((((((((let_clause_1545) (m)) (n)) (H)) (Jokerclearme)) (q1)) (H1)) (Jokerclearme0)) (q2)) (H2)))) (n)) (((((((rewrite_r) (nat)) (((times) (m)) (q1))) (fun Joker_ : nat => (((eq) (nat)) (n)) (Joker_))) (((((((rewrite_r) (nat)) (O)) (fun Joker_ : nat => (((eq) (nat)) (n)) (((times) (Joker_)) (q1)))) (H1)) (m)) ((((((((((let_clause_1545) (m)) (n)) (H)) (Jokerclearme)) (q1)) (H1)) (Jokerclearme0)) (q2)) (H2)))) (m)) (((((((rewrite_r) (nat)) (O)) (fun Joker_ : nat => (((eq) (nat)) (m)) (((times) (Joker_)) (q1)))) (((((((rewrite_r) (nat)) (O)) (fun Joker_ : nat => (((eq) (nat)) (Joker_)) (((times) (O)) (q1)))) ((times_O_n) (q1))) (m)) ((((((((((let_clause_1545) (m)) (n)) (H)) (Jokerclearme)) (q1)) (H1)) (Jokerclearme0)) (q2)) (H2)))) (m)) ((((((((((let_clause_1545) (m)) (n)) (H)) (Jokerclearme)) (q1)) (H1)) (Jokerclearme0)) (q2)) (H2))))))) (Jokerclearme0))) (Jokerclearme))) (((((((eq_ind) (nat)) (((gcd) (m)) (n))) (fun x_1 : nat => ((And) (((divides) (x_1)) (n))) (((divides) (x_1)) (m)))) (((divides_gcd_nm) (m)) (n))) (O)) (H)).
Definition let_clause_1571 : forall m : nat, forall n : nat, (((lt) (O)) (n)) -> ((((eq) (nat)) (((gcd) (m)) (n))) (O)) -> ((((eq) (nat)) (m)) (O)) -> ((((eq) (nat)) (n)) (O)) -> (((eq) (nat)) (m)) (n) := fun m : nat => fun n : nat => fun posn : ((lt) (O)) (n) => fun H : (((eq) (nat)) (((gcd) (m)) (n))) (O) => fun auto : (((eq) (nat)) (m)) (O) => fun auto' : (((eq) (nat)) (n)) (O) => ((((((rewrite_r) (nat)) (O)) (fun Joker_ : nat => (((eq) (nat)) (m)) (Joker_))) (auto)) (n)) (auto').
Definition let_clause_1572 : forall m : nat, forall n : nat, (((lt) (O)) (n)) -> ((((eq) (nat)) (((gcd) (m)) (n))) (O)) -> ((((eq) (nat)) (m)) (O)) -> ((((eq) (nat)) (n)) (O)) -> (((eq) (nat)) (m)) (O) := fun m : nat => fun n : nat => fun posn : ((lt) (O)) (n) => fun H : (((eq) (nat)) (((gcd) (m)) (n))) (O) => fun auto : (((eq) (nat)) (m)) (O) => fun auto' : (((eq) (nat)) (n)) (O) => ((((((rewrite_r) (nat)) (n)) (fun Joker_ : nat => (((eq) (nat)) (Joker_)) (O))) (auto')) (m)) (((((((let_clause_1571) (m)) (n)) (posn)) (H)) (auto)) (auto')).
Definition lt_O_gcd : forall m : nat, forall n : nat, (((lt) (O)) (n)) -> ((lt) (O)) (((gcd) (m)) (n)) := fun m : nat => fun n : nat => fun posn : ((lt) (O)) (n) => ((((nat_case) (((gcd) (m)) (n))) ((lt) (O))) (fun H : (((eq) (nat)) (((gcd) (m)) (n))) (O) => (((((match_And_prop) ((((eq) (nat)) (m)) (O))) ((((eq) (nat)) (n)) (O))) (((lt) (O)) (O))) (fun auto : (((eq) (nat)) (m)) (O) => fun auto' : (((eq) (nat)) (n)) (O) => ((((eq_coerc) (((lt) (O)) (n))) (((lt) (O)) (O))) (posn)) (((((((rewrite_l) (nat)) (m)) (fun Joker_ : nat => (((eq) Prop) (((lt) (Joker_)) (n))) (((lt) (O)) (O)))) (((((((rewrite_l) (nat)) (m)) (fun Joker_ : nat => (((eq) Prop) (((lt) (m)) (Joker_))) (((lt) (O)) (O)))) (((((((rewrite_l) (nat)) (m)) (fun Joker_ : nat => (((eq) Prop) (((lt) (m)) (m))) (((lt) (Joker_)) (O)))) (((((((rewrite_l) (nat)) (m)) (fun Joker_ : nat => (((eq) Prop) (((lt) (m)) (m))) (((lt) (m)) (Joker_)))) (((refl) Prop) (((lt) (m)) (m)))) (O)) (((((((let_clause_1572) (m)) (n)) (posn)) (H)) (auto)) (auto')))) (O)) (((((((let_clause_1572) (m)) (n)) (posn)) (H)) (auto)) (auto')))) (n)) (((((((let_clause_1571) (m)) (n)) (posn)) (H)) (auto)) (auto')))) (O)) (((((((let_clause_1572) (m)) (n)) (posn)) (H)) (auto)) (auto'))))) ((((gcd_O_to_eq_O) (m)) (n)) (H)))) (fun m0 : nat => fun auto : (((eq) (nat)) (((gcd) (m)) (n))) ((S) (m0)) => (lt_O_S) (m0)).
Definition prime_to_gcd_1 : forall n : nat, forall m : nat, ((prime) (n)) -> ((Not) (((divides) (n)) (m))) -> (((eq) (nat)) (((gcd) (n)) (m))) ((S) (O)) := fun n : nat => fun m : nat => fun Jokerclearme : (prime) (n) => (((((match_And_prop) (((lt) ((S) (O))) (n))) (forall m1 : nat, (((divides) (m1)) (n)) -> (((lt) ((S) (O))) (m1)) -> (((eq) (nat)) (m1)) (n))) (((Not) (((divides) (n)) (m))) -> (((eq) (nat)) (((gcd) (n)) (m))) ((S) (O)))) (fun lt1n : ((lt) ((S) (O))) (n) => fun primen : forall m0 : nat, (((divides) (m0)) (n)) -> (((lt) ((S) (O))) (m0)) -> (((eq) (nat)) (m0)) (n) => fun ndivnm : (Not) (((divides) (n)) (m)) => ((((le_to_le_to_eq) (((gcd) (n)) (m))) ((S) (O))) ((((not_lt_to_le) ((S) (O))) (((gcd) (n)) (m))) (((((not_to_not) (((lt) ((S) (O))) (((gcd) (n)) (m)))) ((((eq) (nat)) (((gcd) (n)) (m))) (n))) (((primen) (((gcd) (n)) (m))) (((divides_gcd_l) (n)) (m)))) (((((not_to_not) ((((eq) (nat)) (((gcd) (n)) (m))) (n))) (((divides) (n)) (m))) (fun auto : (((eq) (nat)) (((gcd) (n)) (m))) (n) => ((((eq_coerc) (((divides) (((gcd) (n)) (m))) (m))) (((divides) (n)) (m))) (((divides_gcd_r) (n)) (m))) (((((((rewrite_r) (nat)) (n)) (fun Joker_ : nat => (((eq) Prop) (((divides) (Joker_)) (m))) (((divides) (n)) (m)))) (((refl) Prop) (((divides) (n)) (m)))) (((gcd) (n)) (m))) (auto)))) (ndivnm))))) ((((lt_O_gcd) (n)) (m)) (((((not_eq_to_le_to_lt) (O)) (m)) (((((not_to_not) ((((eq) (nat)) (O)) (m))) (((divides) (n)) (m))) (fun auto : (((eq) (nat)) (O)) (m) => ((((eq_coerc) (((divides) (n)) (O))) (((divides) (n)) (m))) ((divides_n_O) (n))) (((((((rewrite_r) (nat)) (m)) (fun Joker_ : nat => (((eq) Prop) (((divides) (n)) (Joker_))) (((divides) (n)) (m)))) (((refl) Prop) (((divides) (n)) (m)))) (O)) (auto)))) (ndivnm))) ((le_O_n) (m)))))) (Jokerclearme).
Definition divides_times_to_divides : forall p : nat, forall n : nat, forall m : nat, ((prime) (p)) -> (((divides) (p)) (((times) (n)) (m))) -> ((Or) (((divides) (p)) (n))) (((divides) (p)) (m)) := fun p : nat => fun n : nat => fun m : nat => fun primp : (prime) (p) => fun Jokerclearme : ((divides) (p)) (((times) (n)) (m)) => (((((match_divides_prop) (p)) (((times) (n)) (m))) (((Or) (((divides) (p)) (n))) (((divides) (p)) (m)))) (fun c : nat => fun nm : (((eq) (nat)) (((times) (n)) (m))) (((times) (p)) (c)) => ((((((match_Or_prop) (((divides) (p)) (n))) ((Not) (((divides) (p)) (n)))) (((Or) (((divides) (p)) (n))) (((divides) (p)) (m)))) (fun auto : ((divides) (p)) (n) => fun z : Prop => fun l : (((divides) (p)) (n)) -> z => fun r : (((divides) (p)) (m)) -> z => (l) (auto))) (fun ndivpn : (Not) (((divides) (p)) (n)) => fun z : Prop => fun l : (((divides) (p)) (n)) -> z => fun r : (((divides) (p)) (m)) -> z => (r) ((((((match_ex_prop) (nat)) (fun a : nat => ((Ex) (nat)) (fun b : nat => ((Or) ((((eq) (nat)) (((minus) (((times) (a)) (n))) (((times) (b)) (p)))) ((S) (O)))) ((((eq) (nat)) (((minus) (((times) (b)) (p))) (((times) (a)) (n)))) ((S) (O)))))) (((divides) (p)) (m))) (fun a : nat => fun Jokerclearme0 : ((Ex) (nat)) (fun b : nat => ((Or) ((((eq) (nat)) (((minus) (((times) (a)) (n))) (((times) (b)) (p)))) ((S) (O)))) ((((eq) (nat)) (((minus) (((times) (b)) (p))) (((times) (a)) (n)))) ((S) (O)))) => (((((match_ex_prop) (nat)) (fun b : nat => ((Or) ((((eq) (nat)) (((minus) (((times) (a)) (n))) (((times) (b)) (p)))) ((S) (O)))) ((((eq) (nat)) (((minus) (((times) (b)) (p))) (((times) (a)) (n)))) ((S) (O))))) (((divides) (p)) (m))) (fun b : nat => fun Jokerclearme1 : ((Or) ((((eq) (nat)) (((minus) (((times) (a)) (n))) (((times) (b)) (p)))) ((S) (O)))) ((((eq) (nat)) (((minus) (((times) (b)) (p))) (((times) (a)) (n)))) ((S) (O))) => ((((((match_Or_prop) ((((eq) (nat)) (((minus) (((times) (a)) (n))) (((times) (b)) (p)))) ((S) (O)))) ((((eq) (nat)) (((minus) (((times) (b)) (p))) (((times) (a)) (n)))) ((S) (O)))) (((divides) (p)) (m))) (fun H : (((eq) (nat)) (((minus) (((times) (a)) (n))) (((times) (b)) (p)))) ((S) (O)) => ((((quotient) (p)) (m)) (((minus) (((times) (a)) (c))) (((times) (b)) (m)))) (((((((eq_ind_r) (nat)) (((minus) (((times) (p)) (((times) (a)) (c)))) (((times) (p)) (((times) (b)) (m))))) (fun x : nat => (((eq) (nat)) (m)) (x))) (((((((eq_ind) (nat)) (((times) (((times) (p)) (a))) (c))) (fun x_1 : nat => (((eq) (nat)) (m)) (((minus) (x_1)) (((times) (p)) (((times) (b)) (m)))))) (((((((eq_ind_r) (nat)) (((times) (a)) (p))) (fun x : nat => (((eq) (nat)) (m)) (((minus) (((times) (x)) (c))) (((times) (p)) (((times) (b)) (m)))))) (((((((eq_ind_r) (nat)) (((times) (a)) (((times) (p)) (c)))) (fun x : nat => (((eq) (nat)) (m)) (((minus) (x)) (((times) (p)) (((times) (b)) (m)))))) (((((((eq_ind) (nat)) (((times) (n)) (m))) (fun x_1 : nat => (((eq) (nat)) (m)) (((minus) (((times) (a)) (x_1))) (((times) (p)) (((times) (b)) (m)))))) (((((((eq_ind) (nat)) (((times) (((times) (a)) (n))) (m))) (fun x_1 : nat => (((eq) (nat)) (m)) (((minus) (x_1)) (((times) (p)) (((times) (b)) (m)))))) (((((((eq_ind) (nat)) (((times) (((times) (p)) (b))) (m))) (fun x_1 : nat => (((eq) (nat)) (m)) (((minus) (((times) (((times) (a)) (n))) (m))) (x_1)))) (((((((eq_ind) (nat)) (((times) (m)) (((times) (a)) (n)))) (fun x_1 : nat => (((eq) (nat)) (m)) (((minus) (x_1)) (((times) (((times) (p)) (b))) (m))))) (((((((eq_ind_r) (nat)) (((times) (m)) (((times) (p)) (b)))) (fun x : nat => (((eq) (nat)) (m)) (((minus) (((times) (m)) (((times) (a)) (n)))) (x)))) (((((((eq_ind) (nat)) (((times) (m)) (((minus) (((times) (a)) (n))) (((times) (p)) (b))))) (fun x_1 : nat => (((eq) (nat)) (m)) (x_1))) (((((((rewrite_r) (nat)) (((times) (n)) (a))) (fun Joker_ : nat => (((eq) (nat)) (m)) (((times) (m)) (((minus) (Joker_)) (((times) (p)) (b)))))) (((((((rewrite_l) (nat)) (m)) (fun Joker_ : nat => (((eq) (nat)) (m)) (Joker_))) (((refl) (nat)) (m))) (((times) (m)) (((minus) (((times) (n)) (a))) (((times) (p)) (b))))) (((((((rewrite_r) (nat)) ((S) (O))) (fun Joker_ : nat => (((eq) (nat)) (m)) (((times) (m)) (Joker_)))) ((times_n_1) (m))) (((minus) (((times) (n)) (a))) (((times) (p)) (b)))) (((((((rewrite_l) (nat)) (((times) (b)) (p))) (fun Joker_ : nat => (((eq) (nat)) (((minus) (((times) (n)) (a))) (Joker_))) ((S) (O)))) (((((((rewrite_l) (nat)) (((times) (a)) (n))) (fun Joker_ : nat => (((eq) (nat)) (((minus) (Joker_)) (((times) (b)) (p)))) ((S) (O)))) (H)) (((times) (n)) (a))) (((commutative_times) (a)) (n)))) (((times) (p)) (b))) (((commutative_times) (b)) (p)))))) (((times) (a)) (n))) (((commutative_times) (a)) (n)))) (((minus) (((times) (m)) (((times) (a)) (n)))) (((times) (m)) (((times) (p)) (b))))) ((((distributive_times_minus) (m)) (((times) (a)) (n))) (((times) (p)) (b))))) (((times) (((times) (p)) (b))) (m))) (((commutative_times) (((times) (p)) (b))) (m)))) (((times) (((times) (a)) (n))) (m))) (((commutative_times) (m)) (((times) (a)) (n))))) (((times) (p)) (((times) (b)) (m)))) ((((associative_times) (p)) (b)) (m)))) (((times) (a)) (((times) (n)) (m)))) ((((associative_times) (a)) (n)) (m)))) (((times) (p)) (c))) (nm))) (((times) (((times) (a)) (p))) (c))) ((((associative_times) (a)) (p)) (c)))) (((times) (p)) (a))) (((commutative_times) (p)) (a)))) (((times) (p)) (((times) (a)) (c)))) ((((associative_times) (p)) (a)) (c)))) (((times) (p)) (((minus) (((times) (a)) (c))) (((times) (b)) (m))))) ((((distributive_times_minus) (p)) (((times) (a)) (c))) (((times) (b)) (m)))))) (fun H : (((eq) (nat)) (((minus) (((times) (b)) (p))) (((times) (a)) (n)))) ((S) (O)) => ((((quotient) (p)) (m)) (((minus) (((times) (b)) (m))) (((times) (a)) (c)))) (((((((eq_ind_r) (nat)) (((minus) (((times) (p)) (((times) (b)) (m)))) (((times) (p)) (((times) (a)) (c))))) (fun x : nat => (((eq) (nat)) (m)) (x))) (((((((eq_ind) (nat)) (((times) (((times) (p)) (b))) (m))) (fun x_1 : nat => (((eq) (nat)) (m)) (((minus) (x_1)) (((times) (p)) (((times) (a)) (c)))))) (((((((eq_ind) (nat)) (((times) (((times) (p)) (a))) (c))) (fun x_1 : nat => (((eq) (nat)) (m)) (((minus) (((times) (((times) (p)) (b))) (m))) (x_1)))) (((((((eq_ind) (nat)) (((times) (a)) (p))) (fun x_1 : nat => (((eq) (nat)) (m)) (((minus) (((times) (((times) (p)) (b))) (m))) (((times) (x_1)) (c))))) (((((((eq_ind_r) (nat)) (((times) (a)) (((times) (p)) (c)))) (fun x : nat => (((eq) (nat)) (m)) (((minus) (((times) (((times) (p)) (b))) (m))) (x)))) (((((((eq_ind) (nat)) (((times) (n)) (m))) (fun x_1 : nat => (((eq) (nat)) (m)) (((minus) (((times) (((times) (p)) (b))) (m))) (((times) (a)) (x_1))))) (((((((eq_ind) (nat)) (((times) (((times) (a)) (n))) (m))) (fun x_1 : nat => (((eq) (nat)) (m)) (((minus) (((times) (((times) (p)) (b))) (m))) (x_1)))) (((((((eq_ind) (nat)) (((times) (m)) (((times) (p)) (b)))) (fun x_1 : nat => (((eq) (nat)) (m)) (((minus) (x_1)) (((times) (((times) (a)) (n))) (m))))) (((((((eq_ind_r) (nat)) (((times) (m)) (((times) (a)) (n)))) (fun x : nat => (((eq) (nat)) (m)) (((minus) (((times) (m)) (((times) (p)) (b)))) (x)))) (((((((eq_ind) (nat)) (((times) (m)) (((minus) (((times) (p)) (b))) (((times) (a)) (n))))) (fun x_1 : nat => (((eq) (nat)) (m)) (x_1))) (((((((rewrite_r) (nat)) (((times) (n)) (a))) (fun Joker_ : nat => (((eq) (nat)) (m)) (((times) (m)) (((minus) (((times) (p)) (b))) (Joker_))))) (((((((rewrite_l) (nat)) (m)) (fun Joker_ : nat => (((eq) (nat)) (m)) (Joker_))) (((refl) (nat)) (m))) (((times) (m)) (((minus) (((times) (p)) (b))) (((times) (n)) (a))))) (((((((rewrite_r) (nat)) ((S) (O))) (fun Joker_ : nat => (((eq) (nat)) (m)) (((times) (m)) (Joker_)))) ((times_n_1) (m))) (((minus) (((times) (p)) (b))) (((times) (n)) (a)))) (((((((rewrite_l) (nat)) (((times) (a)) (n))) (fun Joker_ : nat => (((eq) (nat)) (((minus) (((times) (p)) (b))) (Joker_))) ((S) (O)))) (((((((rewrite_l) (nat)) (((times) (b)) (p))) (fun Joker_ : nat => (((eq) (nat)) (((minus) (Joker_)) (((times) (a)) (n)))) ((S) (O)))) (H)) (((times) (p)) (b))) (((commutative_times) (b)) (p)))) (((times) (n)) (a))) (((commutative_times) (a)) (n)))))) (((times) (a)) (n))) (((commutative_times) (a)) (n)))) (((minus) (((times) (m)) (((times) (p)) (b)))) (((times) (m)) (((times) (a)) (n))))) ((((distributive_times_minus) (m)) (((times) (p)) (b))) (((times) (a)) (n))))) (((times) (((times) (a)) (n))) (m))) (((commutative_times) (((times) (a)) (n))) (m)))) (((times) (((times) (p)) (b))) (m))) (((commutative_times) (m)) (((times) (p)) (b))))) (((times) (a)) (((times) (n)) (m)))) ((((associative_times) (a)) (n)) (m)))) (((times) (p)) (c))) (nm))) (((times) (((times) (a)) (p))) (c))) ((((associative_times) (a)) (p)) (c)))) (((times) (p)) (a))) (((commutative_times) (a)) (p)))) (((times) (p)) (((times) (a)) (c)))) ((((associative_times) (p)) (a)) (c)))) (((times) (p)) (((times) (b)) (m)))) ((((associative_times) (p)) (b)) (m)))) (((times) (p)) (((minus) (((times) (b)) (m))) (((times) (a)) (c))))) ((((distributive_times_minus) (p)) (((times) (b)) (m))) (((times) (a)) (c)))))) (Jokerclearme1))) (Jokerclearme0))) (((((((eq_ind) (nat)) (((gcd) (p)) (n))) (fun x_1 : nat => ((Ex) (nat)) (fun a : nat => ((Ex) (nat)) (fun b : nat => ((Or) ((((eq) (nat)) (((minus) (((times) (a)) (n))) (((times) (b)) (p)))) (x_1))) ((((eq) (nat)) (((minus) (((times) (b)) (p))) (((times) (a)) (n)))) (x_1)))))) (((((((eq_ind_r) (nat)) (((gcd) (n)) (p))) (fun x : nat => ((Ex) (nat)) (fun a : nat => ((Ex) (nat)) (fun b : nat => ((Or) ((((eq) (nat)) (((minus) (((times) (a)) (n))) (((times) (b)) (p)))) (x))) ((((eq) (nat)) (((minus) (((times) (b)) (p))) (((times) (a)) (n)))) (x)))))) (((eq_minus_gcd) (p)) (n))) (((gcd) (p)) (n))) (((commutative_gcd) (p)) (n)))) ((S) (O))) (((((prime_to_gcd_1) (p)) (n)) (primp)) (ndivpn)))))) (((decidable_divides) (p)) (n)))) (Jokerclearme).
Definition congruent : (nat) -> (nat) -> (nat) -> Prop := fun n : nat => fun m : nat => fun p : nat => (((eq) (nat)) (((mod) (n)) (p))) (((mod) (m)) (p)).
Definition congruent_n_n : forall n : nat, forall p : nat, (((congruent) (n)) (n)) (p) := fun n : nat => fun p : nat => ((refl) (nat)) (((mod) (n)) (p)).
Definition transitive_congruent : forall p : nat, ((transitive) (nat)) (fun n : nat => fun m : nat => (((congruent) (n)) (m)) (p)) := fun p : nat => fun x : nat => fun y : nat => fun z : nat => fun auto : (((congruent) (x)) (y)) (p) => fun auto' : (((congruent) (y)) (z)) (p) => ((((((rewrite_l) (nat)) (((mod) (x)) (p))) (fun Joker_ : nat => (((eq) (nat)) (((mod) (x)) (p))) (Joker_))) (((refl) (nat)) (((mod) (x)) (p)))) (((mod) (z)) (p))) (((((((rewrite_r) (nat)) (((mod) (y)) (p))) (fun Joker_ : nat => (((eq) (nat)) (Joker_)) (((mod) (z)) (p)))) (auto')) (((mod) (x)) (p))) (auto)).
Definition mod_mod : forall n : nat, forall p : nat, (((lt) (O)) (p)) -> (((eq) (nat)) (((mod) (n)) (p))) (((mod) (((mod) (n)) (p))) (p)) := fun n : nat => fun p : nat => fun posp : ((lt) (O)) (p) => ((((((eq_ind_r) (nat)) (((plus) (((times) (((div) (((mod) (n)) (p))) (p))) (p))) (((mod) (((mod) (n)) (p))) (p)))) (fun x : nat => (((eq) (nat)) (x)) (((mod) (((mod) (n)) (p))) (p)))) (((((((eq_ind_r) (nat)) (O)) (fun x : nat => (((eq) (nat)) (((plus) (((times) (x)) (p))) (((mod) (((mod) (n)) (p))) (p)))) (((mod) (((mod) (n)) (p))) (p)))) (((((((rewrite_r) (nat)) (((times) (p)) (O))) (fun Joker_ : nat => (((eq) (nat)) (((plus) (Joker_)) (((mod) (((mod) (n)) (p))) (p)))) (((mod) (((mod) (n)) (p))) (p)))) (((((((rewrite_l) (nat)) (O)) (fun Joker_ : nat => (((eq) (nat)) (((plus) (Joker_)) (((mod) (((mod) (n)) (p))) (p)))) (((mod) (((mod) (n)) (p))) (p)))) (((((((rewrite_l) (nat)) (((mod) (((mod) (n)) (p))) (p))) (fun Joker_ : nat => (((eq) (nat)) (Joker_)) (((mod) (((mod) (n)) (p))) (p)))) (((refl) (nat)) (((mod) (((mod) (n)) (p))) (p)))) (((plus) (O)) (((mod) (((mod) (n)) (p))) (p)))) ((plus_O_n) (((mod) (((mod) (n)) (p))) (p))))) (((times) (p)) (O))) ((times_n_O) (p)))) (((times) (O)) (p))) (((commutative_times) (O)) (p)))) (((div) (((mod) (n)) (p))) (p))) ((((eq_div_O) (((mod) (n)) (p))) (p)) ((((lt_mod_m_m) (n)) (p)) (posp))))) (((mod) (n)) (p))) (((div_mod) (((mod) (n)) (p))) (p)).
Definition congruent_n_mod_n : forall n : nat, forall p : nat, (((lt) (O)) (p)) -> (((congruent) (n)) (((mod) (n)) (p))) (p) := fun n : nat => fun p : nat => fun posp : ((lt) (O)) (p) => (((mod_mod) (n)) (p)) (posp).
Definition eq_times_plus_to_congruent : forall n : nat, forall m : nat, forall p : nat, forall r : nat, (((lt) (O)) (p)) -> ((((eq) (nat)) (n)) (((plus) (((times) (r)) (p))) (m))) -> (((congruent) (n)) (m)) (p) := fun n : nat => fun m : nat => fun p : nat => fun r : nat => fun posp : ((lt) (O)) (p) => fun Hn : (((eq) (nat)) (n)) (((plus) (((times) (r)) (p))) (m)) => ((((((((div_mod_spec_to_eq2) (n)) (p)) (((div) (n)) (p))) (((mod) (n)) (p))) (((plus) (r)) (((div) (m)) (p)))) (((mod) (m)) (p))) ((((div_mod_spec_div_mod) (n)) (p)) (posp))) (((((((div_mod_spec_intro) (n)) (p)) (((plus) (r)) (((div) (m)) (p)))) (((mod) (m)) (p))) ((((lt_mod_m_m) (m)) (p)) (posp))) (((((((eq_ind_r) (nat)) (((times) (p)) (((plus) (r)) (((div) (m)) (p))))) (fun x : nat => (((eq) (nat)) (n)) (((plus) (x)) (((mod) (m)) (p))))) (((((((eq_ind_r) (nat)) (((plus) (((times) (p)) (r))) (((times) (p)) (((div) (m)) (p))))) (fun x : nat => (((eq) (nat)) (n)) (((plus) (x)) (((mod) (m)) (p))))) (((((((eq_ind_r) (nat)) (((times) (r)) (p))) (fun x : nat => (((eq) (nat)) (n)) (((plus) (((plus) (x)) (((times) (p)) (((div) (m)) (p))))) (((mod) (m)) (p))))) (((((((eq_ind_r) (nat)) (((times) (((div) (m)) (p))) (p))) (fun x : nat => (((eq) (nat)) (n)) (((plus) (((plus) (((times) (r)) (p))) (x))) (((mod) (m)) (p))))) (((((((eq_ind_r) (nat)) (((plus) (((times) (r)) (p))) (((plus) (((times) (((div) (m)) (p))) (p))) (((mod) (m)) (p))))) (fun x : nat => (((eq) (nat)) (n)) (x))) (((((((rewrite_r) (nat)) (((times) (p)) (r))) (fun Joker_ : nat => (((eq) (nat)) (n)) (((plus) (Joker_)) (((plus) (((times) (((div) (m)) (p))) (p))) (((mod) (m)) (p)))))) (((((((rewrite_r) (nat)) (((times) (p)) (((div) (m)) (p)))) (fun Joker_ : nat => (((eq) (nat)) (n)) (((plus) (((times) (p)) (r))) (((plus) (Joker_)) (((mod) (m)) (p)))))) (((((((rewrite_r) (nat)) (((plus) (((mod) (m)) (p))) (((times) (p)) (((div) (m)) (p))))) (fun Joker_ : nat => (((eq) (nat)) (n)) (((plus) (((times) (p)) (r))) (Joker_)))) (((((((rewrite_l) (nat)) (m)) (fun Joker_ : nat => (((eq) (nat)) (n)) (((plus) (((times) (p)) (r))) (Joker_)))) (((((((rewrite_r) (nat)) (((plus) (m)) (((times) (p)) (r)))) (fun Joker_ : nat => (((eq) (nat)) (n)) (Joker_))) (((((((rewrite_l) (nat)) (n)) (fun Joker_ : nat => (((eq) (nat)) (n)) (Joker_))) (((refl) (nat)) (n))) (((plus) (m)) (((times) (p)) (r)))) (((((((rewrite_l) (nat)) (((plus) (((times) (p)) (r))) (m))) (fun Joker_ : nat => (((eq) (nat)) (n)) (Joker_))) (((((((rewrite_l) (nat)) (((times) (r)) (p))) (fun Joker_ : nat => (((eq) (nat)) (n)) (((plus) (Joker_)) (m)))) (Hn)) (((times) (p)) (r))) (((commutative_times) (r)) (p)))) (((plus) (m)) (((times) (p)) (r)))) (((commutative_plus) (((times) (p)) (r))) (m))))) (((plus) (((times) (p)) (r))) (m))) (((commutative_plus) (((times) (p)) (r))) (m)))) (((plus) (((mod) (m)) (p))) (((times) (p)) (((div) (m)) (p))))) (((((((rewrite_l) (nat)) (((plus) (((times) (p)) (((div) (m)) (p)))) (((mod) (m)) (p)))) (fun Joker_ : nat => (((eq) (nat)) (m)) (Joker_))) (((((((rewrite_l) (nat)) (((times) (((div) (m)) (p))) (p))) (fun Joker_ : nat => (((eq) (nat)) (m)) (((plus) (Joker_)) (((mod) (m)) (p))))) (((div_mod) (m)) (p))) (((times) (p)) (((div) (m)) (p)))) (((commutative_times) (((div) (m)) (p))) (p)))) (((plus) (((mod) (m)) (p))) (((times) (p)) (((div) (m)) (p))))) (((commutative_plus) (((times) (p)) (((div) (m)) (p)))) (((mod) (m)) (p)))))) (((plus) (((times) (p)) (((div) (m)) (p)))) (((mod) (m)) (p)))) (((commutative_plus) (((times) (p)) (((div) (m)) (p)))) (((mod) (m)) (p))))) (((times) (((div) (m)) (p))) (p))) (((commutative_times) (((div) (m)) (p))) (p)))) (((times) (r)) (p))) (((commutative_times) (r)) (p)))) (((plus) (((plus) (((times) (r)) (p))) (((times) (((div) (m)) (p))) (p)))) (((mod) (m)) (p)))) ((((associative_plus) (((times) (r)) (p))) (((times) (((div) (m)) (p))) (p))) (((mod) (m)) (p))))) (((times) (p)) (((div) (m)) (p)))) (((commutative_times) (p)) (((div) (m)) (p))))) (((times) (p)) (r))) (((commutative_times) (p)) (r)))) (((times) (p)) (((plus) (r)) (((div) (m)) (p))))) ((((distributive_times_plus) (p)) (r)) (((div) (m)) (p))))) (((times) (((plus) (r)) (((div) (m)) (p)))) (p))) (((commutative_times) (((plus) (r)) (((div) (m)) (p)))) (p)))).
Definition divides_to_congruent : forall n : nat, forall m : nat, forall p : nat, (((lt) (O)) (p)) -> (((le) (m)) (n)) -> (((divides) (p)) (((minus) (n)) (m))) -> (((congruent) (n)) (m)) (p) := fun n : nat => fun m : nat => fun p : nat => fun posp : ((lt) (O)) (p) => fun lemn : ((le) (m)) (n) => fun Jokerclearme : ((divides) (p)) (((minus) (n)) (m)) => (((((match_divides_prop) (p)) (((minus) (n)) (m))) ((((congruent) (n)) (m)) (p))) (fun q : nat => fun Hdiv : (((eq) (nat)) (((minus) (n)) (m))) (((times) (p)) (q)) => ((((((eq_times_plus_to_congruent) (n)) (m)) (p)) (q)) (posp)) (((((((eq_ind_r) (nat)) (((plus) (m)) (((times) (q)) (p)))) (fun x : nat => (((eq) (nat)) (n)) (x))) ((((((minus_to_plus) (n)) (m)) (((times) (q)) (p))) (lemn)) (((((((rewrite_r) (nat)) (((times) (p)) (q))) (fun Joker_ : nat => (((eq) (nat)) (Joker_)) (((times) (q)) (p)))) (((((((rewrite_r) (nat)) (((times) (p)) (q))) (fun Joker_ : nat => (((eq) (nat)) (((times) (p)) (q))) (Joker_))) (((refl) (nat)) (((times) (p)) (q)))) (((times) (q)) (p))) (((commutative_times) (q)) (p)))) (((minus) (n)) (m))) (Hdiv)))) (((plus) (((times) (q)) (p))) (m))) (((commutative_plus) (((times) (q)) (p))) (m))))) (Jokerclearme).
Definition congruent_to_divides : forall n : nat, forall m : nat, forall p : nat, (((lt) (O)) (p)) -> ((((congruent) (n)) (m)) (p)) -> ((divides) (p)) (((minus) (n)) (m)) := fun n : nat => fun m : nat => fun p : nat => fun posp : ((lt) (O)) (p) => fun Hcong : (((congruent) (n)) (m)) (p) => ((((quotient) (p)) (((minus) (n)) (m))) (((minus) (((div) (n)) (p))) (((div) (m)) (p)))) (((((((eq_ind_r) (nat)) (((times) (((minus) (((div) (n)) (p))) (((div) (m)) (p)))) (p))) (fun x : nat => (((eq) (nat)) (((minus) (n)) (m))) (x))) (((((((eq_ind_r) (nat)) (((plus) (((times) (((div) (n)) (p))) (p))) (((mod) (n)) (p)))) (fun x : nat => (((eq) (nat)) (((minus) (x)) (m))) (((times) (((minus) (((div) (n)) (p))) (((div) (m)) (p)))) (p)))) (((((((eq_ind_r) (nat)) (((plus) (((times) (((div) (m)) (p))) (p))) (((mod) (m)) (p)))) (fun x : nat => (((eq) (nat)) (((minus) (((plus) (((times) (((div) (n)) (p))) (p))) (((mod) (n)) (p)))) (x))) (((times) (((minus) (((div) (n)) (p))) (((div) (m)) (p)))) (p)))) (((((((rewrite_r) (nat)) (((times) (p)) (((div) (n)) (p)))) (fun Joker_ : nat => (((eq) (nat)) (((minus) (((plus) (Joker_)) (((mod) (n)) (p)))) (((plus) (((times) (((div) (m)) (p))) (p))) (((mod) (m)) (p))))) (((times) (((minus) (((div) (n)) (p))) (((div) (m)) (p)))) (p)))) (((((((rewrite_r) (nat)) (((plus) (((mod) (n)) (p))) (((times) (p)) (((div) (n)) (p))))) (fun Joker_ : nat => (((eq) (nat)) (((minus) (Joker_)) (((plus) (((times) (((div) (m)) (p))) (p))) (((mod) (m)) (p))))) (((times) (((minus) (((div) (n)) (p))) (((div) (m)) (p)))) (p)))) (((((((rewrite_l) (nat)) (n)) (fun Joker_ : nat => (((eq) (nat)) (((minus) (Joker_)) (((plus) (((times) (((div) (m)) (p))) (p))) (((mod) (m)) (p))))) (((times) (((minus) (((div) (n)) (p))) (((div) (m)) (p)))) (p)))) (((((((rewrite_r) (nat)) (((times) (p)) (((div) (m)) (p)))) (fun Joker_ : nat => (((eq) (nat)) (((minus) (n)) (((plus) (Joker_)) (((mod) (m)) (p))))) (((times) (((minus) (((div) (n)) (p))) (((div) (m)) (p)))) (p)))) (((((((rewrite_l) (nat)) (((mod) (n)) (p))) (fun Joker_ : nat => (((eq) (nat)) (((minus) (n)) (((plus) (((times) (p)) (((div) (m)) (p)))) (Joker_)))) (((times) (((minus) (((div) (n)) (p))) (((div) (m)) (p)))) (p)))) (((((((rewrite_r) (nat)) (((plus) (((mod) (n)) (p))) (((times) (p)) (((div) (m)) (p))))) (fun Joker_ : nat => (((eq) (nat)) (((minus) (n)) (Joker_))) (((times) (((minus) (((div) (n)) (p))) (((div) (m)) (p)))) (p)))) (((((((rewrite_l) (nat)) (((minus) (((minus) (n)) (((mod) (n)) (p)))) (((times) (p)) (((div) (m)) (p))))) (fun Joker_ : nat => (((eq) (nat)) (Joker_)) (((times) (((minus) (((div) (n)) (p))) (((div) (m)) (p)))) (p)))) (((((((rewrite_l) (nat)) (((times) (p)) (((div) (n)) (p)))) (fun Joker_ : nat => (((eq) (nat)) (((minus) (Joker_)) (((times) (p)) (((div) (m)) (p))))) (((times) (((minus) (((div) (n)) (p))) (((div) (m)) (p)))) (p)))) (((((((rewrite_l) (nat)) (((times) (p)) (((minus) (((div) (n)) (p))) (((div) (m)) (p))))) (fun Joker_ : nat => (((eq) (nat)) (Joker_)) (((times) (((minus) (((div) (n)) (p))) (((div) (m)) (p)))) (p)))) (((((((rewrite_r) (nat)) (((times) (p)) (((minus) (((div) (n)) (p))) (((div) (m)) (p))))) (fun Joker_ : nat => (((eq) (nat)) (((times) (p)) (((minus) (((div) (n)) (p))) (((div) (m)) (p))))) (Joker_))) (((refl) (nat)) (((times) (p)) (((minus) (((div) (n)) (p))) (((div) (m)) (p)))))) (((times) (((minus) (((div) (n)) (p))) (((div) (m)) (p)))) (p))) (((commutative_times) (((minus) (((div) (n)) (p))) (((div) (m)) (p)))) (p)))) (((minus) (((times) (p)) (((div) (n)) (p)))) (((times) (p)) (((div) (m)) (p))))) ((((distributive_times_minus) (p)) (((div) (n)) (p))) (((div) (m)) (p))))) (((minus) (n)) (((mod) (n)) (p)))) (((((((rewrite_l) (nat)) (((times) (((div) (n)) (p))) (p))) (fun Joker_ : nat => (((eq) (nat)) (Joker_)) (((minus) (n)) (((mod) (n)) (p))))) (((eq_times_div_minus_mod) (n)) (p))) (((times) (p)) (((div) (n)) (p)))) (((commutative_times) (((div) (n)) (p))) (p))))) (((minus) (n)) (((plus) (((mod) (n)) (p))) (((times) (p)) (((div) (m)) (p)))))) ((((minus_plus) (n)) (((mod) (n)) (p))) (((times) (p)) (((div) (m)) (p)))))) (((plus) (((times) (p)) (((div) (m)) (p)))) (((mod) (n)) (p)))) (((commutative_plus) (((times) (p)) (((div) (m)) (p)))) (((mod) (n)) (p))))) (((mod) (m)) (p))) (Hcong))) (((times) (((div) (m)) (p))) (p))) (((commutative_times) (((div) (m)) (p))) (p)))) (((plus) (((mod) (n)) (p))) (((times) (p)) (((div) (n)) (p))))) (((((((rewrite_l) (nat)) (((plus) (((times) (p)) (((div) (n)) (p)))) (((mod) (n)) (p)))) (fun Joker_ : nat => (((eq) (nat)) (n)) (Joker_))) (((((((rewrite_l) (nat)) (((times) (((div) (n)) (p))) (p))) (fun Joker_ : nat => (((eq) (nat)) (n)) (((plus) (Joker_)) (((mod) (n)) (p))))) (((div_mod) (n)) (p))) (((times) (p)) (((div) (n)) (p)))) (((commutative_times) (((div) (n)) (p))) (p)))) (((plus) (((mod) (n)) (p))) (((times) (p)) (((div) (n)) (p))))) (((commutative_plus) (((times) (p)) (((div) (n)) (p)))) (((mod) (n)) (p)))))) (((plus) (((times) (p)) (((div) (n)) (p)))) (((mod) (n)) (p)))) (((commutative_plus) (((times) (p)) (((div) (n)) (p)))) (((mod) (n)) (p))))) (((times) (((div) (n)) (p))) (p))) (((commutative_times) (((div) (n)) (p))) (p)))) (m)) (((div_mod) (m)) (p)))) (n)) (((div_mod) (n)) (p)))) (((times) (p)) (((minus) (((div) (n)) (p))) (((div) (m)) (p))))) (((commutative_times) (p)) (((minus) (((div) (n)) (p))) (((div) (m)) (p))))).
Definition let_clause_1034 : forall n : nat, forall m : nat, forall p : nat, (((lt) (O)) (p)) -> forall x2515 : nat, forall x2516 : nat, (((eq) (nat)) (x2515)) (((plus) (((mod) (x2515)) (x2516))) (((times) (x2516)) (((div) (x2515)) (x2516)))) := fun n : nat => fun m : nat => fun p : nat => fun posp : ((lt) (O)) (p) => fun x2515 : nat => fun x2516 : nat => ((((((rewrite_l) (nat)) (((plus) (((times) (x2516)) (((div) (x2515)) (x2516)))) (((mod) (x2515)) (x2516)))) (fun Joker_ : nat => (((eq) (nat)) (x2515)) (Joker_))) (((((((rewrite_l) (nat)) (((times) (((div) (x2515)) (x2516))) (x2516))) (fun Joker_ : nat => (((eq) (nat)) (x2515)) (((plus) (Joker_)) (((mod) (x2515)) (x2516))))) (((div_mod) (x2515)) (x2516))) (((times) (x2516)) (((div) (x2515)) (x2516)))) (((commutative_times) (((div) (x2515)) (x2516))) (x2516)))) (((plus) (((mod) (x2515)) (x2516))) (((times) (x2516)) (((div) (x2515)) (x2516))))) (((commutative_plus) (((times) (x2516)) (((div) (x2515)) (x2516)))) (((mod) (x2515)) (x2516))).
Definition let_clause_73 : forall n : nat, forall m : nat, forall p : nat, (((lt) (O)) (p)) -> forall x134 : nat, forall x135 : nat, forall x136 : nat, (((eq) (nat)) (((plus) (x134)) (((plus) (x135)) (x136)))) (((plus) (x135)) (((plus) (x134)) (x136))) := fun n : nat => fun m : nat => fun p : nat => fun posp : ((lt) (O)) (p) => fun x134 : nat => fun x135 : nat => fun x136 : nat => ((((((rewrite_l) (nat)) (((plus) (((plus) (x135)) (x134))) (x136))) (fun Joker_ : nat => (((eq) (nat)) (((plus) (x134)) (((plus) (x135)) (x136)))) (Joker_))) ((((assoc_plus1) (x136)) (x135)) (x134))) (((plus) (x135)) (((plus) (x134)) (x136)))) ((((associative_plus) (x135)) (x134)) (x136)).
Definition mod_times : forall n : nat, forall m : nat, forall p : nat, (((lt) (O)) (p)) -> (((eq) (nat)) (((mod) (((times) (n)) (m))) (p))) (((mod) (((times) (((mod) (n)) (p))) (((mod) (m)) (p)))) (p)) := fun n : nat => fun m : nat => fun p : nat => fun posp : ((lt) (O)) (p) => ((((((eq_times_plus_to_congruent) (((times) (n)) (m))) (((times) (((mod) (n)) (p))) (((mod) (m)) (p)))) (p)) (((plus) (((plus) (((times) (((times) (((div) (n)) (p))) (p))) (((div) (m)) (p)))) (((times) (((div) (n)) (p))) (((mod) (m)) (p))))) (((times) (((mod) (n)) (p))) (((div) (m)) (p))))) (posp)) (((((((trans_eq) (nat)) (((times) (n)) (m))) (((times) (((plus) (((times) (((div) (n)) (p))) (p))) (((mod) (n)) (p)))) (((plus) (((times) (((div) (m)) (p))) (p))) (((mod) (m)) (p))))) (((plus) (((times) (((plus) (((plus) (((times) (((times) (((div) (n)) (p))) (p))) (((div) (m)) (p)))) (((times) (((div) (n)) (p))) (((mod) (m)) (p))))) (((times) (((mod) (n)) (p))) (((div) (m)) (p))))) (p))) (((times) (((mod) (n)) (p))) (((mod) (m)) (p))))) (((((((rewrite_r) (nat)) (((times) (p)) (((div) (n)) (p)))) (fun Joker_ : nat => (((eq) (nat)) (((times) (n)) (m))) (((times) (((plus) (Joker_)) (((mod) (n)) (p)))) (((plus) (((times) (((div) (m)) (p))) (p))) (((mod) (m)) (p)))))) (((((((rewrite_r) (nat)) (((plus) (((mod) (n)) (p))) (((times) (p)) (((div) (n)) (p))))) (fun Joker_ : nat => (((eq) (nat)) (((times) (n)) (m))) (((times) (Joker_)) (((plus) (((times) (((div) (m)) (p))) (p))) (((mod) (m)) (p)))))) (((((((rewrite_l) (nat)) (n)) (fun Joker_ : nat => (((eq) (nat)) (((times) (n)) (m))) (((times) (Joker_)) (((plus) (((times) (((div) (m)) (p))) (p))) (((mod) (m)) (p)))))) (((((((rewrite_r) (nat)) (((times) (p)) (((div) (m)) (p)))) (fun Joker_ : nat => (((eq) (nat)) (((times) (n)) (m))) (((times) (n)) (((plus) (Joker_)) (((mod) (m)) (p)))))) (((((((rewrite_r) (nat)) (((plus) (((mod) (m)) (p))) (((times) (p)) (((div) (m)) (p))))) (fun Joker_ : nat => (((eq) (nat)) (((times) (n)) (m))) (((times) (n)) (Joker_)))) (((((((rewrite_l) (nat)) (m)) (fun Joker_ : nat => (((eq) (nat)) (((times) (n)) (m))) (((times) (n)) (Joker_)))) (((refl) (nat)) (((times) (n)) (m)))) (((plus) (((mod) (m)) (p))) (((times) (p)) (((div) (m)) (p))))) (((((((let_clause_1034) (n)) (m)) (p)) (posp)) (m)) (p)))) (((plus) (((times) (p)) (((div) (m)) (p)))) (((mod) (m)) (p)))) (((commutative_plus) (((times) (p)) (((div) (m)) (p)))) (((mod) (m)) (p))))) (((times) (((div) (m)) (p))) (p))) (((commutative_times) (((div) (m)) (p))) (p)))) (((plus) (((mod) (n)) (p))) (((times) (p)) (((div) (n)) (p))))) (((((((let_clause_1034) (n)) (m)) (p)) (posp)) (n)) (p)))) (((plus) (((times) (p)) (((div) (n)) (p)))) (((mod) (n)) (p)))) (((commutative_plus) (((times) (p)) (((div) (n)) (p)))) (((mod) (n)) (p))))) (((times) (((div) (n)) (p))) (p))) (((commutative_times) (((div) (n)) (p))) (p)))) (((((((trans_eq) (nat)) (((times) (((plus) (((times) (((div) (n)) (p))) (p))) (((mod) (n)) (p)))) (((plus) (((times) (((div) (m)) (p))) (p))) (((mod) (m)) (p))))) (((plus) (((plus) (((plus) (((times) (((times) (((div) (n)) (p))) (p))) (((times) (((div) (m)) (p))) (p)))) (((times) (((times) (((div) (n)) (p))) (p))) (((mod) (m)) (p))))) (((times) (((mod) (n)) (p))) (((times) (((div) (m)) (p))) (p))))) (((times) (((mod) (n)) (p))) (((mod) (m)) (p))))) (((plus) (((times) (((plus) (((plus) (((times) (((times) (((div) (n)) (p))) (p))) (((div) (m)) (p)))) (((times) (((div) (n)) (p))) (((mod) (m)) (p))))) (((times) (((mod) (n)) (p))) (((div) (m)) (p))))) (p))) (((times) (((mod) (n)) (p))) (((mod) (m)) (p))))) (((((((eq_ind_r) (nat)) (((plus) (((times) (((times) (((div) (n)) (p))) (p))) (((plus) (((times) (((div) (m)) (p))) (p))) (((mod) (m)) (p))))) (((times) (((mod) (n)) (p))) (((plus) (((times) (((div) (m)) (p))) (p))) (((mod) (m)) (p)))))) (fun x : nat => (((eq) (nat)) (x)) (((plus) (((plus) (((plus) (((times) (((times) (((div) (n)) (p))) (p))) (((times) (((div) (m)) (p))) (p)))) (((times) (((times) (((div) (n)) (p))) (p))) (((mod) (m)) (p))))) (((times) (((mod) (n)) (p))) (((times) (((div) (m)) (p))) (p))))) (((times) (((mod) (n)) (p))) (((mod) (m)) (p)))))) (((((((eq_ind_r) (nat)) (((plus) (((times) (((times) (((div) (n)) (p))) (p))) (((times) (((div) (m)) (p))) (p)))) (((times) (((times) (((div) (n)) (p))) (p))) (((mod) (m)) (p))))) (fun x : nat => (((eq) (nat)) (((plus) (x)) (((times) (((mod) (n)) (p))) (((plus) (((times) (((div) (m)) (p))) (p))) (((mod) (m)) (p)))))) (((plus) (((plus) (((plus) (((times) (((times) (((div) (n)) (p))) (p))) (((times) (((div) (m)) (p))) (p)))) (((times) (((times) (((div) (n)) (p))) (p))) (((mod) (m)) (p))))) (((times) (((mod) (n)) (p))) (((times) (((div) (m)) (p))) (p))))) (((times) (((mod) (n)) (p))) (((mod) (m)) (p)))))) (((((((eq_ind_r) (nat)) (((plus) (((times) (((mod) (n)) (p))) (((times) (((div) (m)) (p))) (p)))) (((times) (((mod) (n)) (p))) (((mod) (m)) (p))))) (fun x : nat => (((eq) (nat)) (((plus) (((plus) (((times) (((times) (((div) (n)) (p))) (p))) (((times) (((div) (m)) (p))) (p)))) (((times) (((times) (((div) (n)) (p))) (p))) (((mod) (m)) (p))))) (x))) (((plus) (((plus) (((plus) (((times) (((times) (((div) (n)) (p))) (p))) (((times) (((div) (m)) (p))) (p)))) (((times) (((times) (((div) (n)) (p))) (p))) (((mod) (m)) (p))))) (((times) (((mod) (n)) (p))) (((times) (((div) (m)) (p))) (p))))) (((times) (((mod) (n)) (p))) (((mod) (m)) (p)))))) (((((((rewrite_l) (nat)) (((plus) (((plus) (((plus) (((times) (((times) (((div) (n)) (p))) (p))) (((times) (((div) (m)) (p))) (p)))) (((times) (((times) (((div) (n)) (p))) (p))) (((mod) (m)) (p))))) (((times) (((mod) (n)) (p))) (((times) (((div) (m)) (p))) (p))))) (((times) (((mod) (n)) (p))) (((mod) (m)) (p))))) (fun Joker_ : nat => (((eq) (nat)) (Joker_)) (((plus) (((plus) (((plus) (((times) (((times) (((div) (n)) (p))) (p))) (((times) (((div) (m)) (p))) (p)))) (((times) (((times) (((div) (n)) (p))) (p))) (((mod) (m)) (p))))) (((times) (((mod) (n)) (p))) (((times) (((div) (m)) (p))) (p))))) (((times) (((mod) (n)) (p))) (((mod) (m)) (p)))))) (((refl) (nat)) (((plus) (((plus) (((plus) (((times) (((times) (((div) (n)) (p))) (p))) (((times) (((div) (m)) (p))) (p)))) (((times) (((times) (((div) (n)) (p))) (p))) (((mod) (m)) (p))))) (((times) (((mod) (n)) (p))) (((times) (((div) (m)) (p))) (p))))) (((times) (((mod) (n)) (p))) (((mod) (m)) (p)))))) (((plus) (((plus) (((times) (((times) (((div) (n)) (p))) (p))) (((times) (((div) (m)) (p))) (p)))) (((times) (((times) (((div) (n)) (p))) (p))) (((mod) (m)) (p))))) (((plus) (((times) (((mod) (n)) (p))) (((times) (((div) (m)) (p))) (p)))) (((times) (((mod) (n)) (p))) (((mod) (m)) (p)))))) ((((associative_plus) (((plus) (((times) (((times) (((div) (n)) (p))) (p))) (((times) (((div) (m)) (p))) (p)))) (((times) (((times) (((div) (n)) (p))) (p))) (((mod) (m)) (p))))) (((times) (((mod) (n)) (p))) (((times) (((div) (m)) (p))) (p)))) (((times) (((mod) (n)) (p))) (((mod) (m)) (p)))))) (((times) (((mod) (n)) (p))) (((plus) (((times) (((div) (m)) (p))) (p))) (((mod) (m)) (p))))) ((((distributive_times_plus) (((mod) (n)) (p))) (((times) (((div) (m)) (p))) (p))) (((mod) (m)) (p))))) (((times) (((times) (((div) (n)) (p))) (p))) (((plus) (((times) (((div) (m)) (p))) (p))) (((mod) (m)) (p))))) ((((distributive_times_plus) (((times) (((div) (n)) (p))) (p))) (((times) (((div) (m)) (p))) (p))) (((mod) (m)) (p))))) (((times) (((plus) (((times) (((div) (n)) (p))) (p))) (((mod) (n)) (p)))) (((plus) (((times) (((div) (m)) (p))) (p))) (((mod) (m)) (p))))) ((((distributive_times_plus_r) (((plus) (((times) (((div) (m)) (p))) (p))) (((mod) (m)) (p)))) (((times) (((div) (n)) (p))) (p))) (((mod) (n)) (p))))) (((((((((((eq_f2) (nat)) (nat)) (nat)) (plus)) (((plus) (((plus) (((times) (((times) (((div) (n)) (p))) (p))) (((times) (((div) (m)) (p))) (p)))) (((times) (((times) (((div) (n)) (p))) (p))) (((mod) (m)) (p))))) (((times) (((mod) (n)) (p))) (((times) (((div) (m)) (p))) (p))))) (((times) (((plus) (((plus) (((times) (((times) (((div) (n)) (p))) (p))) (((div) (m)) (p)))) (((times) (((div) (n)) (p))) (((mod) (m)) (p))))) (((times) (((mod) (n)) (p))) (((div) (m)) (p))))) (p))) (((times) (((mod) (n)) (p))) (((mod) (m)) (p)))) (((times) (((mod) (n)) (p))) (((mod) (m)) (p)))) (((((((eq_ind) (nat)) (((times) (((times) (((times) (((div) (n)) (p))) (p))) (((div) (m)) (p)))) (p))) (fun x_1 : nat => (((eq) (nat)) (((plus) (((plus) (x_1)) (((times) (((times) (((div) (n)) (p))) (p))) (((mod) (m)) (p))))) (((times) (((mod) (n)) (p))) (((times) (((div) (m)) (p))) (p))))) (((times) (((plus) (((plus) (((times) (((times) (((div) (n)) (p))) (p))) (((div) (m)) (p)))) (((times) (((div) (n)) (p))) (((mod) (m)) (p))))) (((times) (((mod) (n)) (p))) (((div) (m)) (p))))) (p)))) (((((((eq_ind_r) (nat)) (((times) (((div) (n)) (p))) (((times) (p)) (((mod) (m)) (p))))) (fun x : nat => (((eq) (nat)) (((plus) (((plus) (((times) (((times) (((times) (((div) (n)) (p))) (p))) (((div) (m)) (p)))) (p))) (x))) (((times) (((mod) (n)) (p))) (((times) (((div) (m)) (p))) (p))))) (((times) (((plus) (((plus) (((times) (((times) (((div) (n)) (p))) (p))) (((div) (m)) (p)))) (((times) (((div) (n)) (p))) (((mod) (m)) (p))))) (((times) (((mod) (n)) (p))) (((div) (m)) (p))))) (p)))) (((((((eq_ind_r) (nat)) (((times) (((mod) (m)) (p))) (p))) (fun x : nat => (((eq) (nat)) (((plus) (((plus) (((times) (((times) (((times) (((div) (n)) (p))) (p))) (((div) (m)) (p)))) (p))) (((times) (((div) (n)) (p))) (x)))) (((times) (((mod) (n)) (p))) (((times) (((div) (m)) (p))) (p))))) (((times) (((plus) (((plus) (((times) (((times) (((div) (n)) (p))) (p))) (((div) (m)) (p)))) (((times) (((div) (n)) (p))) (((mod) (m)) (p))))) (((times) (((mod) (n)) (p))) (((div) (m)) (p))))) (p)))) (((((((eq_ind) (nat)) (((times) (((times) (((div) (n)) (p))) (((mod) (m)) (p)))) (p))) (fun x_1 : nat => (((eq) (nat)) (((plus) (((plus) (((times) (((times) (((times) (((div) (n)) (p))) (p))) (((div) (m)) (p)))) (p))) (x_1))) (((times) (((mod) (n)) (p))) (((times) (((div) (m)) (p))) (p))))) (((times) (((plus) (((plus) (((times) (((times) (((div) (n)) (p))) (p))) (((div) (m)) (p)))) (((times) (((div) (n)) (p))) (((mod) (m)) (p))))) (((times) (((mod) (n)) (p))) (((div) (m)) (p))))) (p)))) (((((((eq_ind_r) (nat)) (((plus) (((times) (((plus) (((times) (((times) (((div) (n)) (p))) (p))) (((div) (m)) (p)))) (((times) (((div) (n)) (p))) (((mod) (m)) (p))))) (p))) (((times) (((times) (((mod) (n)) (p))) (((div) (m)) (p)))) (p)))) (fun x : nat => (((eq) (nat)) (((plus) (((plus) (((times) (((times) (((times) (((div) (n)) (p))) (p))) (((div) (m)) (p)))) (p))) (((times) (((times) (((div) (n)) (p))) (((mod) (m)) (p)))) (p)))) (((times) (((mod) (n)) (p))) (((times) (((div) (m)) (p))) (p))))) (x))) (((((((rewrite_r) (nat)) (((times) (p)) (((div) (n)) (p)))) (fun Joker_ : nat => (((eq) (nat)) (((plus) (((plus) (((times) (((times) (Joker_)) (((div) (m)) (p)))) (p))) (((times) (((times) (((div) (n)) (p))) (((mod) (m)) (p)))) (p)))) (((times) (((mod) (n)) (p))) (((times) (((div) (m)) (p))) (p))))) (((plus) (((times) (((plus) (((times) (((times) (((div) (n)) (p))) (p))) (((div) (m)) (p)))) (((times) (((div) (n)) (p))) (((mod) (m)) (p))))) (p))) (((times) (((times) (((mod) (n)) (p))) (((div) (m)) (p)))) (p))))) (((((((rewrite_r) (nat)) (((times) (((div) (m)) (p))) (((times) (p)) (((div) (n)) (p))))) (fun Joker_ : nat => (((eq) (nat)) (((plus) (((plus) (((times) (Joker_)) (p))) (((times) (((times) (((div) (n)) (p))) (((mod) (m)) (p)))) (p)))) (((times) (((mod) (n)) (p))) (((times) (((div) (m)) (p))) (p))))) (((plus) (((times) (((plus) (((times) (((times) (((div) (n)) (p))) (p))) (((div) (m)) (p)))) (((times) (((div) (n)) (p))) (((mod) (m)) (p))))) (p))) (((times) (((times) (((mod) (n)) (p))) (((div) (m)) (p)))) (p))))) (((((((rewrite_r) (nat)) (((times) (p)) (((times) (((div) (m)) (p))) (((div) (n)) (p))))) (fun Joker_ : nat => (((eq) (nat)) (((plus) (((plus) (((times) (Joker_)) (p))) (((times) (((times) (((div) (n)) (p))) (((mod) (m)) (p)))) (p)))) (((times) (((mod) (n)) (p))) (((times) (((div) (m)) (p))) (p))))) (((plus) (((times) (((plus) (((times) (((times) (((div) (n)) (p))) (p))) (((div) (m)) (p)))) (((times) (((div) (n)) (p))) (((mod) (m)) (p))))) (p))) (((times) (((times) (((mod) (n)) (p))) (((div) (m)) (p)))) (p))))) (((((((rewrite_r) (nat)) (((times) (((div) (n)) (p))) (((div) (m)) (p)))) (fun Joker_ : nat => (((eq) (nat)) (((plus) (((plus) (((times) (((times) (p)) (Joker_))) (p))) (((times) (((times) (((div) (n)) (p))) (((mod) (m)) (p)))) (p)))) (((times) (((mod) (n)) (p))) (((times) (((div) (m)) (p))) (p))))) (((plus) (((times) (((plus) (((times) (((times) (((div) (n)) (p))) (p))) (((div) (m)) (p)))) (((times) (((div) (n)) (p))) (((mod) (m)) (p))))) (p))) (((times) (((times) (((mod) (n)) (p))) (((div) (m)) (p)))) (p))))) (((((((rewrite_r) (nat)) (((times) (p)) (((times) (p)) (((times) (((div) (n)) (p))) (((div) (m)) (p)))))) (fun Joker_ : nat => (((eq) (nat)) (((plus) (((plus) (Joker_)) (((times) (((times) (((div) (n)) (p))) (((mod) (m)) (p)))) (p)))) (((times) (((mod) (n)) (p))) (((times) (((div) (m)) (p))) (p))))) (((plus) (((times) (((plus) (((times) (((times) (((div) (n)) (p))) (p))) (((div) (m)) (p)))) (((times) (((div) (n)) (p))) (((mod) (m)) (p))))) (p))) (((times) (((times) (((mod) (n)) (p))) (((div) (m)) (p)))) (p))))) (((((((rewrite_r) (nat)) (((times) (p)) (((times) (((div) (n)) (p))) (((mod) (m)) (p))))) (fun Joker_ : nat => (((eq) (nat)) (((plus) (((plus) (((times) (p)) (((times) (p)) (((times) (((div) (n)) (p))) (((div) (m)) (p)))))) (Joker_))) (((times) (((mod) (n)) (p))) (((times) (((div) (m)) (p))) (p))))) (((plus) (((times) (((plus) (((times) (((times) (((div) (n)) (p))) (p))) (((div) (m)) (p)))) (((times) (((div) (n)) (p))) (((mod) (m)) (p))))) (p))) (((times) (((times) (((mod) (n)) (p))) (((div) (m)) (p)))) (p))))) (((((((rewrite_l) (nat)) (((times) (p)) (((plus) (((times) (p)) (((times) (((div) (n)) (p))) (((div) (m)) (p))))) (((times) (((div) (n)) (p))) (((mod) (m)) (p)))))) (fun Joker_ : nat => (((eq) (nat)) (((plus) (Joker_)) (((times) (((mod) (n)) (p))) (((times) (((div) (m)) (p))) (p))))) (((plus) (((times) (((plus) (((times) (((times) (((div) (n)) (p))) (p))) (((div) (m)) (p)))) (((times) (((div) (n)) (p))) (((mod) (m)) (p))))) (p))) (((times) (((times) (((mod) (n)) (p))) (((div) (m)) (p)))) (p))))) (((((((rewrite_r) (nat)) (((times) (p)) (((div) (m)) (p)))) (fun Joker_ : nat => (((eq) (nat)) (((plus) (((times) (p)) (((plus) (((times) (p)) (((times) (((div) (n)) (p))) (((div) (m)) (p))))) (((times) (((div) (n)) (p))) (((mod) (m)) (p)))))) (((times) (((mod) (n)) (p))) (Joker_)))) (((plus) (((times) (((plus) (((times) (((times) (((div) (n)) (p))) (p))) (((div) (m)) (p)))) (((times) (((div) (n)) (p))) (((mod) (m)) (p))))) (p))) (((times) (((times) (((mod) (n)) (p))) (((div) (m)) (p)))) (p))))) (((((((rewrite_r) (nat)) (((times) (p)) (((times) (((mod) (n)) (p))) (((div) (m)) (p))))) (fun Joker_ : nat => (((eq) (nat)) (((plus) (((times) (p)) (((plus) (((times) (p)) (((times) (((div) (n)) (p))) (((div) (m)) (p))))) (((times) (((div) (n)) (p))) (((mod) (m)) (p)))))) (Joker_))) (((plus) (((times) (((plus) (((times) (((times) (((div) (n)) (p))) (p))) (((div) (m)) (p)))) (((times) (((div) (n)) (p))) (((mod) (m)) (p))))) (p))) (((times) (((times) (((mod) (n)) (p))) (((div) (m)) (p)))) (p))))) (((((((rewrite_r) (nat)) (((times) (((div) (m)) (p))) (((mod) (n)) (p)))) (fun Joker_ : nat => (((eq) (nat)) (((plus) (((times) (p)) (((plus) (((times) (p)) (((times) (((div) (n)) (p))) (((div) (m)) (p))))) (((times) (((div) (n)) (p))) (((mod) (m)) (p)))))) (((times) (p)) (Joker_)))) (((plus) (((times) (((plus) (((times) (((times) (((div) (n)) (p))) (p))) (((div) (m)) (p)))) (((times) (((div) (n)) (p))) (((mod) (m)) (p))))) (p))) (((times) (((times) (((mod) (n)) (p))) (((div) (m)) (p)))) (p))))) (((((((rewrite_r) (nat)) (((plus) (((times) (p)) (((times) (((div) (m)) (p))) (((mod) (n)) (p))))) (((times) (p)) (((plus) (((times) (p)) (((times) (((div) (n)) (p))) (((div) (m)) (p))))) (((times) (((div) (n)) (p))) (((mod) (m)) (p))))))) (fun Joker_ : nat => (((eq) (nat)) (Joker_)) (((plus) (((times) (((plus) (((times) (((times) (((div) (n)) (p))) (p))) (((div) (m)) (p)))) (((times) (((div) (n)) (p))) (((mod) (m)) (p))))) (p))) (((times) (((times) (((mod) (n)) (p))) (((div) (m)) (p)))) (p))))) (((((((rewrite_l) (nat)) (((times) (p)) (((plus) (((times) (((div) (m)) (p))) (((mod) (n)) (p)))) (((plus) (((times) (p)) (((times) (((div) (n)) (p))) (((div) (m)) (p))))) (((times) (((div) (n)) (p))) (((mod) (m)) (p))))))) (fun Joker_ : nat => (((eq) (nat)) (Joker_)) (((plus) (((times) (((plus) (((times) (((times) (((div) (n)) (p))) (p))) (((div) (m)) (p)))) (((times) (((div) (n)) (p))) (((mod) (m)) (p))))) (p))) (((times) (((times) (((mod) (n)) (p))) (((div) (m)) (p)))) (p))))) (((((((rewrite_r) (nat)) (((plus) (((times) (p)) (((times) (((div) (n)) (p))) (((div) (m)) (p))))) (((plus) (((times) (((div) (m)) (p))) (((mod) (n)) (p)))) (((times) (((div) (n)) (p))) (((mod) (m)) (p)))))) (fun Joker_ : nat => (((eq) (nat)) (((times) (p)) (Joker_))) (((plus) (((times) (((plus) (((times) (((times) (((div) (n)) (p))) (p))) (((div) (m)) (p)))) (((times) (((div) (n)) (p))) (((mod) (m)) (p))))) (p))) (((times) (((times) (((mod) (n)) (p))) (((div) (m)) (p)))) (p))))) (((((((rewrite_r) (nat)) (((plus) (((times) (((div) (n)) (p))) (((mod) (m)) (p)))) (((times) (((div) (m)) (p))) (((mod) (n)) (p))))) (fun Joker_ : nat => (((eq) (nat)) (((times) (p)) (((plus) (((times) (p)) (((times) (((div) (n)) (p))) (((div) (m)) (p))))) (Joker_)))) (((plus) (((times) (((plus) (((times) (((times) (((div) (n)) (p))) (p))) (((div) (m)) (p)))) (((times) (((div) (n)) (p))) (((mod) (m)) (p))))) (p))) (((times) (((times) (((mod) (n)) (p))) (((div) (m)) (p)))) (p))))) (((((((rewrite_r) (nat)) (((times) (p)) (((div) (n)) (p)))) (fun Joker_ : nat => (((eq) (nat)) (((times) (p)) (((plus) (((times) (p)) (((times) (((div) (n)) (p))) (((div) (m)) (p))))) (((plus) (((times) (((div) (n)) (p))) (((mod) (m)) (p)))) (((times) (((div) (m)) (p))) (((mod) (n)) (p))))))) (((plus) (((times) (((plus) (((times) (Joker_)) (((div) (m)) (p)))) (((times) (((div) (n)) (p))) (((mod) (m)) (p))))) (p))) (((times) (((times) (((mod) (n)) (p))) (((div) (m)) (p)))) (p))))) (((((((rewrite_r) (nat)) (((times) (((div) (m)) (p))) (((times) (p)) (((div) (n)) (p))))) (fun Joker_ : nat => (((eq) (nat)) (((times) (p)) (((plus) (((times) (p)) (((times) (((div) (n)) (p))) (((div) (m)) (p))))) (((plus) (((times) (((div) (n)) (p))) (((mod) (m)) (p)))) (((times) (((div) (m)) (p))) (((mod) (n)) (p))))))) (((plus) (((times) (((plus) (Joker_)) (((times) (((div) (n)) (p))) (((mod) (m)) (p))))) (p))) (((times) (((times) (((mod) (n)) (p))) (((div) (m)) (p)))) (p))))) (((((((rewrite_r) (nat)) (((times) (p)) (((times) (((div) (m)) (p))) (((div) (n)) (p))))) (fun Joker_ : nat => (((eq) (nat)) (((times) (p)) (((plus) (((times) (p)) (((times) (((div) (n)) (p))) (((div) (m)) (p))))) (((plus) (((times) (((div) (n)) (p))) (((mod) (m)) (p)))) (((times) (((div) (m)) (p))) (((mod) (n)) (p))))))) (((plus) (((times) (((plus) (Joker_)) (((times) (((div) (n)) (p))) (((mod) (m)) (p))))) (p))) (((times) (((times) (((mod) (n)) (p))) (((div) (m)) (p)))) (p))))) (((((((rewrite_r) (nat)) (((times) (((div) (n)) (p))) (((div) (m)) (p)))) (fun Joker_ : nat => (((eq) (nat)) (((times) (p)) (((plus) (((times) (p)) (((times) (((div) (n)) (p))) (((div) (m)) (p))))) (((plus) (((times) (((div) (n)) (p))) (((mod) (m)) (p)))) (((times) (((div) (m)) (p))) (((mod) (n)) (p))))))) (((plus) (((times) (((plus) (((times) (p)) (Joker_))) (((times) (((div) (n)) (p))) (((mod) (m)) (p))))) (p))) (((times) (((times) (((mod) (n)) (p))) (((div) (m)) (p)))) (p))))) (((((((rewrite_r) (nat)) (((times) (p)) (((plus) (((times) (p)) (((times) (((div) (n)) (p))) (((div) (m)) (p))))) (((times) (((div) (n)) (p))) (((mod) (m)) (p)))))) (fun Joker_ : nat => (((eq) (nat)) (((times) (p)) (((plus) (((times) (p)) (((times) (((div) (n)) (p))) (((div) (m)) (p))))) (((plus) (((times) (((div) (n)) (p))) (((mod) (m)) (p)))) (((times) (((div) (m)) (p))) (((mod) (n)) (p))))))) (((plus) (Joker_)) (((times) (((times) (((mod) (n)) (p))) (((div) (m)) (p)))) (p))))) (((((((rewrite_r) (nat)) (((times) (((div) (m)) (p))) (((mod) (n)) (p)))) (fun Joker_ : nat => (((eq) (nat)) (((times) (p)) (((plus) (((times) (p)) (((times) (((div) (n)) (p))) (((div) (m)) (p))))) (((plus) (((times) (((div) (n)) (p))) (((mod) (m)) (p)))) (((times) (((div) (m)) (p))) (((mod) (n)) (p))))))) (((plus) (((times) (p)) (((plus) (((times) (p)) (((times) (((div) (n)) (p))) (((div) (m)) (p))))) (((times) (((div) (n)) (p))) (((mod) (m)) (p)))))) (((times) (Joker_)) (p))))) (((((((rewrite_r) (nat)) (((times) (p)) (((times) (((div) (m)) (p))) (((mod) (n)) (p))))) (fun Joker_ : nat => (((eq) (nat)) (((times) (p)) (((plus) (((times) (p)) (((times) (((div) (n)) (p))) (((div) (m)) (p))))) (((plus) (((times) (((div) (n)) (p))) (((mod) (m)) (p)))) (((times) (((div) (m)) (p))) (((mod) (n)) (p))))))) (((plus) (((times) (p)) (((plus) (((times) (p)) (((times) (((div) (n)) (p))) (((div) (m)) (p))))) (((times) (((div) (n)) (p))) (((mod) (m)) (p)))))) (Joker_)))) (((((((rewrite_r) (nat)) (((plus) (((times) (p)) (((times) (((div) (m)) (p))) (((mod) (n)) (p))))) (((times) (p)) (((plus) (((times) (p)) (((times) (((div) (n)) (p))) (((div) (m)) (p))))) (((times) (((div) (n)) (p))) (((mod) (m)) (p))))))) (fun Joker_ : nat => (((eq) (nat)) (((times) (p)) (((plus) (((times) (p)) (((times) (((div) (n)) (p))) (((div) (m)) (p))))) (((plus) (((times) (((div) (n)) (p))) (((mod) (m)) (p)))) (((times) (((div) (m)) (p))) (((mod) (n)) (p))))))) (Joker_))) (((((((rewrite_l) (nat)) (((times) (p)) (((plus) (((times) (((div) (m)) (p))) (((mod) (n)) (p)))) (((plus) (((times) (p)) (((times) (((div) (n)) (p))) (((div) (m)) (p))))) (((times) (((div) (n)) (p))) (((mod) (m)) (p))))))) (fun Joker_ : nat => (((eq) (nat)) (((times) (p)) (((plus) (((times) (p)) (((times) (((div) (n)) (p))) (((div) (m)) (p))))) (((plus) (((times) (((div) (n)) (p))) (((mod) (m)) (p)))) (((times) (((div) (m)) (p))) (((mod) (n)) (p))))))) (Joker_))) (((((((rewrite_r) (nat)) (((plus) (((times) (p)) (((times) (((div) (n)) (p))) (((div) (m)) (p))))) (((plus) (((times) (((div) (m)) (p))) (((mod) (n)) (p)))) (((times) (((div) (n)) (p))) (((mod) (m)) (p)))))) (fun Joker_ : nat => (((eq) (nat)) (((times) (p)) (((plus) (((times) (p)) (((times) (((div) (n)) (p))) (((div) (m)) (p))))) (((plus) (((times) (((div) (n)) (p))) (((mod) (m)) (p)))) (((times) (((div) (m)) (p))) (((mod) (n)) (p))))))) (((times) (p)) (Joker_)))) (((((((rewrite_r) (nat)) (((plus) (((times) (((div) (n)) (p))) (((mod) (m)) (p)))) (((times) (((div) (m)) (p))) (((mod) (n)) (p))))) (fun Joker_ : nat => (((eq) (nat)) (((times) (p)) (((plus) (((times) (p)) (((times) (((div) (n)) (p))) (((div) (m)) (p))))) (((plus) (((times) (((div) (n)) (p))) (((mod) (m)) (p)))) (((times) (((div) (m)) (p))) (((mod) (n)) (p))))))) (((times) (p)) (((plus) (((times) (p)) (((times) (((div) (n)) (p))) (((div) (m)) (p))))) (Joker_))))) (((refl) (nat)) (((times) (p)) (((plus) (((times) (p)) (((times) (((div) (n)) (p))) (((div) (m)) (p))))) (((plus) (((times) (((div) (n)) (p))) (((mod) (m)) (p)))) (((times) (((div) (m)) (p))) (((mod) (n)) (p)))))))) (((plus) (((times) (((div) (m)) (p))) (((mod) (n)) (p)))) (((times) (((div) (n)) (p))) (((mod) (m)) (p))))) (((commutative_plus) (((times) (((div) (m)) (p))) (((mod) (n)) (p)))) (((times) (((div) (n)) (p))) (((mod) (m)) (p)))))) (((plus) (((times) (((div) (m)) (p))) (((mod) (n)) (p)))) (((plus) (((times) (p)) (((times) (((div) (n)) (p))) (((div) (m)) (p))))) (((times) (((div) (n)) (p))) (((mod) (m)) (p)))))) ((((((((let_clause_73) (n)) (m)) (p)) (posp)) (((times) (((div) (m)) (p))) (((mod) (n)) (p)))) (((times) (p)) (((times) (((div) (n)) (p))) (((div) (m)) (p))))) (((times) (((div) (n)) (p))) (((mod) (m)) (p)))))) (((plus) (((times) (p)) (((times) (((div) (m)) (p))) (((mod) (n)) (p))))) (((times) (p)) (((plus) (((times) (p)) (((times) (((div) (n)) (p))) (((div) (m)) (p))))) (((times) (((div) (n)) (p))) (((mod) (m)) (p))))))) ((((distributive_times_plus) (p)) (((times) (((div) (m)) (p))) (((mod) (n)) (p)))) (((plus) (((times) (p)) (((times) (((div) (n)) (p))) (((div) (m)) (p))))) (((times) (((div) (n)) (p))) (((mod) (m)) (p))))))) (((plus) (((times) (p)) (((plus) (((times) (p)) (((times) (((div) (n)) (p))) (((div) (m)) (p))))) (((times) (((div) (n)) (p))) (((mod) (m)) (p)))))) (((times) (p)) (((times) (((div) (m)) (p))) (((mod) (n)) (p)))))) (((commutative_plus) (((times) (p)) (((plus) (((times) (p)) (((times) (((div) (n)) (p))) (((div) (m)) (p))))) (((times) (((div) (n)) (p))) (((mod) (m)) (p)))))) (((times) (p)) (((times) (((div) (m)) (p))) (((mod) (n)) (p))))))) (((times) (((times) (((div) (m)) (p))) (((mod) (n)) (p)))) (p))) (((commutative_times) (((times) (((div) (m)) (p))) (((mod) (n)) (p)))) (p)))) (((times) (((mod) (n)) (p))) (((div) (m)) (p)))) (((commutative_times) (((mod) (n)) (p))) (((div) (m)) (p))))) (((times) (((plus) (((times) (p)) (((times) (((div) (n)) (p))) (((div) (m)) (p))))) (((times) (((div) (n)) (p))) (((mod) (m)) (p))))) (p))) (((commutative_times) (((plus) (((times) (p)) (((times) (((div) (n)) (p))) (((div) (m)) (p))))) (((times) (((div) (n)) (p))) (((mod) (m)) (p))))) (p)))) (((times) (((div) (m)) (p))) (((div) (n)) (p)))) (((commutative_times) (((div) (m)) (p))) (((div) (n)) (p))))) (((times) (((div) (m)) (p))) (((times) (p)) (((div) (n)) (p))))) ((((times_times) (((div) (m)) (p))) (p)) (((div) (n)) (p))))) (((times) (((times) (p)) (((div) (n)) (p)))) (((div) (m)) (p)))) (((commutative_times) (((times) (p)) (((div) (n)) (p)))) (((div) (m)) (p))))) (((times) (((div) (n)) (p))) (p))) (((commutative_times) (((div) (n)) (p))) (p)))) (((plus) (((times) (((div) (m)) (p))) (((mod) (n)) (p)))) (((times) (((div) (n)) (p))) (((mod) (m)) (p))))) (((commutative_plus) (((times) (((div) (m)) (p))) (((mod) (n)) (p)))) (((times) (((div) (n)) (p))) (((mod) (m)) (p)))))) (((plus) (((times) (((div) (m)) (p))) (((mod) (n)) (p)))) (((plus) (((times) (p)) (((times) (((div) (n)) (p))) (((div) (m)) (p))))) (((times) (((div) (n)) (p))) (((mod) (m)) (p)))))) ((((((((let_clause_73) (n)) (m)) (p)) (posp)) (((times) (((div) (m)) (p))) (((mod) (n)) (p)))) (((times) (p)) (((times) (((div) (n)) (p))) (((div) (m)) (p))))) (((times) (((div) (n)) (p))) (((mod) (m)) (p)))))) (((plus) (((times) (p)) (((times) (((div) (m)) (p))) (((mod) (n)) (p))))) (((times) (p)) (((plus) (((times) (p)) (((times) (((div) (n)) (p))) (((div) (m)) (p))))) (((times) (((div) (n)) (p))) (((mod) (m)) (p))))))) ((((distributive_times_plus) (p)) (((times) (((div) (m)) (p))) (((mod) (n)) (p)))) (((plus) (((times) (p)) (((times) (((div) (n)) (p))) (((div) (m)) (p))))) (((times) (((div) (n)) (p))) (((mod) (m)) (p))))))) (((plus) (((times) (p)) (((plus) (((times) (p)) (((times) (((div) (n)) (p))) (((div) (m)) (p))))) (((times) (((div) (n)) (p))) (((mod) (m)) (p)))))) (((times) (p)) (((times) (((div) (m)) (p))) (((mod) (n)) (p)))))) (((commutative_plus) (((times) (p)) (((plus) (((times) (p)) (((times) (((div) (n)) (p))) (((div) (m)) (p))))) (((times) (((div) (n)) (p))) (((mod) (m)) (p)))))) (((times) (p)) (((times) (((div) (m)) (p))) (((mod) (n)) (p))))))) (((times) (((mod) (n)) (p))) (((div) (m)) (p)))) (((commutative_times) (((mod) (n)) (p))) (((div) (m)) (p))))) (((times) (((mod) (n)) (p))) (((times) (p)) (((div) (m)) (p))))) ((((times_times) (((mod) (n)) (p))) (p)) (((div) (m)) (p))))) (((times) (((div) (m)) (p))) (p))) (((commutative_times) (((div) (m)) (p))) (p)))) (((plus) (((times) (p)) (((times) (p)) (((times) (((div) (n)) (p))) (((div) (m)) (p)))))) (((times) (p)) (((times) (((div) (n)) (p))) (((mod) (m)) (p)))))) ((((distributive_times_plus) (p)) (((times) (p)) (((times) (((div) (n)) (p))) (((div) (m)) (p))))) (((times) (((div) (n)) (p))) (((mod) (m)) (p)))))) (((times) (((times) (((div) (n)) (p))) (((mod) (m)) (p)))) (p))) (((commutative_times) (((times) (((div) (n)) (p))) (((mod) (m)) (p)))) (p)))) (((times) (((times) (p)) (((times) (((div) (n)) (p))) (((div) (m)) (p))))) (p))) (((commutative_times) (((times) (p)) (((times) (((div) (n)) (p))) (((div) (m)) (p))))) (p)))) (((times) (((div) (m)) (p))) (((div) (n)) (p)))) (((commutative_times) (((div) (m)) (p))) (((div) (n)) (p))))) (((times) (((div) (m)) (p))) (((times) (p)) (((div) (n)) (p))))) ((((times_times) (((div) (m)) (p))) (p)) (((div) (n)) (p))))) (((times) (((times) (p)) (((div) (n)) (p)))) (((div) (m)) (p)))) (((commutative_times) (((times) (p)) (((div) (n)) (p)))) (((div) (m)) (p))))) (((times) (((div) (n)) (p))) (p))) (((commutative_times) (((div) (n)) (p))) (p)))) (((times) (((plus) (((plus) (((times) (((times) (((div) (n)) (p))) (p))) (((div) (m)) (p)))) (((times) (((div) (n)) (p))) (((mod) (m)) (p))))) (((times) (((mod) (n)) (p))) (((div) (m)) (p))))) (p))) ((((distributive_times_plus_r) (p)) (((plus) (((times) (((times) (((div) (n)) (p))) (p))) (((div) (m)) (p)))) (((times) (((div) (n)) (p))) (((mod) (m)) (p))))) (((times) (((mod) (n)) (p))) (((div) (m)) (p)))))) (((times) (((div) (n)) (p))) (((times) (((mod) (m)) (p))) (p)))) ((((associative_times) (((div) (n)) (p))) (((mod) (m)) (p))) (p)))) (((times) (p)) (((mod) (m)) (p)))) (((commutative_times) (p)) (((mod) (m)) (p))))) (((times) (((times) (((div) (n)) (p))) (p))) (((mod) (m)) (p)))) ((((associative_times) (((div) (n)) (p))) (p)) (((mod) (m)) (p))))) (((times) (((times) (((div) (n)) (p))) (p))) (((times) (((div) (m)) (p))) (p)))) ((((associative_times) (((times) (((div) (n)) (p))) (p))) (((div) (m)) (p))) (p)))) (((refl) (nat)) (((times) (((mod) (n)) (p))) (((mod) (m)) (p))))))).
Definition congruent_times : forall n : nat, forall m : nat, forall n1 : nat, forall m1 : nat, forall p : nat, (((lt) (O)) (p)) -> ((((congruent) (n)) (n1)) (p)) -> ((((congruent) (m)) (m1)) (p)) -> (((congruent) (((times) (n)) (m))) (((times) (n1)) (m1))) (p) := fun n : nat => fun m : nat => fun n1 : nat => fun m1 : nat => fun p : nat => fun posp : ((lt) (O)) (p) => fun Hcongn : (((congruent) (n)) (n1)) (p) => fun Hcongm : (((congruent) (m)) (m1)) (p) => ((((((eq_ind_r) (nat)) (((mod) (((times) (((mod) (n)) (p))) (((mod) (m)) (p)))) (p))) (fun x : nat => (((eq) (nat)) (x)) (((mod) (((times) (n1)) (m1))) (p)))) (((((((eq_ind_r) (nat)) (((mod) (n1)) (p))) (fun x : nat => (((eq) (nat)) (((mod) (((times) (x)) (((mod) (m)) (p)))) (p))) (((mod) (((times) (n1)) (m1))) (p)))) (((((((eq_ind_r) (nat)) (((mod) (m1)) (p))) (fun x : nat => (((eq) (nat)) (((mod) (((times) (((mod) (n1)) (p))) (x))) (p))) (((mod) (((times) (n1)) (m1))) (p)))) (((((sym_eq) (nat)) (((mod) (((times) (n1)) (m1))) (p))) (((mod) (((times) (((mod) (n1)) (p))) (((mod) (m1)) (p)))) (p))) (((((mod_times) (n1)) (m1)) (p)) (posp)))) (((mod) (m)) (p))) (Hcongm))) (((mod) (n)) (p))) (Hcongn))) (((mod) (((times) (n)) (m))) (p))) (((((mod_times) (n)) (m)) (p)) (posp)).
Parameter fact : (nat) -> nat.
Parameter fact_body : (nat) -> nat.
Axiom eq_fact : forall n : nat, (((leibniz) (nat)) ((fact) (n))) ((((filter_nat_type) (nat)) (fact_body)) (n)).
Definition sym_eq_fact : forall n : nat, (((leibniz) (nat)) ((((filter_nat_type) (nat)) (fact_body)) (n))) ((fact) (n)) := fun n : nat => ((((sym_leibniz) (nat)) ((fact) (n))) ((((filter_nat_type) (nat)) (fact_body)) (n))) ((eq_fact) (n)).
Axiom eq_fact_body_O : (((leibniz) (nat)) ((fact_body) (O))) ((S) (O)).
Definition sym_eq_fact_body_O : (((leibniz) (nat)) ((S) (O))) ((fact_body) (O)) := ((((sym_leibniz) (nat)) ((fact_body) (O))) ((S) (O))) (eq_fact_body_O).
Axiom eq_fact_body_S : forall n : nat, (((leibniz) (nat)) ((fact_body) ((S) (n)))) (((times) ((fact) (n))) ((S) (n))).
Definition sym_eq_fact_body_S : forall n : nat, (((leibniz) (nat)) (((times) ((fact) (n))) ((S) (n)))) ((fact_body) ((S) (n))) := fun n : nat => ((((sym_leibniz) (nat)) ((fact_body) ((S) (n)))) (((times) ((fact) (n))) ((S) (n)))) ((eq_fact_body_S) (n)).
Definition prime_to_not_divides_fact : forall p : nat, ((prime) (p)) -> forall n : nat, (((lt) (n)) (p)) -> (Not) (((divides) (p)) ((fact) (n))) := fun p : nat => fun primep : (prime) (p) => fun n : nat => ((((nat_ind) (fun Jokerx_365 : nat => (((lt) (Jokerx_365)) (p)) -> (Not) (((divides) (p)) ((fact) (Jokerx_365))))) ((((sym_eq_fact) (O)) (fun y : nat => (((lt) (O)) (p)) -> (Not) (((divides) (p)) (y)))) (((((sym_eq_filter_nat_type_O) (nat)) (fact_body)) (fun y : nat => (((lt) (O)) (p)) -> (Not) (((divides) (p)) (y)))) (((sym_eq_fact_body_O) (fun y : nat => (((lt) (O)) (p)) -> (Not) (((divides) (p)) (y)))) (fun Joker_ : ((le) ((S) (O))) (p) => fun divp : ((divides) (p)) ((S) (O)) => (((absurd) (((le) (p)) ((S) (O)))) (((((divides_to_le) (p)) ((S) (O))) ((lt_O_S) (O))) (divp))) ((((lt_to_not_le) ((S) (O))) (p)) (((prime_to_lt_SO) (p)) (primep)))))))) (fun n1 : nat => (((sym_eq_fact) ((S) (n1))) (fun y : nat => ((((lt) (n1)) (p)) -> (Not) (((divides) (p)) ((fact) (n1)))) -> (((lt) ((S) (n1))) (p)) -> (Not) (((divides) (p)) (y)))) ((((((sym_eq_filter_nat_type_S) (nat)) (fact_body)) (n1)) (fun y : nat => ((((lt) (n1)) (p)) -> (Not) (((divides) (p)) ((fact) (n1)))) -> (((lt) ((S) (n1))) (p)) -> (Not) (((divides) (p)) (y)))) ((((sym_eq_fact_body_S) (n1)) (fun y : nat => ((((lt) (n1)) (p)) -> (Not) (((divides) (p)) ((fact) (n1)))) -> (((lt) ((S) (n1))) (p)) -> (Not) (((divides) (p)) (y)))) (fun Hind : (((lt) (n1)) (p)) -> (Not) (((divides) (p)) ((fact) (n1))) => fun ltn1 : ((lt) ((S) (n1))) (p) => fun Hdiv : ((divides) (p)) (((times) ((fact) (n1))) ((S) (n1))) => ((((((match_Or_prop) (((divides) (p)) ((fact) (n1)))) (((divides) (p)) ((S) (n1)))) (False)) (fun Hdiv0 : ((divides) (p)) ((fact) (n1)) => (((absurd) (((divides) (p)) ((fact) (n1)))) (Hdiv0)) ((Hind) ((((lt_to_le) ((S) (n1))) (p)) (ltn1))))) (fun Hdiv0 : ((divides) (p)) ((S) (n1)) => (((absurd) (((le) (p)) ((S) (n1)))) (((((divides_to_le) (p)) ((S) (n1))) ((lt_O_S) (n1))) (Hdiv0))) ((((lt_to_not_le) ((S) (n1))) (p)) (ltn1)))) ((((((divides_times_to_divides) (p)) ((fact) (n1))) ((S) (n1))) (primep)) (Hdiv))))))) (n).
Definition permut_mod : forall p : nat, forall a : nat, ((prime) (p)) -> ((Not) (((divides) (p)) (a))) -> ((permut) (fun n : nat => ((mod) (((times) (a)) (n))) (p))) ((pred) (p)) := fun p : nat => fun a : nat => fun primep : (prime) (p) => fun ndiv : (Not) (((divides) (p)) (a)) => fun z : Prop => fun f : (forall x : nat, (((le) (x)) ((pred) (p))) -> ((le) (((mod) (((times) (a)) (x))) (p))) ((pred) (p))) -> (((injn) (fun n : nat => ((mod) (((times) (a)) (n))) (p))) ((pred) (p))) -> z => ((f) (fun i : nat => fun lei : ((le) (i)) ((pred) (p)) => (((le_S_S_to_le) (((mod) (((times) (a)) (i))) (p))) ((pred) (p))) ((((((transitive_le) ((S) (((mod) (((times) (a)) (i))) (p)))) (p)) ((S) ((pred) (p)))) ((((lt_mod_m_m) (((times) (a)) (i))) (p)) (((prime_to_lt_O) (p)) (primep)))) (((((((eq_ind_r) (nat)) (p)) (fun x : nat => ((le) (p)) (x))) ((le_n) (p))) ((S) ((pred) (p)))) (((S_pred) (p)) (((prime_to_lt_O) (p)) (primep))))))) (fun i : nat => fun j : nat => fun lei : ((le) (i)) ((pred) (p)) => fun lej : ((le) (j)) ((pred) (p)) => fun H : (((eq) (nat)) (((mod) (((times) (a)) (i))) (p))) (((mod) (((times) (a)) (j))) (p)) => ((((((match_Or_prop) (((lt) (i)) (j))) ((Not) (((lt) (i)) (j)))) ((((eq) (nat)) (i)) (j))) (fun ltij : ((lt) (i)) (j) => ((falsity) ((((eq) (nat)) (i)) (j))) ((((absurd) (((lt) (((minus) (j)) (i))) (p))) (((((((eq_ind) (nat)) ((S) ((pred) (p)))) (fun x_1 : nat => ((lt) (((minus) (j)) (i))) (x_1))) ((((le_S_S) (((minus) (j)) (i))) ((pred) (p))) (((((le_plus_to_minus) (j)) (i)) ((pred) (p))) ((((((transitive_le) (j)) ((pred) (p))) (((plus) ((pred) (p))) (i))) (lej)) (((le_plus_n_r) (i)) ((pred) (p))))))) (p)) (((S_pred) (p)) (((prime_to_lt_O) (p)) (primep))))) ((((le_to_not_lt) (p)) (((minus) (j)) (i))) (((((divides_to_le) (p)) (((minus) (j)) (i))) (((((lt_plus_to_minus_r) (O)) (i)) (j)) ((((sym_eq_plus) (O)) (fun y : (nat) -> nat => ((le) ((S) ((y) (i)))) (j))) (((((sym_eq_filter_nat_type_O) ((nat) -> nat)) (plus_body)) (fun y : (nat) -> nat => ((le) ((S) ((y) (i)))) (j))) (((sym_eq_plus_body_O) (fun y : (nat) -> nat => ((le) ((S) ((y) (i)))) (j))) (ltij)))))) (((((((match_Or_prop) (((divides) (p)) (a))) (((divides) (p)) (((minus) (j)) (i)))) (((divides) (p)) (((minus) (j)) (i)))) (fun Hdiv : ((divides) (p)) (a) => ((falsity) (((divides) (p)) (((minus) (j)) (i)))) ((((absurd) (((divides) (p)) (a))) (Hdiv)) (ndiv)))) (fun auto : ((divides) (p)) (((minus) (j)) (i)) => auto)) ((((((divides_times_to_divides) (p)) (a)) (((minus) (j)) (i))) (primep)) (((((((eq_ind_r) (nat)) (((minus) (((times) (a)) (j))) (((times) (a)) (i)))) (fun x : nat => ((divides) (p)) (x))) ((((((eq_mod_to_divides) (((times) (a)) (j))) (((times) (a)) (i))) (p)) (((prime_to_lt_O) (p)) (primep))) (((((((rewrite_l) (nat)) (((mod) (((times) (a)) (i))) (p))) (fun Joker_ : nat => (((eq) (nat)) (Joker_)) (((mod) (((times) (a)) (i))) (p)))) (((refl) (nat)) (((mod) (((times) (a)) (i))) (p)))) (((mod) (((times) (a)) (j))) (p))) (H)))) (((times) (a)) (((minus) (j)) (i)))) ((((distributive_times_minus) (a)) (j)) (i)))))))))) (fun Hij : (Not) (((lt) (i)) (j)) => ((((((match_Or_prop) (((lt) (j)) (i))) ((((eq) (nat)) (j)) (i))) ((((eq) (nat)) (i)) (j))) (fun Hij0 : ((lt) (j)) (i) => ((falsity) ((((eq) (nat)) (i)) (j))) ((((absurd) (((lt) (((minus) (i)) (j))) (p))) (((((((eq_ind) (nat)) ((S) ((pred) (p)))) (fun x_1 : nat => ((lt) (((minus) (i)) (j))) (x_1))) ((((le_S_S) (((minus) (i)) (j))) ((pred) (p))) (((((le_plus_to_minus) (i)) (j)) ((pred) (p))) ((((((transitive_le) (i)) ((pred) (p))) (((plus) ((pred) (p))) (j))) (lei)) (((le_plus_n_r) (j)) ((pred) (p))))))) (p)) (((S_pred) (p)) (((prime_to_lt_O) (p)) (primep))))) ((((le_to_not_lt) (p)) (((minus) (i)) (j))) (((((divides_to_le) (p)) (((minus) (i)) (j))) (((((lt_plus_to_minus_r) (O)) (j)) (i)) ((((sym_eq_plus) (O)) (fun y : (nat) -> nat => ((le) ((S) ((y) (j)))) (i))) (((((sym_eq_filter_nat_type_O) ((nat) -> nat)) (plus_body)) (fun y : (nat) -> nat => ((le) ((S) ((y) (j)))) (i))) (((sym_eq_plus_body_O) (fun y : (nat) -> nat => ((le) ((S) ((y) (j)))) (i))) (Hij0)))))) (((((((match_Or_prop) (((divides) (p)) (a))) (((divides) (p)) (((minus) (i)) (j)))) (((divides) (p)) (((minus) (i)) (j)))) (fun Hdiv : ((divides) (p)) (a) => ((falsity) (((divides) (p)) (((minus) (i)) (j)))) ((((absurd) (((divides) (p)) (a))) (Hdiv)) (ndiv)))) (fun auto : ((divides) (p)) (((minus) (i)) (j)) => auto)) ((((((divides_times_to_divides) (p)) (a)) (((minus) (i)) (j))) (primep)) (((((((eq_ind_r) (nat)) (((minus) (((times) (a)) (i))) (((times) (a)) (j)))) (fun x : nat => ((divides) (p)) (x))) ((((((eq_mod_to_divides) (((times) (a)) (i))) (((times) (a)) (j))) (p)) (((prime_to_lt_O) (p)) (primep))) (((((((rewrite_l) (nat)) (((mod) (((times) (a)) (i))) (p))) (fun Joker_ : nat => (((eq) (nat)) (((mod) (((times) (a)) (i))) (p))) (Joker_))) (((refl) (nat)) (((mod) (((times) (a)) (i))) (p)))) (((mod) (((times) (a)) (j))) (p))) (H)))) (((times) (a)) (((minus) (i)) (j)))) ((((distributive_times_minus) (a)) (i)) (j)))))))))) (fun Hij0 : (((eq) (nat)) (j)) (i) => ((((((rewrite_r) (nat)) (i)) (fun Joker_ : nat => (((eq) (nat)) (i)) (Joker_))) (((refl) (nat)) (i))) (j)) (Hij0))) ((((le_to_or_lt_eq) (j)) (i)) ((((not_lt_to_le) (i)) (j)) (Hij))))) (((decidable_lt) (i)) (j))).
Definition eq_fact_pi_p : forall n : nat, (((eq) (nat)) ((fact) (n))) (((((((bigop) (nat)) (((minus) ((S) (n))) ((S) (O)))) (fun i : nat => true)) ((S) (O))) (times)) (fun i : nat => ((plus) (i)) ((S) (O)))) := fun n : nat => ((((nat_ind) (fun Jokerx_365 : nat => (((eq) (nat)) ((fact) (Jokerx_365))) (((((((bigop) (nat)) (((minus) ((S) (Jokerx_365))) ((S) (O)))) (fun i : nat => true)) ((S) (O))) (times)) (fun i : nat => ((plus) (i)) ((S) (O)))))) ((((sym_eq_minus) ((S) (O))) (fun y : (nat) -> nat => (((eq) (nat)) ((fact) (O))) (((((((bigop) (nat)) ((y) ((S) (O)))) (fun i : nat => true)) ((S) (O))) (times)) (fun i : nat => ((plus) (i)) ((S) (O)))))) ((((((sym_eq_filter_nat_type_S) ((nat) -> nat)) (minus_body)) (O)) (fun y : (nat) -> nat => (((eq) (nat)) ((fact) (O))) (((((((bigop) (nat)) ((y) ((S) (O)))) (fun i : nat => true)) ((S) (O))) (times)) (fun i : nat => ((plus) (i)) ((S) (O)))))) ((((sym_eq_minus_body_S) (O)) (fun y : (nat) -> nat => (((eq) (nat)) ((fact) (O))) (((((((bigop) (nat)) ((y) ((S) (O)))) (fun i : nat => true)) ((S) (O))) (times)) (fun i : nat => ((plus) (i)) ((S) (O)))))) (((((((sym_eq_match_nat_type_S) (nat)) ((S) (O))) (fun q : nat => ((minus) (O)) (q))) (O)) (fun y : nat => (((eq) (nat)) ((fact) (O))) (((((((bigop) (nat)) (y)) (fun i : nat => true)) ((S) (O))) (times)) (fun i : nat => ((plus) (i)) ((S) (O)))))) ((((sym_eq_minus) (O)) (fun y : (nat) -> nat => (((eq) (nat)) ((fact) (O))) (((((((bigop) (nat)) ((y) (O))) (fun i : nat => true)) ((S) (O))) (times)) (fun i : nat => ((plus) (i)) ((S) (O)))))) (((((sym_eq_filter_nat_type_O) ((nat) -> nat)) (minus_body)) (fun y : (nat) -> nat => (((eq) (nat)) ((fact) (O))) (((((((bigop) (nat)) ((y) (O))) (fun i : nat => true)) ((S) (O))) (times)) (fun i : nat => ((plus) (i)) ((S) (O)))))) (((sym_eq_minus_body_O) (fun y : (nat) -> nat => (((eq) (nat)) ((fact) (O))) (((((((bigop) (nat)) ((y) (O))) (fun i : nat => true)) ((S) (O))) (times)) (fun i : nat => ((plus) (i)) ((S) (O)))))) ((((sym_eq_bigop_O) (nat)) (fun y : ((nat) -> bool) -> (nat) -> ((nat) -> (nat) -> nat) -> ((nat) -> nat) -> nat => (((eq) (nat)) ((fact) (O))) (((((y) (fun i : nat => true)) ((S) (O))) (times)) (fun i : nat => ((plus) (i)) ((S) (O)))))) ((((sym_eq_bigop_body_O) (nat)) (fun y : ((nat) -> bool) -> (nat) -> ((nat) -> (nat) -> nat) -> ((nat) -> nat) -> nat => (((eq) (nat)) ((fact) (O))) (((((y) (fun i : nat => true)) ((S) (O))) (times)) (fun i : nat => ((plus) (i)) ((S) (O)))))) (((eq_fact_body_O) (fun y : nat => (((eq) (nat)) ((fact) (O))) (y))) (((((eq_filter_nat_type_O) (nat)) (fact_body)) (fun y : nat => (((eq) (nat)) ((fact) (O))) (y))) ((((eq_fact) (O)) (fun y : nat => (((eq) (nat)) ((fact) (O))) (y))) (((refl) (nat)) ((fact) (O)))))))))))))))) (fun n1 : nat => (((sym_eq_fact) ((S) (n1))) (fun y : nat => ((((eq) (nat)) ((fact) (n1))) (((((((bigop) (nat)) (((minus) ((S) (n1))) ((S) (O)))) (fun i : nat => true)) ((S) (O))) (times)) (fun i : nat => ((plus) (i)) ((S) (O))))) -> (((eq) (nat)) (y)) (((((((bigop) (nat)) (((minus) ((S) ((S) (n1)))) ((S) (O)))) (fun i : nat => true)) ((S) (O))) (times)) (fun i : nat => ((plus) (i)) ((S) (O)))))) ((((((sym_eq_filter_nat_type_S) (nat)) (fact_body)) (n1)) (fun y : nat => ((((eq) (nat)) ((fact) (n1))) (((((((bigop) (nat)) (((minus) ((S) (n1))) ((S) (O)))) (fun i : nat => true)) ((S) (O))) (times)) (fun i : nat => ((plus) (i)) ((S) (O))))) -> (((eq) (nat)) (y)) (((((((bigop) (nat)) (((minus) ((S) ((S) (n1)))) ((S) (O)))) (fun i : nat => true)) ((S) (O))) (times)) (fun i : nat => ((plus) (i)) ((S) (O)))))) ((((sym_eq_fact_body_S) (n1)) (fun y : nat => ((((eq) (nat)) ((fact) (n1))) (((((((bigop) (nat)) (((minus) ((S) (n1))) ((S) (O)))) (fun i : nat => true)) ((S) (O))) (times)) (fun i : nat => ((plus) (i)) ((S) (O))))) -> (((eq) (nat)) (y)) (((((((bigop) (nat)) (((minus) ((S) ((S) (n1)))) ((S) (O)))) (fun i : nat => true)) ((S) (O))) (times)) (fun i : nat => ((plus) (i)) ((S) (O)))))) (fun Hind : (((eq) (nat)) ((fact) (n1))) (((((((bigop) (nat)) (((minus) ((S) (n1))) ((S) (O)))) (fun i : nat => true)) ((S) (O))) (times)) (fun i : nat => ((plus) (i)) ((S) (O)))) => ((((((eq_ind_r) (nat)) (((times) ((S) (n1))) ((fact) (n1)))) (fun x : nat => (((eq) (nat)) (x)) (((((((bigop) (nat)) (((minus) ((S) ((S) (n1)))) ((S) (O)))) (fun i : nat => true)) ((S) (O))) (times)) (fun i : nat => ((plus) (i)) ((S) (O)))))) ((((sym_eq_minus) ((S) ((S) (n1)))) (fun y : (nat) -> nat => (((eq) (nat)) (((times) ((S) (n1))) ((fact) (n1)))) (((((((bigop) (nat)) ((y) ((S) (O)))) (fun i : nat => true)) ((S) (O))) (times)) (fun i : nat => ((plus) (i)) ((S) (O)))))) ((((((sym_eq_filter_nat_type_S) ((nat) -> nat)) (minus_body)) ((S) (n1))) (fun y : (nat) -> nat => (((eq) (nat)) (((times) ((S) (n1))) ((fact) (n1)))) (((((((bigop) (nat)) ((y) ((S) (O)))) (fun i : nat => true)) ((S) (O))) (times)) (fun i : nat => ((plus) (i)) ((S) (O)))))) ((((sym_eq_minus_body_S) ((S) (n1))) (fun y : (nat) -> nat => (((eq) (nat)) (((times) ((S) (n1))) ((fact) (n1)))) (((((((bigop) (nat)) ((y) ((S) (O)))) (fun i : nat => true)) ((S) (O))) (times)) (fun i : nat => ((plus) (i)) ((S) (O)))))) (((((((sym_eq_match_nat_type_S) (nat)) ((S) ((S) (n1)))) (fun q : nat => ((minus) ((S) (n1))) (q))) (O)) (fun y : nat => (((eq) (nat)) (((times) ((S) (n1))) ((fact) (n1)))) (((((((bigop) (nat)) (y)) (fun i : nat => true)) ((S) (O))) (times)) (fun i : nat => ((plus) (i)) ((S) (O)))))) ((((sym_eq_minus) ((S) (n1))) (fun y : (nat) -> nat => (((eq) (nat)) (((times) ((S) (n1))) ((fact) (n1)))) (((((((bigop) (nat)) ((y) (O))) (fun i : nat => true)) ((S) (O))) (times)) (fun i : nat => ((plus) (i)) ((S) (O)))))) ((((((sym_eq_filter_nat_type_S) ((nat) -> nat)) (minus_body)) (n1)) (fun y : (nat) -> nat => (((eq) (nat)) (((times) ((S) (n1))) ((fact) (n1)))) (((((((bigop) (nat)) ((y) (O))) (fun i : nat => true)) ((S) (O))) (times)) (fun i : nat => ((plus) (i)) ((S) (O)))))) ((((sym_eq_minus_body_S) (n1)) (fun y : (nat) -> nat => (((eq) (nat)) (((times) ((S) (n1))) ((fact) (n1)))) (((((((bigop) (nat)) ((y) (O))) (fun i : nat => true)) ((S) (O))) (times)) (fun i : nat => ((plus) (i)) ((S) (O)))))) ((((((sym_eq_match_nat_type_O) (nat)) ((S) (n1))) (fun q : nat => ((minus) (n1)) (q))) (fun y : nat => (((eq) (nat)) (((times) ((S) (n1))) ((fact) (n1)))) (((((((bigop) (nat)) (y)) (fun i : nat => true)) ((S) (O))) (times)) (fun i : nat => ((plus) (i)) ((S) (O)))))) (((((((eq_ind_r) (nat)) (((times) (((plus) (n1)) ((S) (O)))) (((((((bigop) (nat)) (n1)) (fun i : nat => true)) ((S) (O))) (times)) (fun i : nat => ((plus) (i)) ((S) (O)))))) (fun x : nat => (((eq) (nat)) (((times) ((S) (n1))) ((fact) (n1)))) (x))) (((((((eq_ind) (nat)) ((S) (((plus) (n1)) (O)))) (fun x_1 : nat => (((eq) (nat)) (((times) ((S) (n1))) ((fact) (n1)))) (((times) (x_1)) (((((((bigop) (nat)) (n1)) (fun i : nat => true)) ((S) (O))) (times)) (fun i : nat => ((plus) (i)) ((S) (O))))))) (((((((eq_ind) (nat)) (n1)) (fun x_1 : nat => (((eq) (nat)) (((times) ((S) (n1))) ((fact) (n1)))) (((times) ((S) (x_1))) (((((((bigop) (nat)) (n1)) (fun i : nat => true)) ((S) (O))) (times)) (fun i : nat => ((plus) (i)) ((S) (O))))))) (((((((eq_f) (nat)) (nat)) ((times) ((S) (n1)))) ((fact) (n1))) (((((((bigop) (nat)) (n1)) (fun i : nat => true)) ((S) (O))) (times)) (fun i : nat => ((plus) (i)) ((S) (O))))) (((((((eq_ind) (nat)) (((minus) ((S) (n1))) ((S) (O)))) (fun x_1 : nat => (((eq) (nat)) ((fact) (n1))) (((((((bigop) (nat)) (x_1)) (fun i : nat => true)) ((S) (O))) (times)) (fun i : nat => ((plus) (i)) ((S) (O)))))) (Hind)) (n1)) ((((sym_eq_minus) ((S) (n1))) (fun y : (nat) -> nat => (((eq) (nat)) ((y) ((S) (O)))) (n1))) ((((((sym_eq_filter_nat_type_S) ((nat) -> nat)) (minus_body)) (n1)) (fun y : (nat) -> nat => (((eq) (nat)) ((y) ((S) (O)))) (n1))) ((((sym_eq_minus_body_S) (n1)) (fun y : (nat) -> nat => (((eq) (nat)) ((y) ((S) (O)))) (n1))) (((((((sym_eq_match_nat_type_S) (nat)) ((S) (n1))) (fun q : nat => ((minus) (n1)) (q))) (O)) (fun y : nat => (((eq) (nat)) (y)) (n1))) (((((((rewrite_l) (nat)) (n1)) (fun Joker_ : nat => (((eq) (nat)) (Joker_)) (n1))) (((refl) (nat)) (n1))) (((minus) (n1)) (O))) ((minus_n_O) (n1)))))))))) (((plus) (n1)) (O))) ((plus_n_O) (n1)))) (((plus) (n1)) ((S) (O)))) (((plus_n_Sm) (n1)) (O)))) (((((((bigop) (nat)) ((S) (n1))) (fun i : nat => true)) ((S) (O))) (times)) (fun i : nat => ((plus) (i)) ((S) (O))))) ((((((((bigop_Strue) (nat)) (n1)) (fun Joker_ : nat => true)) ((S) (O))) (times)) (fun Joker_ : nat => ((plus) (Joker_)) ((S) (O)))) (((refl) (bool)) (true))))))))))))) (((times) ((fact) (n1))) ((S) (n1)))) (((commutative_times) ((fact) (n1))) ((S) (n1)))))))) (n).
Definition congruent_pi : forall f : (nat) -> nat, forall n : nat, forall p : nat, (((lt) (O)) (p)) -> (((congruent) (((((((bigop) (nat)) (n)) (fun i : nat => true)) ((S) (O))) (times)) (fun i : nat => (f) (i)))) (((((((bigop) (nat)) (n)) (fun i : nat => true)) ((S) (O))) (times)) (fun i : nat => ((mod) ((f) (i))) (p)))) (p) := fun f : (nat) -> nat => fun n : nat => ((((nat_ind) (fun Jokerx_365 : nat => forall p : nat, (((lt) (O)) (p)) -> (((congruent) (((((((bigop) (nat)) (Jokerx_365)) (fun i : nat => true)) ((S) (O))) (times)) (fun i : nat => (f) (i)))) (((((((bigop) (nat)) (Jokerx_365)) (fun i : nat => true)) ((S) (O))) (times)) (fun i : nat => ((mod) ((f) (i))) (p)))) (p))) (fun p : nat => (((sym_eq_bigop_O) (nat)) (fun y : ((nat) -> bool) -> (nat) -> ((nat) -> (nat) -> nat) -> ((nat) -> nat) -> nat => (((lt) (O)) (p)) -> (((congruent) (((((((bigop) (nat)) (O)) (fun i : nat => true)) ((S) (O))) (times)) (fun i : nat => (f) (i)))) (((((y) (fun i : nat => true)) ((S) (O))) (times)) (fun i : nat => ((mod) ((f) (i))) (p)))) (p))) ((((sym_eq_bigop_body_O) (nat)) (fun y : ((nat) -> bool) -> (nat) -> ((nat) -> (nat) -> nat) -> ((nat) -> nat) -> nat => (((lt) (O)) (p)) -> (((congruent) (((((((bigop) (nat)) (O)) (fun i : nat => true)) ((S) (O))) (times)) (fun i : nat => (f) (i)))) (((((y) (fun i : nat => true)) ((S) (O))) (times)) (fun i : nat => ((mod) ((f) (i))) (p)))) (p))) ((((eq_bigop_body_O) (nat)) (fun y : ((nat) -> bool) -> (nat) -> ((nat) -> (nat) -> nat) -> ((nat) -> nat) -> nat => (((lt) (O)) (p)) -> (((congruent) (((((((bigop) (nat)) (O)) (fun i : nat => true)) ((S) (O))) (times)) (fun i : nat => (f) (i)))) (((((y) (fun i : nat => true)) ((S) (O))) (times)) (fun i : nat => (f) (i)))) (p))) ((((eq_bigop_O) (nat)) (fun y : ((nat) -> bool) -> (nat) -> ((nat) -> (nat) -> nat) -> ((nat) -> nat) -> nat => (((lt) (O)) (p)) -> (((congruent) (((((((bigop) (nat)) (O)) (fun i : nat => true)) ((S) (O))) (times)) (fun i : nat => (f) (i)))) (((((y) (fun i : nat => true)) ((S) (O))) (times)) (fun i : nat => (f) (i)))) (p))) (fun auto : ((lt) (O)) (p) => ((congruent_n_n) (((((((bigop) (nat)) (O)) (fun i : nat => true)) ((S) (O))) (times)) (fun i : nat => (f) (i)))) (p))))))) (fun n1 : nat => fun Hind : forall p : nat, (((lt) (O)) (p)) -> (((congruent) (((((((bigop) (nat)) (n1)) (fun i : nat => true)) ((S) (O))) (times)) (fun i : nat => (f) (i)))) (((((((bigop) (nat)) (n1)) (fun i : nat => true)) ((S) (O))) (times)) (fun i : nat => ((mod) ((f) (i))) (p)))) (p) => fun p : nat => fun posp : ((lt) (O)) (p) => ((((((eq_ind_r) (nat)) (((times) ((f) (n1))) (((((((bigop) (nat)) (n1)) (fun i : nat => true)) ((S) (O))) (times)) (fun i : nat => (f) (i))))) (fun x : nat => (((congruent) (x)) (((((((bigop) (nat)) ((S) (n1))) (fun i : nat => true)) ((S) (O))) (times)) (fun i : nat => ((mod) ((f) (i))) (p)))) (p))) (((((sym_eq_bigop_S) (nat)) (n1)) (fun y : ((nat) -> bool) -> (nat) -> ((nat) -> (nat) -> nat) -> ((nat) -> nat) -> nat => (((congruent) (((times) ((f) (n1))) (((((((bigop) (nat)) (n1)) (fun i : nat => true)) ((S) (O))) (times)) (fun i : nat => (f) (i))))) (((((y) (fun i : nat => true)) ((S) (O))) (times)) (fun i : nat => ((mod) ((f) (i))) (p)))) (p))) (((((sym_eq_bigop_body_S) (nat)) (n1)) (fun y : ((nat) -> bool) -> (nat) -> ((nat) -> (nat) -> nat) -> ((nat) -> nat) -> nat => (((congruent) (((times) ((f) (n1))) (((((((bigop) (nat)) (n1)) (fun i : nat => true)) ((S) (O))) (times)) (fun i : nat => (f) (i))))) (((((y) (fun i : nat => true)) ((S) (O))) (times)) (fun i : nat => ((mod) ((f) (i))) (p)))) (p))) ((((((sym_eq_match_bool_type_true) (nat)) (((times) (((mod) ((f) (n1))) (p))) (((((((bigop) (nat)) (n1)) (fun i : nat => true)) ((S) (O))) (times)) (fun i : nat => ((mod) ((f) (i))) (p))))) (((((((bigop) (nat)) (n1)) (fun i : nat => true)) ((S) (O))) (times)) (fun i : nat => ((mod) ((f) (i))) (p)))) (fun y : nat => (((congruent) (((times) ((f) (n1))) (((((((bigop) (nat)) (n1)) (fun i : nat => true)) ((S) (O))) (times)) (fun i : nat => (f) (i))))) (y)) (p))) (((((((((congruent_times) ((f) (n1))) (((((((bigop) (nat)) (n1)) (fun i : nat => true)) ((S) (O))) (times)) (fun i : nat => (f) (i)))) (((mod) ((f) (n1))) (p))) (((((((bigop) (nat)) (n1)) (fun i : nat => true)) ((S) (O))) (times)) (fun i : nat => ((mod) ((f) (i))) (p)))) (p)) (posp)) ((((congruent_n_mod_n) ((f) (n1))) (p)) (posp))) (((Hind) (p)) (posp))))))) (((((((bigop) (nat)) ((S) (n1))) (fun i : nat => true)) ((S) (O))) (times)) (fun i : nat => (f) (i)))) ((((((((bigop_Strue) (nat)) (n1)) (fun Joker_ : nat => true)) ((S) (O))) (times)) (f)) (((refl) (bool)) (true))))) (n).
Definition congruent_exp_pred_SO : forall p : nat, forall a : nat, ((prime) (p)) -> ((Not) (((divides) (p)) (a))) -> (((congruent) (((exp) (a)) ((pred) (p)))) ((S) (O))) (p) := fun p : nat => fun a : nat => fun primep : (prime) (p) => fun ndiv : (Not) (((divides) (p)) (a)) => ((((((divides_to_congruent) (((exp) (a)) ((pred) (p)))) ((S) (O))) (p)) (((prime_to_lt_O) (p)) (primep))) ((((lt_O_exp) (a)) ((pred) (p))) ((((((match_nat_prop) (fun Joker_ : nat => ((Not) (((divides) (p)) (Joker_))) -> ((lt) (O)) (Joker_))) (fun Jokerclearme : (Not) (((divides) (p)) (O)) => ((((Not_ind) (((divides) (p)) (O))) (((lt) (O)) (O))) (fun div0 : (((divides) (p)) (O)) -> False => ((falsity) (((lt) (O)) (O))) ((div0) (((((quotient) (p)) (O)) (O)) (((((((rewrite_l) (nat)) (O)) (fun Joker_ : nat => (((eq) (nat)) (O)) (Joker_))) (((refl) (nat)) (O))) (((times) (p)) (O))) ((times_n_O) (p))))))) (Jokerclearme))) (fun auto : nat => fun auto' : (Not) (((divides) (p)) ((S) (auto))) => (lt_O_S) (auto))) (a)) (ndiv)))) (((((((match_Or_prop) (((divides) (p)) (((minus) (((exp) (a)) ((pred) (p)))) ((S) (O))))) (((divides) (p)) ((fact) ((pred) (p))))) (((divides) (p)) (((minus) (((exp) (a)) ((pred) (p)))) ((S) (O))))) (fun auto : ((divides) (p)) (((minus) (((exp) (a)) ((pred) (p)))) ((S) (O))) => auto)) (fun Hdiv : ((divides) (p)) ((fact) ((pred) (p))) => ((falsity) (((divides) (p)) (((minus) (((exp) (a)) ((pred) (p)))) ((S) (O))))) ((((absurd) (((divides) (p)) ((fact) ((pred) (p))))) (Hdiv)) (((((prime_to_not_divides_fact) (p)) (primep)) ((pred) (p))) ((((le_S_S_to_le) ((S) ((pred) (p)))) (p)) (((((((eq_ind_r) (nat)) (p)) (fun x : nat => ((le) ((S) (x))) ((S) (p)))) ((le_n) ((S) (p)))) ((S) ((pred) (p)))) (((S_pred) (p)) (((prime_to_lt_O) (p)) (primep))))))))) ((((((divides_times_to_divides) (p)) (((minus) (((exp) (a)) ((pred) (p)))) ((S) (O)))) ((fact) ((pred) (p)))) (primep)) (((((((eq_ind_r) (nat)) (((times) ((fact) ((pred) (p)))) (((minus) (((exp) (a)) ((pred) (p)))) ((S) (O))))) (fun x : nat => ((divides) (p)) (x))) (((((((eq_ind_r) (nat)) (((minus) (((times) ((fact) ((pred) (p)))) (((exp) (a)) ((pred) (p))))) (((times) ((fact) ((pred) (p)))) ((S) (O))))) (fun x : nat => ((divides) (p)) (x))) (((((((eq_ind) (nat)) ((fact) ((pred) (p)))) (fun x_1 : nat => ((divides) (p)) (((minus) (((times) ((fact) ((pred) (p)))) (((exp) (a)) ((pred) (p))))) (x_1)))) (((((((eq_ind_r) (nat)) (((((((bigop) (nat)) (((minus) ((S) ((pred) (p)))) ((S) (O)))) (fun i : nat => true)) ((S) (O))) (times)) (fun i : nat => ((plus) (i)) ((S) (O))))) (fun x : nat => ((divides) (p)) (((minus) (((times) (x)) (((exp) (a)) ((pred) (p))))) (x)))) (((((((eq_ind_r) (nat)) (((times) (((exp) (a)) ((pred) (p)))) (((((((bigop) (nat)) (((minus) ((S) ((pred) (p)))) ((S) (O)))) (fun i : nat => true)) ((S) (O))) (times)) (fun i : nat => ((plus) (i)) ((S) (O)))))) (fun x : nat => ((divides) (p)) (((minus) (x)) (((((((bigop) (nat)) (((minus) ((S) ((pred) (p)))) ((S) (O)))) (fun i : nat => true)) ((S) (O))) (times)) (fun i : nat => ((plus) (i)) ((S) (O))))))) (((((((eq_ind_r) (nat)) (((minus) ((S) ((pred) (p)))) ((S) (O)))) (fun x : nat => ((divides) (p)) (((minus) (((times) (((exp) (a)) (x))) (((((((bigop) (nat)) (((minus) ((S) ((pred) (p)))) ((S) (O)))) (fun i : nat => true)) ((S) (O))) (times)) (fun i : nat => ((plus) (i)) ((S) (O)))))) (((((((bigop) (nat)) (((minus) ((S) ((pred) (p)))) ((S) (O)))) (fun i : nat => true)) ((S) (O))) (times)) (fun i : nat => ((plus) (i)) ((S) (O))))))) (((((((eq_ind_r) (nat)) (((((((bigop) (nat)) (((minus) ((S) ((pred) (p)))) ((S) (O)))) (fun i : nat => true)) ((S) (O))) (times)) (fun i : nat => ((times) (a)) (((plus) (i)) ((S) (O)))))) (fun x : nat => ((divides) (p)) (((minus) (x)) (((((((bigop) (nat)) (((minus) ((S) ((pred) (p)))) ((S) (O)))) (fun i : nat => true)) ((S) (O))) (times)) (fun i : nat => ((plus) (i)) ((S) (O))))))) ((((((congruent_to_divides) (((((((bigop) (nat)) (((minus) ((S) ((pred) (p)))) ((S) (O)))) (fun i : nat => true)) ((S) (O))) (times)) (fun i : nat => ((times) (a)) (((plus) (i)) ((S) (O)))))) (((((((bigop) (nat)) (((minus) ((S) ((pred) (p)))) ((S) (O)))) (fun i : nat => true)) ((S) (O))) (times)) (fun i : nat => ((plus) (i)) ((S) (O))))) (p)) (((prime_to_lt_O) (p)) (primep))) (((((((transitive_congruent) (p)) (((((((bigop) (nat)) (((minus) ((S) ((pred) (p)))) ((S) (O)))) (fun i : nat => true)) ((S) (O))) (times)) (fun i : nat => ((times) (a)) (((plus) (i)) ((S) (O)))))) (((((((bigop) (nat)) (((minus) ((S) ((pred) (p)))) ((S) (O)))) (fun i : nat => true)) ((S) (O))) (times)) (fun i : nat => ((mod) (((times) (a)) (((plus) (i)) ((S) (O))))) (p)))) (((((((bigop) (nat)) (((minus) ((S) ((pred) (p)))) ((S) (O)))) (fun i : nat => true)) ((S) (O))) (times)) (fun i : nat => ((plus) (i)) ((S) (O))))) (((((congruent_pi) (fun m : nat => ((times) (a)) (((plus) (m)) ((S) (O))))) (((minus) ((S) ((pred) (p)))) ((S) (O)))) (p)) (((prime_to_lt_O) (p)) (primep)))) (((((((eq_ind) (nat)) (((((((bigop) (nat)) (((minus) ((S) ((pred) (p)))) ((S) (O)))) (fun i : nat => true)) ((S) (O))) (times)) (fun i : nat => ((plus) (i)) ((S) (O))))) (fun x_1 : nat => (((congruent) (x_1)) (((((((bigop) (nat)) (((minus) ((S) ((pred) (p)))) ((S) (O)))) (fun i : nat => true)) ((S) (O))) (times)) (fun i : nat => ((plus) (i)) ((S) (O))))) (p))) (((congruent_n_n) (((((((bigop) (nat)) (((minus) ((S) ((pred) (p)))) ((S) (O)))) (fun i : nat => true)) ((S) (O))) (times)) (fun i : nat => ((plus) (i)) ((S) (O))))) (p))) (((((((bigop) (nat)) (((minus) ((S) ((pred) (p)))) ((S) (O)))) (fun i : nat => true)) ((S) (O))) (times)) (fun i : nat => ((mod) (((times) (a)) (((plus) (i)) ((S) (O))))) (p)))) (((((((eq_ind_r) (nat)) (((((((bigop) (nat)) ((S) ((pred) (p)))) (fun i : nat => ((andb) (((leb) ((S) (O))) (i))) (true))) ((S) (O))) (times)) (fun i : nat => i))) (fun x : nat => (((eq) (nat)) (x)) (((((((bigop) (nat)) (((minus) ((S) ((pred) (p)))) ((S) (O)))) (fun i : nat => true)) ((S) (O))) (times)) (fun i : nat => ((mod) (((times) (a)) (((plus) (i)) ((S) (O))))) (p))))) (((((((eq_ind_r) (nat)) (((((((bigop) (nat)) ((S) ((pred) (p)))) (fun i : nat => ((andb) (((leb) ((S) (O))) (i))) (true))) ((S) (O))) (times)) (fun i : nat => ((mod) (((times) (a)) (i))) (p)))) (fun x : nat => (((eq) (nat)) (((((((bigop) (nat)) ((S) ((pred) (p)))) (fun i : nat => ((andb) (((leb) ((S) (O))) (i))) (true))) ((S) (O))) (times)) (fun i : nat => i))) (x))) (((((sym_eq) (nat)) (((((((bigop) (nat)) ((S) ((pred) (p)))) (fun i : nat => ((andb) (((leb) ((S) (O))) (i))) (true))) ((S) (O))) (times)) (fun i : nat => ((mod) (((times) (a)) (i))) (p)))) (((((((bigop) (nat)) ((S) ((pred) (p)))) (fun i : nat => ((andb) (((leb) ((S) (O))) (i))) (true))) ((S) (O))) (times)) (fun i : nat => i))) ((((((((bigop_iso) ((S) ((pred) (p)))) ((S) ((pred) (p)))) (fun Joker_ : nat => ((andb) (((leb) ((S) (O))) (Joker_))) (true))) (fun Joker_ : nat => ((andb) (((leb) ((S) (O))) (Joker_))) (true))) (fun Joker_ : nat => ((mod) (((times) (a)) (Joker_))) (p))) (fun Joker_ : nat => Joker_)) (fun z : Prop => fun f : forall x : (nat) -> nat, (((Ex) ((nat) -> nat)) (fun k : (nat) -> nat => ((And) (((And) (forall i : nat, (((lt) (i)) ((S) ((pred) (p)))) -> ((((eq) (bool)) (((andb) (((leb) ((S) (O))) (i))) (true))) (true)) -> (((eq) (nat)) (((mod) (((times) (a)) (i))) (p))) ((x) (i)))) (((((((((sub_hk) (x)) (k)) ((S) ((pred) (p)))) ((S) ((pred) (p)))) (fun Joker0 : nat => ((andb) (((leb) ((S) (O))) (Joker0))) (true))) (fun Joker0 : nat => ((andb) (((leb) ((S) (O))) (Joker0))) (true))) (fun Joker0 : nat => ((mod) (((times) (a)) (Joker0))) (p))) (fun Joker0 : nat => Joker0)))) (((((((((sub_hk) (k)) (x)) ((S) ((pred) (p)))) ((S) ((pred) (p)))) (fun Joker0 : nat => ((andb) (((leb) ((S) (O))) (Joker0))) (true))) (fun Joker0 : nat => ((andb) (((leb) ((S) (O))) (Joker0))) (true))) (fun Joker0 : nat => Joker0)) (fun Joker0 : nat => ((mod) (((times) (a)) (Joker0))) (p))))) -> z => ((f) (fun i : nat => ((mod) (((times) (a)) (i))) (p))) (fun z0 : Prop => fun f2 : forall y : (nat) -> nat, (((And) (((And) (forall i : nat, (((lt) (i)) ((S) ((pred) (p)))) -> ((((eq) (bool)) (((andb) (((leb) ((S) (O))) (i))) (true))) (true)) -> (((eq) (nat)) (((mod) (((times) (a)) (i))) (p))) (((mod) (((times) (a)) (i))) (p)))) (((((((((sub_hk) (fun i : nat => ((mod) (((times) (a)) (i))) (p))) (y)) ((S) ((pred) (p)))) ((S) ((pred) (p)))) (fun Joker0 : nat => ((andb) (((leb) ((S) (O))) (Joker0))) (true))) (fun Joker0 : nat => ((andb) (((leb) ((S) (O))) (Joker0))) (true))) (fun Joker0 : nat => ((mod) (((times) (a)) (Joker0))) (p))) (fun Joker0 : nat => Joker0)))) (((((((((sub_hk) (y)) (fun i : nat => ((mod) (((times) (a)) (i))) (p))) ((S) ((pred) (p)))) ((S) ((pred) (p)))) (fun Joker0 : nat => ((andb) (((leb) ((S) (O))) (Joker0))) (true))) (fun Joker0 : nat => ((andb) (((leb) ((S) (O))) (Joker0))) (true))) (fun Joker0 : nat => Joker0)) (fun Joker0 : nat => ((mod) (((times) (a)) (Joker0))) (p)))) -> z0 => ((f2) (((invert_permut) ((pred) (p))) (fun i : nat => ((mod) (((times) (a)) (i))) (p)))) (fun z1 : Prop => fun f0 : (((And) (forall i : nat, (((lt) (i)) ((S) ((pred) (p)))) -> ((((eq) (bool)) (((andb) (((leb) ((S) (O))) (i))) (true))) (true)) -> (((eq) (nat)) (((mod) (((times) (a)) (i))) (p))) (((mod) (((times) (a)) (i))) (p)))) (((((((((sub_hk) (fun i : nat => ((mod) (((times) (a)) (i))) (p))) (((invert_permut) ((pred) (p))) (fun i : nat => ((mod) (((times) (a)) (i))) (p)))) ((S) ((pred) (p)))) ((S) ((pred) (p)))) (fun Joker0 : nat => ((andb) (((leb) ((S) (O))) (Joker0))) (true))) (fun Joker0 : nat => ((andb) (((leb) ((S) (O))) (Joker0))) (true))) (fun Joker0 : nat => ((mod) (((times) (a)) (Joker0))) (p))) (fun Joker0 : nat => Joker0))) -> (((((((((sub_hk) (((invert_permut) ((pred) (p))) (fun i : nat => ((mod) (((times) (a)) (i))) (p)))) (fun i : nat => ((mod) (((times) (a)) (i))) (p))) ((S) ((pred) (p)))) ((S) ((pred) (p)))) (fun Joker0 : nat => ((andb) (((leb) ((S) (O))) (Joker0))) (true))) (fun Joker0 : nat => ((andb) (((leb) ((S) (O))) (Joker0))) (true))) (fun Joker0 : nat => Joker0)) (fun Joker0 : nat => ((mod) (((times) (a)) (Joker0))) (p))) -> z1 => ((f0) (fun z2 : Prop => fun f20 : (forall x : nat, (((lt) (x)) ((S) ((pred) (p)))) -> ((((eq) (bool)) (((andb) (((leb) ((S) (O))) (x))) (true))) (true)) -> (((eq) (nat)) (((mod) (((times) (a)) (x))) (p))) (((mod) (((times) (a)) (x))) (p))) -> (((((((((sub_hk) (fun i : nat => ((mod) (((times) (a)) (i))) (p))) (((invert_permut) ((pred) (p))) (fun i : nat => ((mod) (((times) (a)) (i))) (p)))) ((S) ((pred) (p)))) ((S) ((pred) (p)))) (fun Joker0 : nat => ((andb) (((leb) ((S) (O))) (Joker0))) (true))) (fun Joker0 : nat => ((andb) (((leb) ((S) (O))) (Joker0))) (true))) (fun Joker0 : nat => ((mod) (((times) (a)) (Joker0))) (p))) (fun Joker0 : nat => Joker0)) -> z2 => ((f20) (fun i : nat => fun lti : ((lt) (i)) ((S) ((pred) (p))) => fun Joker_ : (((eq) (bool)) (((andb) (((leb) ((S) (O))) (i))) (true))) (true) => ((refl) (nat)) (((mod) (((times) (a)) (i))) (p)))) (fun i : nat => fun lti : ((lt) (i)) ((S) ((pred) (p))) => fun posi : (((eq) (bool)) (((andb) (((leb) ((S) (O))) (i))) (true))) (true) => fun z3 : Prop => fun f3 : (((And) (((lt) (((mod) (((times) (a)) (i))) (p))) ((S) ((pred) (p))))) ((((eq) (bool)) (((andb) (((leb) ((S) (O))) (((mod) (((times) (a)) (i))) (p)))) (true))) (true))) -> ((((eq) (nat)) ((((invert_permut) ((pred) (p))) (fun i0 : nat => ((mod) (((times) (a)) (i0))) (p))) (((mod) (((times) (a)) (i))) (p)))) (i)) -> z3 => ((f3) (fun z4 : Prop => fun f4 : (((lt) (((mod) (((times) (a)) (i))) (p))) ((S) ((pred) (p)))) -> ((((eq) (bool)) (((andb) (((leb) ((S) (O))) (((mod) (((times) (a)) (i))) (p)))) (true))) (true)) -> z4 => ((f4) (((((((eq_ind_r) (nat)) (p)) (fun x : nat => ((lt) (((mod) (((times) (a)) (i))) (p))) (x))) ((((lt_mod_m_m) (((times) (a)) (i))) (p)) (((prime_to_lt_O) (p)) (primep)))) ((S) ((pred) (p)))) (((S_pred) (p)) (((prime_to_lt_O) (p)) (primep))))) (((((((eq_ind_r) (bool)) (true)) (fun x : bool => (((eq) (bool)) (((andb) (x)) (true))) (true))) ((((((eq_match_bool_type_true) (bool)) (true)) (false)) (fun y : bool => (((eq) (bool)) (((andb) (true)) (true))) (y))) (((refl) (bool)) (((andb) (true)) (true))))) (((leb) ((S) (O))) (((mod) (((times) (a)) (i))) (p)))) ((((le_to_leb_true) ((S) (O))) (((mod) (((times) (a)) (i))) (p))) (((((((match_Or_prop) (((lt) (O)) (((mod) (((times) (a)) (i))) (p)))) ((((eq) (nat)) (O)) (((mod) (((times) (a)) (i))) (p)))) (((le) ((S) (O))) (((mod) (((times) (a)) (i))) (p)))) (fun auto : ((lt) (O)) (((mod) (((times) (a)) (i))) (p)) => auto)) (fun H : (((eq) (nat)) (O)) (((mod) (((times) (a)) (i))) (p)) => ((falsity) (((le) ((S) (O))) (((mod) (((times) (a)) (i))) (p)))) ((((absurd) (((divides) (p)) (((times) (a)) (i)))) (((((mod_O_to_divides) (p)) (((times) (a)) (i))) (((prime_to_lt_O) (p)) (primep))) (((((sym_eq) (nat)) (O)) (((mod) (((times) (a)) (i))) (p))) (H)))) (((((not_to_not) (((divides) (p)) (((times) (a)) (i)))) (((divides) (p)) (a))) (fun Hdiv : ((divides) (p)) (((times) (a)) (i)) => ((((((match_Or_prop) (((divides) (p)) (a))) (((divides) (p)) (i))) (((divides) (p)) (a))) (fun auto : ((divides) (p)) (a) => auto)) (fun divpi : ((divides) (p)) (i) => ((falsity) (((divides) (p)) (a))) ((((absurd) (((lt) (i)) ((S) ((pred) (p))))) (lti)) ((((le_to_not_lt) ((S) ((pred) (p)))) (i)) (((((((eq_ind_r) (nat)) (p)) (fun x : nat => ((le) (x)) (i))) (((((divides_to_le) (p)) (i)) ((((leb_true_to_le) ((S) (O))) (i)) ((((andb_true_l) (((leb) ((S) (O))) (i))) (true)) (posi)))) (divpi))) ((S) ((pred) (p)))) (((S_pred) (p)) (((prime_to_lt_O) (p)) (primep)))))))) ((((((divides_times_to_divides) (p)) (a)) (i)) (primep)) (Hdiv)))) (ndiv))))) ((((le_to_or_lt_eq) (O)) (((mod) (((times) (a)) (i))) (p))) ((le_O_n) (((mod) (((times) (a)) (i))) (p))))))))) ((((((invert_permut_f) (fun i0 : nat => ((mod) (((times) (a)) (i0))) (p))) ((pred) (p))) (i)) ((((le_S_S_to_le) (i)) ((pred) (p))) (lti))) ((((((match_And_prop) (forall i1 : nat, (((le) (i1)) ((pred) (p))) -> ((le) (((mod) (((times) (a)) (i1))) (p))) ((pred) (p)))) (((injn) (fun n : nat => ((mod) (((times) (a)) (n))) (p))) ((pred) (p)))) (((injn) (fun i0 : nat => ((mod) (((times) (a)) (i0))) (p))) ((pred) (p)))) (fun auto : forall i0 : nat, (((le) (i0)) ((pred) (p))) -> ((le) (((mod) (((times) (a)) (i0))) (p))) ((pred) (p)) => fun auto' : ((injn) (fun n : nat => ((mod) (((times) (a)) (n))) (p))) ((pred) (p)) => auto')) (((((permut_mod) (p)) (a)) (primep)) (ndiv))))))) ((((((match_And_prop) (forall i : nat, (((le) (i)) ((pred) (p))) -> ((le) ((((invert_permut) ((pred) (p))) (fun n : nat => ((mod) (((times) (a)) (n))) (p))) (i))) ((pred) (p)))) (((injn) (((invert_permut) ((pred) (p))) (fun n : nat => ((mod) (((times) (a)) (n))) (p)))) ((pred) (p)))) (((((((((sub_hk) (((invert_permut) ((pred) (p))) (fun i : nat => ((mod) (((times) (a)) (i))) (p)))) (fun i : nat => ((mod) (((times) (a)) (i))) (p))) ((S) ((pred) (p)))) ((S) ((pred) (p)))) (fun Joker0 : nat => ((andb) (((leb) ((S) (O))) (Joker0))) (true))) (fun Joker0 : nat => ((andb) (((leb) ((S) (O))) (Joker0))) (true))) (fun Joker0 : nat => Joker0)) (fun Joker0 : nat => ((mod) (((times) (a)) (Joker0))) (p)))) (fun le_invert_permut : forall i : nat, (((le) (i)) ((pred) (p))) -> ((le) ((((invert_permut) ((pred) (p))) (fun n : nat => ((mod) (((times) (a)) (n))) (p))) (i))) ((pred) (p)) => fun inj_inv_permut : ((injn) (((invert_permut) ((pred) (p))) (fun n : nat => ((mod) (((times) (a)) (n))) (p)))) ((pred) (p)) => fun i : nat => fun lti : ((lt) (i)) ((S) ((pred) (p))) => fun posi : (((eq) (bool)) (((andb) (((leb) ((S) (O))) (i))) (true))) (true) => fun z2 : Prop => fun f5 : (((And) (((lt) ((((invert_permut) ((pred) (p))) (fun i0 : nat => ((mod) (((times) (a)) (i0))) (p))) (i))) ((S) ((pred) (p))))) ((((eq) (bool)) (((andb) (((leb) ((S) (O))) ((((invert_permut) ((pred) (p))) (fun i0 : nat => ((mod) (((times) (a)) (i0))) (p))) (i)))) (true))) (true))) -> ((((eq) (nat)) (((mod) (((times) (a)) ((((invert_permut) ((pred) (p))) (fun i0 : nat => ((mod) (((times) (a)) (i0))) (p))) (i)))) (p))) (i)) -> z2 => ((f5) (fun z3 : Prop => fun f6 : (((lt) ((((invert_permut) ((pred) (p))) (fun i0 : nat => ((mod) (((times) (a)) (i0))) (p))) (i))) ((S) ((pred) (p)))) -> ((((eq) (bool)) (((andb) (((leb) ((S) (O))) ((((invert_permut) ((pred) (p))) (fun i0 : nat => ((mod) (((times) (a)) (i0))) (p))) (i)))) (true))) (true)) -> z3 => ((f6) ((((le_S_S) ((((invert_permut) ((pred) (p))) (fun i0 : nat => ((mod) (((times) (a)) (i0))) (p))) (i))) ((pred) (p))) (((le_invert_permut) (i)) ((((le_S_S_to_le) (i)) ((pred) (p))) (lti))))) (((((((eq_ind_r) (bool)) (true)) (fun x : bool => (((eq) (bool)) (((andb) (x)) (true))) (true))) ((((((eq_match_bool_type_true) (bool)) (true)) (false)) (fun y : bool => (((eq) (bool)) (((andb) (true)) (true))) (y))) (((refl) (bool)) (((andb) (true)) (true))))) (((leb) ((S) (O))) ((((invert_permut) ((pred) (p))) (fun i0 : nat => ((mod) (((times) (a)) (i0))) (p))) (i)))) ((((le_to_leb_true) ((S) (O))) ((((invert_permut) ((pred) (p))) (fun i0 : nat => ((mod) (((times) (a)) (i0))) (p))) (i))) (((((((match_Or_prop) (((lt) (O)) ((((invert_permut) ((pred) (p))) (fun i0 : nat => ((mod) (((times) (a)) (i0))) (p))) (i)))) ((((eq) (nat)) (O)) ((((invert_permut) ((pred) (p))) (fun i0 : nat => ((mod) (((times) (a)) (i0))) (p))) (i)))) (((le) ((S) (O))) ((((invert_permut) ((pred) (p))) (fun i0 : nat => ((mod) (((times) (a)) (i0))) (p))) (i)))) (fun auto : ((lt) (O)) ((((invert_permut) ((pred) (p))) (fun i0 : nat => ((mod) (((times) (a)) (i0))) (p))) (i)) => auto)) (fun H : (((eq) (nat)) (O)) ((((invert_permut) ((pred) (p))) (fun i0 : nat => ((mod) (((times) (a)) (i0))) (p))) (i)) => ((falsity) (((le) ((S) (O))) ((((invert_permut) ((pred) (p))) (fun i0 : nat => ((mod) (((times) (a)) (i0))) (p))) (i)))) ((((((((eq_ind_r) (nat)) (O)) (fun x : nat => ((((eq) (nat)) (x)) (((mod) (((times) (a)) ((((invert_permut) ((pred) (p))) (fun i0 : nat => ((mod) (((times) (a)) (i0))) (p))) (i)))) (p))) -> False)) (((((((eq_ind_r) (nat)) (i)) (fun x : nat => ((((eq) (nat)) (O)) (x)) -> False)) (fun eq0i : (((eq) (nat)) (O)) (i) => (((((((eq_ind) (nat)) (O)) (fun x_1 : nat => ((((eq) (bool)) (((andb) (((leb) ((S) (O))) (x_1))) (true))) (true)) -> False)) ((((sym_eq_leb) ((S) (O))) (fun y : (nat) -> bool => ((((eq) (bool)) (((andb) ((y) (O))) (true))) (true)) -> False)) ((((((sym_eq_filter_nat_type_S) ((nat) -> bool)) (leb_body)) (O)) (fun y : (nat) -> bool => ((((eq) (bool)) (((andb) ((y) (O))) (true))) (true)) -> False)) ((((sym_eq_leb_body_S) (O)) (fun y : (nat) -> bool => ((((eq) (bool)) (((andb) ((y) (O))) (true))) (true)) -> False)) ((((((sym_eq_match_nat_type_O) (bool)) (false)) (fun q : nat => ((leb) (O)) (q))) (fun y : bool => ((((eq) (bool)) (((andb) (y)) (true))) (true)) -> False)) ((((((sym_eq_match_bool_type_false) (bool)) (true)) (false)) (fun y : bool => ((((eq) (bool)) (y)) (true)) -> False)) (fun H0 : (((eq) (bool)) (false)) (true) => ((((((eq_match_bool_type_true) Prop) (forall P : Prop, P)) (forall P : Prop, (P) -> P)) (fun y : Prop => y)) ((((((eq_match_bool_type_false) Prop) (((((match_bool_type) Prop) (forall P : Prop, (P) -> P)) (forall P : Prop, P)) (true))) (((((match_bool_type) Prop) (forall P : Prop, P)) (forall P : Prop, (P) -> P)) (true))) (fun y : Prop => y)) ((((bool_discr) (false)) (true)) (H0)))) (False)))))))) (i)) (eq0i)) (posi))) (((mod) (((times) (a)) ((((invert_permut) ((pred) (p))) (fun i0 : nat => ((mod) (((times) (a)) (i0))) (p))) (i)))) (p))) ((((((f_invert_permut) (fun i0 : nat => ((mod) (((times) (a)) (i0))) (p))) ((pred) (p))) (i)) ((((le_S_S_to_le) (i)) ((pred) (p))) (lti))) (((((permut_mod) (p)) (a)) (primep)) (ndiv))))) (((mod) (((times) (a)) (O))) (p))) (((((((eq_ind) (nat)) (O)) (fun x_1 : nat => (((eq) (nat)) (((mod) (x_1)) (p))) (O))) (((((((rewrite_r) (nat)) (O)) (fun Joker_ : nat => (((eq) (nat)) (Joker_)) (O))) (((refl) (nat)) (O))) (((mod) (O)) (p))) ((mod_O_n) (p)))) (((times) (a)) (O))) ((times_n_O) (a)))) (((((((eq_f) (nat)) (nat)) (fun i0 : nat => ((mod) (((times) (a)) (i0))) (p))) (O)) ((((invert_permut) ((pred) (p))) (fun i0 : nat => ((mod) (((times) (a)) (i0))) (p))) (i))) (((((((rewrite_l) (nat)) (O)) (fun Joker_ : nat => (((eq) (nat)) (O)) (Joker_))) (((refl) (nat)) (O))) ((((invert_permut) ((pred) (p))) (fun i0 : nat => ((mod) (((times) (a)) (i0))) (p))) (i))) (H)))))) ((((le_to_or_lt_eq) (O)) ((((invert_permut) ((pred) (p))) (fun i0 : nat => ((mod) (((times) (a)) (i0))) (p))) (i))) ((le_O_n) ((((invert_permut) ((pred) (p))) (fun i0 : nat => ((mod) (((times) (a)) (i0))) (p))) (i))))))))) ((((((f_invert_permut) (fun Joker_ : nat => ((mod) (((times) (a)) (Joker_))) (p))) ((pred) (p))) (i)) ((((le_S_S_to_le) (i)) ((pred) (p))) (lti))) (((((permut_mod) (p)) (a)) (primep)) (ndiv))))) ((((permut_invert_permut) (fun n : nat => ((mod) (((times) (a)) (n))) (p))) ((pred) (p))) (((((permut_mod) (p)) (a)) (primep)) (ndiv)))))))))) (((((((bigop) (nat)) (((minus) ((S) ((pred) (p)))) ((S) (O)))) (fun i : nat => true)) ((S) (O))) (times)) (fun i : nat => ((mod) (((times) (a)) (((plus) (i)) ((S) (O))))) (p)))) ((((((bigop_I_gen) ((S) (O))) ((S) ((pred) (p)))) (fun Joker_ : nat => true)) (fun Joker_ : nat => ((mod) (((times) (a)) (Joker_))) (p))) ((lt_O_S) ((pred) (p)))))) (((((((bigop) (nat)) (((minus) ((S) ((pred) (p)))) ((S) (O)))) (fun i : nat => true)) ((S) (O))) (times)) (fun i : nat => ((plus) (i)) ((S) (O))))) ((((((bigop_I_gen) ((S) (O))) ((S) ((pred) (p)))) (fun Joker_ : nat => true)) (fun Joker_ : nat => Joker_)) ((lt_O_S) ((pred) (p))))))))) (((times) (((exp) (a)) (((minus) ((S) ((pred) (p)))) ((S) (O))))) (((((((bigop) (nat)) (((minus) ((S) ((pred) (p)))) ((S) (O)))) (fun i : nat => true)) ((S) (O))) (times)) (fun i : nat => ((plus) (i)) ((S) (O)))))) (((((exp_pi_bc) (a)) ((S) (O))) ((S) ((pred) (p)))) (fun Joker_ : nat => Joker_)))) ((pred) (p))) (((((((rewrite_r) (nat)) (((minus) ((pred) (p))) (O))) (fun Joker_ : nat => (((eq) (nat)) ((pred) (p))) (Joker_))) (((((((rewrite_l) (nat)) ((pred) (p))) (fun Joker_ : nat => (((eq) (nat)) ((pred) (p))) (Joker_))) (((refl) (nat)) ((pred) (p)))) (((minus) ((pred) (p))) (O))) ((minus_n_O) ((pred) (p))))) (((minus) ((S) ((pred) (p)))) ((S) (O)))) (((minus_S_S) ((pred) (p))) (O))))) (((times) (((((((bigop) (nat)) (((minus) ((S) ((pred) (p)))) ((S) (O)))) (fun i : nat => true)) ((S) (O))) (times)) (fun i : nat => ((plus) (i)) ((S) (O))))) (((exp) (a)) ((pred) (p))))) (((commutative_times) (((((((bigop) (nat)) (((minus) ((S) ((pred) (p)))) ((S) (O)))) (fun i : nat => true)) ((S) (O))) (times)) (fun i : nat => ((plus) (i)) ((S) (O))))) (((exp) (a)) ((pred) (p)))))) ((fact) ((pred) (p)))) ((eq_fact_pi_p) ((pred) (p))))) (((times) ((fact) ((pred) (p)))) ((S) (O)))) ((times_n_1) ((fact) ((pred) (p)))))) (((times) ((fact) ((pred) (p)))) (((minus) (((exp) (a)) ((pred) (p)))) ((S) (O))))) ((((distributive_times_minus) ((fact) ((pred) (p)))) (((exp) (a)) ((pred) (p)))) ((S) (O))))) (((times) (((minus) (((exp) (a)) ((pred) (p)))) ((S) (O)))) ((fact) ((pred) (p))))) (((commutative_times) (((minus) (((exp) (a)) ((pred) (p)))) ((S) (O)))) ((fact) ((pred) (p))))))).
